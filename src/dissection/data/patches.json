[
  {
    "id": 1,
    "bugId": 1,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/util/ShapeList.java\n+++ b/source/org/jfree/chart/util/ShapeList.java\n@@ -108,7 +108,14 @@ public boolean equals(Object obj) {\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+        ShapeList that = (ShapeList) obj;\n+        int listSize = size();\n+        for (int i = 0; i < listSize; i++) {\n+           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {\n+               return false;\n+           }\n+        }\n+        return true;\n \n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 2,
    "bugId": 2,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\n+++ b/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\n@@ -62,7 +62,7 @@ public StandardToolTipTagFragmentGenerator() {\n      * @return The formatted HTML area tag attribute(s).\r\n      */\r\n     public String generateToolTipFragment(String toolTipText) {\r\n-        return \" title=\\\"\" + toolTipText\r\n+        return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \r\n             + \"\\\" alt=\\\"\\\"\";\r\n     }\r\n \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 3,
    "bugId": 3,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -941,7 +941,7 @@ public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\r\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\r\n         }\r\n-        if (endIndex < 0) {\r\n+        if ((endIndex < 0)  || (endIndex < startIndex)) {\r\n             emptyRange = true;\r\n         }\r\n         if (emptyRange) {\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 4,
    "bugId": 3,
    "name": "Patch_79_65",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Chart_9/source/org/jfree/data/time/TimeSeriesjava\n+++ /tmp/Cardumen_Defects4J_Chart_9/source/org/jfree/data/time/TimeSeriesjava\n@@ -941,7 +941,7 @@\n \t\t\tendIndex = -(endIndex + 1);\n \t\t\tendIndex = endIndex - 1;\n \t\t}\n-\t\tif (endIndex < 0) {\n+\t\tif (endIndex < startIndex) {\n \t\t\temptyRange = true;\n \t\t}\n \t\tif (emptyRange) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 5,
    "bugId": 3,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -943,3 +943,3 @@\n         }\n-        if (endIndex < 0) {\n+        if ((!((2) != (org.jfree.data.time.TimeSeries.this.data.size()))) || (endIndex < 0)) {\n             emptyRange = true;\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 6,
    "bugId": 3,
    "name": "Patch_11_11",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex 4067e3e..a62e5fe 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -941,7 +941,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+        if (endIndex < startIndex || (endIndex < 0)) {\n             emptyRange = true;\n         }\n         if (emptyRange) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 7,
    "bugId": 4,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/data/time/Week.java\n+++ b/source/org/jfree/data/time/Week.java\n@@ -172,7 +172,7 @@ public Week(Date time) {\n      */\r\n     public Week(Date time, TimeZone zone) {\r\n         // defer argument checking...\r\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\r\n+        this(time, zone, Locale.getDefault());\r\n     }\r\n \r\n     /**\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 8,
    "bugId": 4,
    "name": "Patch_37_1",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/data/time/Week.java b/source/org/jfree/data/time/Week.java\nindex 3cc4138..8228589 100644\n--- a/source/org/jfree/data/time/Week.java\n+++ b/source/org/jfree/data/time/Week.java\n@@ -172,7 +172,7 @@ public class Week extends RegularTimePeriod implements Serializable {\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+        this(time, zone, Locale.getDefault());\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 9,
    "bugId": 4,
    "name": "Patch_1_1",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/data/time/Week.java b/source/org/jfree/data/time/Week.java\nindex 3cc4138..8228589 100644\n--- a/source/org/jfree/data/time/Week.java\n+++ b/source/org/jfree/data/time/Week.java\n@@ -172,7 +172,7 @@ public class Week extends RegularTimePeriod implements Serializable {\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+        this(time, zone, Locale.getDefault());\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 10,
    "bugId": 5,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -297,9 +297,9 @@ private void updateBounds(TimePeriod period, int index) {\n         }\r\n         \r\n         if (this.maxMiddleIndex >= 0) {\r\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n+            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\r\n                 .getTime();\r\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n+            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\r\n                 .getTime();\r\n             long maxMiddle = s + (e - s) / 2;\r\n             if (middle > maxMiddle) {\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 5,
    "name": "Patch_5_5",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..2e0bab3 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -295,7 +295,20 @@ public class TimePeriodValues extends Series implements Serializable {\n         else {\n             this.minMiddleIndex = index;\n         }\n        \n+// start of generated patch\n+if(this.maxMiddleIndex>=0){\n+long s=getDataItem(this.maxMiddleIndex).getPeriod().getStart().getTime();\n+long e=getDataItem(this.maxMiddleIndex).getPeriod().getEnd().getTime();\n+long maxMiddle=s+(e-s)/2;\n+if(middle>maxMiddle){\n+this.maxMiddleIndex=index;\n+}\n+}else {\n+this.maxMiddleIndex=index;\n+}\n+// end of generated patch\n+/* start of original code^M\n         if (this.maxMiddleIndex >= 0) {\n             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                 .getTime();\n@@ -308,7 +321,8 @@ public class TimePeriodValues extends Series implements Serializable {\n         }\n         else {\n             this.maxMiddleIndex = index;\n         }\n+end of original code*/\n         \n         if (this.minEndIndex >= 0) {\n             long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 12,
    "bugId": 5,
    "name": "Patch_12_3",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..ce08139 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -297,7 +297,7 @@ public class TimePeriodValues extends Series implements Serializable {\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n+            long s = getDataItem(this.maxStartIndex).getPeriod().getStart()\n                 .getTime();\n             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 13,
    "bugId": 5,
    "name": "Patch_4_3",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..ce08139 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -297,7 +297,7 @@ public class TimePeriodValues extends Series implements Serializable {\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n+            long s = getDataItem(this.maxStartIndex).getPeriod().getStart()\n                 .getTime();\n             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 14,
    "bugId": 5,
    "name": "Patch_13_3",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..4e4f6e4 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -297,7 +297,7 @@ public class TimePeriodValues extends Series implements Serializable {\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n+            long s = getDataItem(this.maxStartIndex).getPeriod().getStart()\n                 .getTime();\n             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 15,
    "bugId": 6,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/data/xy/XYSeries.java\n+++ b/source/org/jfree/data/xy/XYSeries.java\n@@ -541,11 +541,15 @@ public XYDataItem addOrUpdate(Number x, Number y) {\n         if (x == null) {\r\n             throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n         }\r\n+        if (this.allowDuplicateXValues) {\r\n+            add(x, y);\r\n+            return null;\r\n+        }\r\n \r\n         // if we get to here, we know that duplicate X values are not permitted\r\n         XYDataItem overwritten = null;\r\n         int index = indexOf(x);\r\n-        if (index >= 0 && !this.allowDuplicateXValues) {\r\n+        if (index >= 0) {\r\n             XYDataItem existing = (XYDataItem) this.data.get(index);\r\n             try {\r\n                 overwritten = (XYDataItem) existing.clone();\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 16,
    "bugId": 7,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -1054,6 +1054,8 @@ public TimeSeries createCopy(int start, int end)\n             throw new IllegalArgumentException(\"Requires start <= end.\");\r\n         }\r\n         TimeSeries copy = (TimeSeries) super.clone();\r\n+        copy.minY = Double.NaN;\r\n+        copy.maxY = Double.NaN;\r\n         copy.data = new java.util.ArrayList();\r\n         if (this.data.size() > 0) {\r\n             for (int index = start; index <= end; index++) {\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 17,
    "bugId": 8,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4490,6 +4490,7 @@ public Range getDataRange(ValueAxis axis) {\n                     }\r\n                 }\r\n                 \r\n+                if (r != null) {\r\n                     Collection c = r.getAnnotations();\r\n                     Iterator i = c.iterator();\r\n                     while (i.hasNext()) {\r\n@@ -4498,6 +4499,7 @@ public Range getDataRange(ValueAxis axis) {\n                             includedAnnotations.add(a);\r\n                         }\r\n                     }\r\n+                }\r\n             }\r\n         }\r\n \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 18,
    "bugId": 8,
    "name": "Patch_1_1",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Chart_4/source/org/jfree/chart/plot/XYPlotjava\n+++ /tmp/Cardumen_Defects4J_Chart_4/source/org/jfree/chart/plot/XYPlotjava\n@@ -4490,7 +4490,7 @@\n \t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\tjava.util.Collection c = r.getAnnotations();\n+\t\t\t\tjava.util.Collection c = java.util.Collections.unmodifiableCollection(annotations);\n \t\t\t\tjava.util.Iterator i = c.iterator();\n \t\t\t\twhile (i.hasNext()) {\n \t\t\t\t\torg.jfree.chart.annotations.XYAnnotation a = ((org.jfree.chart.annotations.XYAnnotation) (i.next()));",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 19,
    "bugId": 8,
    "name": "Patch_68_1",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex ec26162..20c0a47 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4490,14 +4490,17 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                     }\n                 }\n                 \n-                    Collection c = r.getAnnotations();\n+                    if (r != null) {\n+\tCollection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n                         XYAnnotation a = (XYAnnotation) i.next();\n                         if (a instanceof XYAnnotationBoundsInfo) {\n                             includedAnnotations.add(a);\n                         }\n-                    }\n+                    }\n+}\n+\n             }\n         }\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 20,
    "bugId": 8,
    "name": "Patch_155_1",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex ec26162..68fe266 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4490,14 +4490,17 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                     }\n                 }\n                 \n-                    Collection c = r.getAnnotations();\n+                    if (r != null) {\n+Collection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n                         XYAnnotation a = (XYAnnotation) i.next();\n                         if (a instanceof XYAnnotationBoundsInfo) {\n                             includedAnnotations.add(a);\n                         }\n-                    }\n+                    }\n+}\n+\n             }\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 21,
    "bugId": 8,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex ec26162..20c0a47 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4490,14 +4490,17 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                     }\n                 }\n                 \n-                    Collection c = r.getAnnotations();\n+                    if (r != null) {\n+\tCollection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n                         XYAnnotation a = (XYAnnotation) i.next();\n                         if (a instanceof XYAnnotationBoundsInfo) {\n                             includedAnnotations.add(a);\n                         }\n-                    }\n+                    }\n+}\n+\n             }\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 22,
    "bugId": 8,
    "name": "Patch_70_2",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex ec26162..1dd3ed6 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4490,14 +4490,17 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                     }\n                 }\n                 \n-                    Collection c = r.getAnnotations();\n+                    if (r != null) {\n+\tCollection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n                         XYAnnotation a = (XYAnnotation) i.next();\n                         if (a instanceof XYAnnotationBoundsInfo) {\n                             includedAnnotations.add(a);\n                         }\n-                    }\n+                    }\n+\t}\n+\n             }\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 23,
    "bugId": 9,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/data/general/DatasetUtilities.java\n+++ b/source/org/jfree/data/general/DatasetUtilities.java\n@@ -752,12 +752,19 @@ public static Range iterateDomainBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n+                    double value = intervalXYData.getXValue(series, item);\r\n                     lvalue = intervalXYData.getStartXValue(series, item);\r\n                     uvalue = intervalXYData.getEndXValue(series, item);\r\n+                    if (!Double.isNaN(value)) {\r\n+                        minimum = Math.min(minimum, value);\r\n+                        maximum = Math.max(maximum, value);\r\n+                    }\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n+                        maximum = Math.max(maximum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n+                        minimum = Math.min(minimum, uvalue);\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r\n@@ -1239,12 +1246,19 @@ public static Range iterateRangeBounds(XYDataset dataset,\n             for (int series = 0; series < seriesCount; series++) {\r\n                 int itemCount = dataset.getItemCount(series);\r\n                 for (int item = 0; item < itemCount; item++) {\r\n+                    double value = ixyd.getYValue(series, item);\r\n                     double lvalue = ixyd.getStartYValue(series, item);\r\n                     double uvalue = ixyd.getEndYValue(series, item);\r\n+                    if (!Double.isNaN(value)) {\r\n+                        minimum = Math.min(minimum, value);\r\n+                        maximum = Math.max(maximum, value);\r\n+                    }\r\n                     if (!Double.isNaN(lvalue)) {\r\n                         minimum = Math.min(minimum, lvalue);\r\n+                        maximum = Math.max(maximum, lvalue);\r\n                     }\r\n                     if (!Double.isNaN(uvalue)) {\r\n+                        minimum = Math.min(minimum, uvalue);\r\n                         maximum = Math.max(maximum, uvalue);\r\n                     }\r\n                 }\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 24,
    "bugId": 10,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public LegendItemCollection getLegendItems() {\n         }\r\n         int index = this.plot.getIndexOf(this);\r\n         CategoryDataset dataset = this.plot.getDataset(index);\r\n-        if (dataset != null) {\r\n+        if (dataset == null) {\r\n             return result;\r\n         }\r\n         int seriesCount = dataset.getRowCount();\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 25,
    "bugId": 10,
    "name": "Patch_2_2",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n+++ /tmp/Cardumen_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n@@ -1794,7 +1794,7 @@\n \t\t}\n \t\tint index = this.plot.getIndexOf(this);\n \t\torg.jfree.data.category.CategoryDataset dataset = this.plot.getDataset(index);\n-\t\tif (dataset != null) {\n+\t\tif ((baseToolTipGenerator) instanceof org.jfree.chart.util.PublicCloneable) {\n \t\t\treturn result;\n \t\t}\n \t\tint seriesCount = dataset.getRowCount();",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 26,
    "bugId": 10,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..271ff12 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,9 +1794,16 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n+// start of generated patch\n+if(dataset==null){\n+return result;\n+}\n+// end of generated patch\n+/* start of original code\n         if (dataset != null) {\n             return result;\n         }\n+end of original code*/\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 27,
    "bugId": 10,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1796,4 +1796,6 @@\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n-            return result;\n+        if (false) {\n+            if (dataset != null) {\n+                return result;\n+            }\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 28,
    "bugId": 10,
    "name": "Patch_2_2",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2019-06-25 06:12:47.660276446 -0400\n+++ /tmp/Arja_Defects4J_Chart_1/patches_oczu/Patch_2/patched/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2019-06-25 06:17:07.762225825 -0400\n@@ -1794,9 +1794,6 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n-            return result;\n-        }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 29,
    "bugId": 10,
    "name": "Patch_1_1",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..4a54655 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (dataset == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 30,
    "bugId": 10,
    "name": "Patch_1_1",
    "tool": "jMutRepair",
    "diff": "--- /tmp/jMutRepair_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n+++ /tmp/jMutRepair_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n@@ -1794,7 +1794,7 @@\n \t\t}\n \t\tint index = this.plot.getIndexOf(this);\n \t\torg.jfree.data.category.CategoryDataset dataset = this.plot.getDataset(index);\n-\t\tif (dataset != null) {\n+\t\tif (dataset == null) {\n \t\t\treturn result;\n \t\t}\n \t\tint seriesCount = dataset.getRowCount();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 31,
    "bugId": 10,
    "name": "Patch_2_2",
    "tool": "jKali",
    "diff": "--- /tmp/jKali_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n+++ /tmp/jKali_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n@@ -1794,7 +1794,7 @@\n \t\t}\n \t\tint index = this.plot.getIndexOf(this);\n \t\torg.jfree.data.category.CategoryDataset dataset = this.plot.getDataset(index);\n-\t\tif (dataset != null) {\n+\t\tif (false) {\n \t\t\treturn result;\n \t\t}\n \t\tint seriesCount = dataset.getRowCount();",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 32,
    "bugId": 10,
    "name": "Patch_1_1",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n+++ /tmp/jGenProg_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n@@ -1794,9 +1794,9 @@\n \t\t}\n \t\tint index = this.plot.getIndexOf(this);\n \t\torg.jfree.data.category.CategoryDataset dataset = this.plot.getDataset(index);\n-\t\tif (dataset != null) {\n-\t\t\treturn result;\n-\t\t}\n+\n+\n+\n \t\tint seriesCount = dataset.getRowCount();\n \t\tif (plot.getRowRenderingOrder().equals(org.jfree.chart.util.SortOrder.ASCENDING)) {\n \t\t\tfor (int i = 0; i < seriesCount; i++) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 33,
    "bugId": 10,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..4a54655 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (dataset == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 34,
    "bugId": 10,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..4a54655 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (dataset == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 35,
    "bugId": 10,
    "name": "Patch_1_1",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..4a54655 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (dataset == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 36,
    "bugId": 10,
    "name": "Patch_2_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2019-06-28 07:37:34.207809383 -0400\n+++ /tmp/RSRepair_Defects4J_Chart_1/patches_ljii/Patch_1/patched/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2019-06-28 07:45:59.258360959 -0400\n@@ -1794,9 +1794,6 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n-            return result;\n-        }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 37,
    "bugId": 10,
    "name": "Patch_1_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2019-06-25 06:25:04.274070235 -0400\n+++ /tmp/GenProg_Defects4J_Chart_1/patches_95wt/Patch_1/patched/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2019-06-25 06:33:56.778556107 -0400\n@@ -1794,9 +1794,6 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n-            return result;\n-        }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 38,
    "bugId": 10,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 39,
    "bugId": 11,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/plot/MultiplePiePlot.java\n+++ b/source/org/jfree/chart/plot/MultiplePiePlot.java\n@@ -142,7 +142,7 @@ public MultiplePiePlot() {\n      */\r\n     public MultiplePiePlot(CategoryDataset dataset) {\r\n         super();\r\n-        this.dataset = dataset;\r\n+        setDataset(dataset);\r\n         PiePlot piePlot = new PiePlot(null);\r\n         this.pieChart = new JFreeChart(piePlot);\r\n         this.pieChart.removeLegend();\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 40,
    "bugId": 11,
    "name": "Patch_14_14",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2019-06-25 08:53:49.092150152 -0400\n+++ /tmp/Arja_Defects4J_Chart_12/patches_4vxr/Patch_14/patched/org/jfree/chart/plot/MultiplePiePlot.java\t2019-06-25 09:02:03.660365672 -0400\n@@ -142,7 +142,7 @@\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+        setDataset(dataset);\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 41,
    "bugId": 11,
    "name": "Patch_66_55",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Chart_12/source/org/jfree/chart/plot/MultiplePiePlotjava\n+++ /tmp/jGenProg_Defects4J_Chart_12/source/org/jfree/chart/plot/MultiplePiePlotjava\n@@ -143,28 +143,12 @@\n \tpublic MultiplePiePlot(org.jfree.data.category.CategoryDataset dataset) {\n \t\tsuper();\n \t\tthis.dataset = dataset;\n-\t\torg.jfree.chart.plot.PiePlot piePlot = new org.jfree.chart.plot.PiePlot(null);\n-\t\tthis.pieChart = new org.jfree.chart.JFreeChart(piePlot);\n-\t\tthis.pieChart.removeLegend();\n-\t\tthis.dataExtractOrder = org.jfree.chart.util.TableOrder.BY_COLUMN;\n-\t\tthis.pieChart.setBackgroundPaint(null);\n-\t\torg.jfree.chart.title.TextTitle seriesTitle = new org.jfree.chart.title.TextTitle(\"Series Title\", \n-\t\tnew java.awt.Font(\"SansSerif\", java.awt.Font.BOLD, 12));\n-\t\tseriesTitle.setPosition(org.jfree.chart.util.RectangleEdge.BOTTOM);\n-\t\tthis.pieChart.setTitle(seriesTitle);\n-\t\tthis.aggregatedItemsKey = \"Other\";\n-\t\tthis.aggregatedItemsPaint = java.awt.Color.lightGray;\n-\t\tthis.sectionPaints = new java.util.HashMap();\n-\t}\n \n \n \n \n \n \n-\tpublic org.jfree.data.category.CategoryDataset getDataset() {\n-\t\treturn this.dataset;\n-\t}\n \n \n \n@@ -172,19 +156,35 @@\n \n \n \n-\tpublic void setDataset(org.jfree.data.category.CategoryDataset dataset) {\n \n \n-\t\tif ((this.dataset) != null) {\n-\t\t\tthis.dataset.removeChangeListener(this);\n-\t\t}\n \n \n-\t\tthis.dataset = dataset;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n \t\tif (dataset != null) {\n \t\t\tsetDatasetGroup(dataset.getGroup());\n \t\t\tdataset.addChangeListener(this);\n-\t\t}\n+\t\t} \t\torg.jfree.chart.plot.PiePlot piePlot = new org.jfree.chart.plot.PiePlot(null); \t\tthis.pieChart = new org.jfree.chart.JFreeChart(piePlot); \t\tthis.pieChart.removeLegend(); \t\tthis.dataExtractOrder = org.jfree.chart.util.TableOrder.BY_COLUMN; \t\tthis.pieChart.setBackgroundPaint(null); \t\torg.jfree.chart.title.TextTitle seriesTitle = new org.jfree.chart.title.TextTitle(\"Series Title\", new java.awt.Font(\"SansSerif\", java.awt.Font.BOLD, 12)); \t\tseriesTitle.setPosition(org.jfree.chart.util.RectangleEdge.BOTTOM); \t\tthis.pieChart.setTitle(seriesTitle); \t\tthis.aggregatedItemsKey = \"Other\"; \t\tthis.aggregatedItemsPaint = java.awt.Color.lightGray; \t\tthis.sectionPaints = new java.util.HashMap();} \tpublic org.jfree.data.category.CategoryDataset getDataset() { \t\treturn this.dataset;} \tpublic void setDataset(org.jfree.data.category.CategoryDataset dataset) { \t\tif ((this.dataset) != null) { \t\t\tthis.dataset.removeChangeListener(this);} \t\tthis.dataset = dataset; \t\tif (dataset != null) { \t\t\tsetDatasetGroup(dataset.getGroup()); \t\t\tdataset.addChangeListener(this);}\n \n \n \t\tdatasetChanged(new org.jfree.data.general.DatasetChangeEvent(this, dataset));",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 42,
    "bugId": 11,
    "name": "Patch_7_5",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/MultiplePiePlot.java b/source/org/jfree/chart/plot/MultiplePiePlot.java\nindex fedc205..5fe04cb 100644\n--- a/source/org/jfree/chart/plot/MultiplePiePlot.java\n+++ b/source/org/jfree/chart/plot/MultiplePiePlot.java\n@@ -142,7 +142,7 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+        setDataset(dataset);\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 43,
    "bugId": 11,
    "name": "Patch_26_15",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/MultiplePiePlot.java b/source/org/jfree/chart/plot/MultiplePiePlot.java\nindex fedc205..5fe04cb 100644\n--- a/source/org/jfree/chart/plot/MultiplePiePlot.java\n+++ b/source/org/jfree/chart/plot/MultiplePiePlot.java\n@@ -142,7 +142,7 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+        setDataset(dataset);\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 44,
    "bugId": 11,
    "name": "Patch_55_32",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Chart_12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2019-06-28 12:40:22.311488174 -0400\n+++ /tmp/RSRepair_Defects4J_Chart_12/patches_xde6/Patch_32/patched/org/jfree/chart/plot/MultiplePiePlot.java\t2019-06-28 12:47:30.305040157 -0400\n@@ -142,7 +142,11 @@\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+        if (dataset != null) {\n+\t\t\tsetDatasetGroup(dataset.getGroup());\n+\t\t\tdataset.addChangeListener(this);\n+\t\t}\n+\t\tthis.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 45,
    "bugId": 11,
    "name": "Patch_473_438",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Chart_12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2019-06-25 15:13:32.030768658 -0400\n+++ /tmp/GenProg_Defects4J_Chart_12/patches_b3n0/Patch_438/patched/org/jfree/chart/plot/MultiplePiePlot.java\t2019-06-25 15:26:55.066491725 -0400\n@@ -142,7 +142,11 @@\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+        if (dataset != null) {\n+\t\t\tsetDatasetGroup(dataset.getGroup());\n+\t\t\tdataset.addChangeListener(this);\n+\t\t}\n+\t\tdouble ep = 0.0;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 46,
    "bugId": 12,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -272,7 +272,7 @@ public static boolean equal(GeneralPath p1, GeneralPath p2) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+        PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 47,
    "bugId": 12,
    "name": "Patch_1_1",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Chart_11/source/org/jfree/chart/util/ShapeUtilitiesjava\n+++ /tmp/Cardumen_Defects4J_Chart_11/source/org/jfree/chart/util/ShapeUtilitiesjava\n@@ -272,7 +272,7 @@\n \t\t\treturn false;\n \t\t}\n \t\tjava.awt.geom.PathIterator iterator1 = p1.getPathIterator(null);\n-\t\tjava.awt.geom.PathIterator iterator2 = p1.getPathIterator(null);\n+\t\tjava.awt.geom.PathIterator iterator2 = p2.getPathIterator(null);\n \t\tdouble[] d1 = new double[6];\n \t\tdouble[] d2 = new double[6];\n \t\tboolean done = (iterator1.isDone()) && (iterator2.isDone());",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 48,
    "bugId": 12,
    "name": "Patch_3_1",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/util/ShapeUtilities.java b/source/org/jfree/chart/util/ShapeUtilities.java\nindex 31aa6c6..f49ecb5 100644\n--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -272,7 +272,7 @@ public class ShapeUtilities {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+        PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 49,
    "bugId": 12,
    "name": "Patch_11_2",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/util/ShapeUtilities.java b/source/org/jfree/chart/util/ShapeUtilities.java\nindex 31aa6c6..f49ecb5 100644\n--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -272,7 +272,7 @@ public class ShapeUtilities {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+        PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 50,
    "bugId": 12,
    "name": "Patch_1_1",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/util/ShapeUtilities.java b/source/org/jfree/chart/util/ShapeUtilities.java\nindex 31aa6c6..f49ecb5 100644\n--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -272,7 +272,7 @@ public class ShapeUtilities {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+        PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 51,
    "bugId": 13,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -452,7 +452,7 @@ protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n         h[3] = h[2];\r\n         if (this.rightBlock != null) {\r\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n-                    new Range(0.0, constraint.getWidth() - w[2]),\r\n+                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\r\n                     LengthConstraintType.RANGE, h[2], null,\r\n                     LengthConstraintType.FIXED);\r\n             Size2D size = this.rightBlock.arrange(g2, c4);\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 52,
    "bugId": 13,
    "name": "Patch_4_4",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Chart_13/source/org/jfree/chart/block/BorderArrangementjava\n+++ /tmp/Cardumen_Defects4J_Chart_13/source/org/jfree/chart/block/BorderArrangementjava\n@@ -451,8 +451,8 @@\n \t\t}\n \t\th[3] = h[2];\n \t\tif ((this.rightBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(0.0, \n-\t\t\tnew org.jfree.data.Range(0.0, ((constraint.getWidth()) - (w[2]))), \n+\t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(0.0, constraint.getWidthRange(), \n+\n \t\t\torg.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, \n \t\t\torg.jfree.chart.block.LengthConstraintType.FIXED);\n \t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 53,
    "bugId": 13,
    "name": "Patch_1364_1268",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/block/BorderArrangement.java b/source/org/jfree/chart/block/BorderArrangement.java\nindex 730aeb3..2b418e7 100644\n--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -452,7 +452,7 @@ public class BorderArrangement implements Arrangement, Serializable {\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+                    new Range(0.0, constraint.getWidth() - w[1]),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 54,
    "bugId": 13,
    "name": "Patch_52_8",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/block/BorderArrangement.java b/source/org/jfree/chart/block/BorderArrangement.java\nindex 730aeb3..acb2d43 100644\n--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -452,7 +452,7 @@ public class BorderArrangement implements Arrangement, Serializable {\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+                    new Range(0.0, serialVersionUID - w[2]),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 55,
    "bugId": 13,
    "name": "Patch_43_19",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/block/BorderArrangement.java b/source/org/jfree/chart/block/BorderArrangement.java\nindex 730aeb3..2b1451c 100644\n--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -452,7 +452,7 @@ public class BorderArrangement implements Arrangement, Serializable {\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+                    new Range(0.0, constraint.getHeight() - w[2]),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 56,
    "bugId": 14,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/data/DefaultKeyedValues.java\n+++ b/source/org/jfree/data/DefaultKeyedValues.java\n@@ -315,30 +315,29 @@ private void rebuildIndex () {\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n-        if (index < this.keys.size()) {\n         rebuildIndex();\n-        }\n     }\n \n     /**\n      * Removes a value from the collection.\n      *\n      * @param key  the item key (<code>null</code> not permitted).\n      * \n      * @throws IllegalArgumentException if <code>key</code> is \n      *     <code>null</code>.\n      * @throws UnknownKeyException if <code>key</code> is not recognised.\n      */\n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n-\t\t\treturn;\n+            throw new UnknownKeyException(\"The key (\" + key \n+                    + \") is not recognised.\");\n         }\n         removeValue(index);\n     }\n     \n     /**\n      * Clears all values from the collection.\n      * \n      * @since 1.0.2\n      */\n--- a/source/org/jfree/data/DefaultKeyedValues2D.java\n+++ b/source/org/jfree/data/DefaultKeyedValues2D.java\n@@ -454,12 +454,21 @@ public void removeColumn(int columnIndex) {\n     public void removeColumn(Comparable columnKey) {\r\n+    \tif (columnKey == null) {\r\n+    \t\tthrow new IllegalArgumentException(\"Null 'columnKey' argument.\");\r\n+    \t}\r\n+    \tif (!this.columnKeys.contains(columnKey)) {\r\n+    \t\tthrow new UnknownKeyException(\"Unknown key: \" + columnKey);\r\n+    \t}\r\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\r\n+            int index = rowData.getIndex(columnKey);\r\n+            if (index >= 0) {\r\n                 rowData.removeValue(columnKey);\r\n+            }\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r\n \r\n     /**\r\n      * Clears all the data and associated keys.\r\n      */\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 57,
    "bugId": 14,
    "name": "Patch_1594_1413",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Chart_18/source/org/jfree/data/DefaultKeyedValues2D.java\t2019-06-25 17:19:06.828764944 -0400\n+++ /tmp/GenProg_Defects4J_Chart_18/patches_ru94/Patch_1413/patched/org/jfree/data/DefaultKeyedValues2D.java\t2019-06-25 17:33:47.981628400 -0400\n@@ -455,9 +455,10 @@\n         Iterator iterator = this.rows.iterator();\n         while (iterator.hasNext()) {\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\n-                rowData.removeValue(columnKey);\n         }\n-        this.columnKeys.remove(columnKey);\n+        if (!(this.columnKeys.contains(columnKey))) {\n+\t\t\tthrow new UnknownKeyException(\"Unrecognised columnKey: \" + columnKey);\n+\t\t}\n     }\n \n     /**\n\n\n--- /tmp/GenProg_Defects4J_Chart_18/source/org/jfree/data/DefaultKeyedValues.java\t2019-06-25 17:19:06.828764944 -0400\n+++ /tmp/GenProg_Defects4J_Chart_18/patches_ru94/Patch_1413/patched/org/jfree/data/DefaultKeyedValues.java\t2019-06-25 17:33:47.985628459 -0400\n@@ -315,9 +315,7 @@\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n-        if (index < this.keys.size()) {\n-        rebuildIndex();\n-        }\n+        this.indexMap.clear();\n     }\n \n     /**\n@@ -332,6 +330,9 @@\n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new UnknownKeyException(\"Key not found: \" + key);\n+\t\t\t}\n \t\t\treturn;\n         }\n         removeValue(index);\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 58,
    "bugId": 15,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,6 +2163,9 @@ public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n+        if (markers == null) {\r\n+            return false;\r\n+        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r\n@@ -2445,6 +2448,9 @@ public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n+        if (markers == null) {\r\n+            return false;\r\n+        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,6 +2290,9 @@ public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n+        if (markers == null) {\r\n+            return false;\r\n+        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r\n@@ -2526,6 +2529,9 @@ public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\r\n                     index));\r\n         }\r\n+        if (markers == null) {\r\n+            return false;\r\n+        }\r\n         boolean removed = markers.remove(marker);\r\n         if (removed && notify) {\r\n             fireChangeEvent();\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 59,
    "bugId": 15,
    "name": "Patch_20_8",
    "tool": "ACS",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..cd0a402 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,7 +2163,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+if (markers == null){return false;}        boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n@@ -2445,7 +2445,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+if (markers == null){return false;}        boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\ndiff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..a6234ab 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,7 +2290,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+if (markers == null){return false;}        boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n@@ -2526,7 +2526,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+if (markers == null){return false;}        boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 60,
    "bugId": 15,
    "name": "Patch_124_3",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..c10fd5a 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,7 +2290,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 61,
    "bugId": 15,
    "name": "Patch_170_4",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..8399cea 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2526,7 +2526,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 62,
    "bugId": 15,
    "name": "Patch_78_2",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..6888e79 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2445,7 +2445,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 63,
    "bugId": 15,
    "name": "Patch_39_1",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..d997068 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,7 +2163,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 64,
    "bugId": 15,
    "name": "Patch_832_204",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..8399cea 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2526,7 +2526,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 65,
    "bugId": 15,
    "name": "Patch_610_149",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..c10fd5a 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,7 +2290,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 66,
    "bugId": 15,
    "name": "Patch_194_47",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..d997068 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,7 +2163,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 67,
    "bugId": 15,
    "name": "Patch_388_94",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..6888e79 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2445,7 +2445,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 68,
    "bugId": 15,
    "name": "Patch_9_6",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..74dfab4 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,7 +2290,10 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 69,
    "bugId": 15,
    "name": "Patch_6_4",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..1f15fe3 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2445,7 +2445,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 70,
    "bugId": 15,
    "name": "Patch_3_2",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..165b1c1 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,7 +2163,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 71,
    "bugId": 15,
    "name": "Patch_12_8",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..5cacbc6 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2526,7 +2526,10 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 72,
    "bugId": 15,
    "name": "Patch_38_1",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..b2e1e8b 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,7 +2163,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = getAnnotations().remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 73,
    "bugId": 15,
    "name": "Patch_115_3",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..3a361b2 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,7 +2290,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = getAnnotations().remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 74,
    "bugId": 15,
    "name": "Patch_154_4",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..ed59298 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2526,7 +2526,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = getAnnotations().remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 75,
    "bugId": 15,
    "name": "Patch_76_2",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..86d07f3 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2445,7 +2445,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = getAnnotations().remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 76,
    "bugId": 16,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java\n+++ b/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java\n@@ -154,6 +154,7 @@ public void add(BoxAndWhiskerItem item, Comparable rowKey,\n                 && this.minimumRangeValueColumn == c))  {\r\n             updateBounds();\r\n         }\r\n+        else {\r\n         \r\n             double minval = Double.NaN;\r\n             if (item.getMinOutlier() != null) {\r\n@@ -185,6 +186,7 @@ else if (minval < this.minimumRangeValue) {\n                 this.minimumRangeValueRow = r;\r\n                 this.minimumRangeValueColumn = c;\r\n             }\r\n+        }\r\n         \r\n         this.rangeBounds = new Range(this.minimumRangeValue,\r\n               this.maximumRangeValue);\r\n@@ -738,7 +740,44 @@ public List getOutliers(Comparable rowKey, Comparable columnKey) {\n      */\r\n     private void updateBounds() {\r\n         this.minimumRangeValue = Double.NaN;\r\n+        this.minimumRangeValueRow = -1;\r\n+        this.minimumRangeValueColumn = -1;\r\n         this.maximumRangeValue = Double.NaN;\r\n+        this.maximumRangeValueRow = -1;\r\n+        this.maximumRangeValueColumn = -1;\r\n+        int rowCount = getRowCount();\r\n+        int columnCount = getColumnCount();\r\n+        for (int r = 0; r < rowCount; r++) {\r\n+            for (int c = 0; c < columnCount; c++) {\r\n+                BoxAndWhiskerItem item = getItem(r, c);\r\n+                if (item != null) {\r\n+                    Number min = item.getMinOutlier();\r\n+                    if (min != null) {\r\n+                        double minv = min.doubleValue();\r\n+                        if (!Double.isNaN(minv)) {\r\n+                            if (minv < this.minimumRangeValue || Double.isNaN(\r\n+                                    this.minimumRangeValue)) {\r\n+                                this.minimumRangeValue = minv;\r\n+                                this.minimumRangeValueRow = r;\r\n+                                this.minimumRangeValueColumn = c;\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                    Number max = item.getMaxOutlier();\r\n+                    if (max != null) {\r\n+                        double maxv = max.doubleValue();\r\n+                        if (!Double.isNaN(maxv)) {\r\n+                            if (maxv > this.maximumRangeValue || Double.isNaN(\r\n+                                    this.maximumRangeValue)) {\r\n+                                this.maximumRangeValue = maxv;\r\n+                                this.maximumRangeValueRow = r;\r\n+                                this.maximumRangeValueColumn = c;\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n     }\r\n     \r\n     /**\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 77,
    "bugId": 17,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/plot/PiePlot.java\n+++ b/source/org/jfree/chart/plot/PiePlot.java\n@@ -1375,6 +1375,9 @@ public void setExplodePercent(Comparable key, double percent) {\n      * @return The percent.\r\n      */\r\n     public double getMaximumExplodePercent() {\r\n+        if (this.dataset == null) {\r\n+            return 0.0;\r\n+        }\r\n         double result = 0.0;\r\n         Iterator iterator = this.dataset.getKeys().iterator();\r\n         while (iterator.hasNext()) {\r\n@@ -2048,8 +2051,10 @@ public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n      \r\n         PiePlotState state = new PiePlotState(info);\r\n         state.setPassesRequired(2);\r\n+        if (this.dataset != null) {\r\n             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\r\n                     plot.getDataset()));\r\n+        }\r\n         state.setLatestAngle(plot.getStartAngle());\r\n         return state;\r\n         \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 78,
    "bugId": 18,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java\n+++ b/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java\n@@ -204,8 +204,8 @@ public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n \r\n             }\r\n             else {\r\n-                this.seriesKeys = null;\r\n-                this.categoryKeys = null;\r\n+                this.seriesKeys = new Comparable[0];\r\n+                this.categoryKeys = new Comparable[0];\r\n             }\r\n         }\r\n \r\n@@ -335,7 +335,7 @@ public void setCategoryKeys(Comparable[] categoryKeys) {\n         if (categoryKeys == null) {\r\n             throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\r\n         }\r\n-        if (categoryKeys.length != this.startData[0].length) {\r\n+        if (categoryKeys.length != getCategoryCount()) {\r\n             throw new IllegalArgumentException(\r\n                     \"The number of categories does not match the data.\");\r\n         }\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 79,
    "bugId": 19,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -854,7 +854,8 @@ public void delete(int start, int end) {\n      *         subclasses may differ.\r\n      */\r\n     public Object clone() throws CloneNotSupportedException {\r\n-        Object clone = createCopy(0, getItemCount() - 1);\r\n+        TimeSeries clone = (TimeSeries) super.clone();\r\n+        clone.data = (List) ObjectUtilities.deepClone(this.data);\r\n         return clone;\r\n     }\r\n \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 80,
    "bugId": 20,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/plot/ValueMarker.java\n+++ b/source/org/jfree/chart/plot/ValueMarker.java\n@@ -92,7 +92,7 @@ public ValueMarker(double value, Paint paint, Stroke stroke) {\n      */\r\n     public ValueMarker(double value, Paint paint, Stroke stroke, \r\n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\r\n-        super(paint, stroke, paint, stroke, alpha);\r\n+        super(paint, stroke, outlinePaint, outlineStroke, alpha);\r\n         this.value = value;\r\n     }\r\n     \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 81,
    "bugId": 20,
    "name": "Patch_3_3",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/chart/plot/ValueMarker.java b/source/org/jfree/chart/plot/ValueMarker.java\nindex 075683d..1d21811 100644\n--- a/source/org/jfree/chart/plot/ValueMarker.java\n+++ b/source/org/jfree/chart/plot/ValueMarker.java\n@@ -91,9 +91,15 @@ public class ValueMarker extends Marker {\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n+// start of generated patch\n+super(paint,stroke,outlinePaint,outlineStroke,alpha);\n+this.value=value;\n+// end of generated patch\n+/* start of original code\n        super(paint, stroke, paint, stroke, alpha);\n        this.value = value;\n+end of original code*/\n     }\n     \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 82,
    "bugId": 20,
    "name": "Patch_83_6",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/ValueMarker.java b/source/org/jfree/chart/plot/ValueMarker.java\nindex 075683d..58d5289 100644\n--- a/source/org/jfree/chart/plot/ValueMarker.java\n+++ b/source/org/jfree/chart/plot/ValueMarker.java\n@@ -92,7 +92,7 @@ public class ValueMarker extends Marker {\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+        super(paint, stroke, outlinePaint, outlineStroke, alpha);\n         this.value = value;\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 83,
    "bugId": 21,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,6 +695,9 @@ public void setDomainAxes(CategoryAxis[] axes) {\n      * @since 1.0.3\r\n      */\r\n     public int getDomainAxisIndex(CategoryAxis axis) {\r\n+        if (axis == null) {\r\n+            throw new IllegalArgumentException(\"Null 'axis' argument.\");\r\n+        }\r\n         return this.domainAxes.indexOf(axis);\r\n     }\r\n     \r\n@@ -970,6 +973,9 @@ public void setRangeAxes(ValueAxis[] axes) {\n      * @since 1.0.7\r\n      */\r\n     public int getRangeAxisIndex(ValueAxis axis) {\r\n+        if (axis == null) {\r\n+            throw new IllegalArgumentException(\"Null 'axis' argument.\");\r\n+        }\r\n         int result = this.rangeAxes.indexOf(axis);\r\n         if (result < 0) { // try the parent plot\r\n             Plot parent = getParent();\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 84,
    "bugId": 21,
    "name": "Patch_6_4",
    "tool": "ACS",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..268ae73 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,7 +695,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        return this.domainAxes.indexOf(axis);\n+if (axis == null){throw new IllegalArgumentException();}        return this.domainAxes.indexOf(axis);\n     }\n     \n     /**\n@@ -970,7 +970,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        int result = this.rangeAxes.indexOf(axis);\n+if (axis == null){throw new IllegalArgumentException();}        int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n             if (parent instanceof CategoryPlot) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 85,
    "bugId": 21,
    "name": "Patch_81_49",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..5f38aed 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,7 +695,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        return this.domainAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+}\n+return this.domainAxes.indexOf(axis);\n     }\n     \n     /**\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 86,
    "bugId": 21,
    "name": "Patch_164_98",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..b81a415 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -970,7 +970,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        int result = this.rangeAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+}\n+int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n             if (parent instanceof CategoryPlot) {\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 87,
    "bugId": 21,
    "name": "Patch_292_96",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..6e8e92c 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -970,7 +970,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        int result = this.rangeAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Empty variable: \" + axis);\n+}\n+int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n             if (parent instanceof CategoryPlot) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 88,
    "bugId": 21,
    "name": "Patch_144_48",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..abebeed 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,7 +695,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        return this.domainAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Empty variable: \" + axis);\n+}\n+return this.domainAxes.indexOf(axis);\n     }\n     \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 89,
    "bugId": 21,
    "name": "Patch_51_49",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..5f38aed 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,7 +695,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        return this.domainAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+}\n+return this.domainAxes.indexOf(axis);\n     }\n     \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 90,
    "bugId": 21,
    "name": "Patch_56_52",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..b81a415 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -970,7 +970,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        int result = this.rangeAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+}\n+int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n             if (parent instanceof CategoryPlot) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 91,
    "bugId": 21,
    "name": "Patch_68_59",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..fa80ec2 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,7 +695,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        return this.domainAxes.indexOf(axis);\n+        if (axis == null) {\n+\t    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+\t}\n+return this.domainAxes.indexOf(axis);\n     }\n     \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 92,
    "bugId": 21,
    "name": "Patch_143_118",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..a51c0a9 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -970,7 +970,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        int result = this.rangeAxes.indexOf(axis);\n+        if (axis == null) {\n+\t    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+\t}\n+int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n             if (parent instanceof CategoryPlot) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 93,
    "bugId": 22,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/data/KeyedObjects2D.java\n+++ b/source/org/jfree/data/KeyedObjects2D.java\n@@ -228,9 +228,10 @@ public Object getObject(Comparable rowKey, Comparable columnKey) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n                     + \") not recognised.\");\r\n         }\r\n-        if (row >= 0) {\r\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n-            return rowData.getObject(columnKey);\r\n+        int index = rowData.getIndex(columnKey);\r\n+        if (index >= 0) {\r\n+            return rowData.getObject(index);\r\n         }\r\n         else {\r\n             return null;\r\n@@ -315,8 +316,29 @@ public void removeObject(Comparable rowKey, Comparable columnKey) {\n         }\r\n         \r\n         // 2. check whether the column is now empty.\r\n+        allNull = true;\r\n         \r\n+        for (int item = 0, itemCount = this.rows.size(); item < itemCount; \r\n+             item++) {\r\n+            row = (KeyedObjects) this.rows.get(item);\r\n+            int columnIndex = row.getIndex(columnKey);\r\n+            if (columnIndex >= 0 && row.getObject(columnIndex) != null) {\r\n+                allNull = false;\r\n+                break;\r\n+            }\r\n+        }\r\n         \r\n+        if (allNull) {\r\n+            for (int item = 0, itemCount = this.rows.size(); item < itemCount; \r\n+                 item++) {\r\n+                row = (KeyedObjects) this.rows.get(item);\r\n+                int columnIndex = row.getIndex(columnKey);\r\n+                if (columnIndex >= 0) {\r\n+                    row.removeValue(columnIndex);\r\n+                }\r\n+            }\r\n+            this.columnKeys.remove(columnKey);\r\n+        }\r\n     }\r\n \r\n     /**\r\n@@ -342,6 +364,10 @@ public void removeRow(int rowIndex) {\n      */\r\n     public void removeRow(Comparable rowKey) {\r\n         int index = getRowIndex(rowKey);\r\n+        if (index < 0) {\r\n+            throw new UnknownKeyException(\"Row key (\" + rowKey \r\n+                    + \") not recognised.\");\r\n+        }\r\n         removeRow(index);\r\n     }\r\n \r\n@@ -375,7 +401,10 @@ public void removeColumn(Comparable columnKey) {\n         Iterator iterator = this.rows.iterator();\r\n         while (iterator.hasNext()) {\r\n             KeyedObjects rowData = (KeyedObjects) iterator.next();\r\n-                rowData.removeValue(columnKey);\r\n+            int i = rowData.getIndex(columnKey);\r\n+            if (i >= 0) {\r\n+                rowData.removeValue(i);\r\n+            }\r\n         }\r\n         this.columnKeys.remove(columnKey);\r\n     }\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 94,
    "bugId": 23,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/axis/Axis.java\n+++ b/source/org/jfree/chart/axis/Axis.java\n@@ -1189,11 +1189,13 @@ else if (edge == RectangleEdge.RIGHT) {\n         }\r\n         if (plotState != null && hotspot != null) {\r\n             ChartRenderingInfo owner = plotState.getOwner();\r\n+            if (owner != null) {\r\n                 EntityCollection entities = owner.getEntityCollection();\r\n                 if (entities != null) {\r\n                     entities.add(new AxisLabelEntity(this, hotspot, \r\n                             this.labelToolTip, this.labelURL));\r\n                 }\r\n+            }\r\n         }\r\n         return state;\r\n \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 95,
    "bugId": 23,
    "name": "Patch_22_22",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/chart/axis/Axis.java b/source/org/jfree/chart/axis/Axis.java\nindex 78a6c66..4d3d4f7 100644\n--- a/source/org/jfree/chart/axis/Axis.java\n+++ b/source/org/jfree/chart/axis/Axis.java\n@@ -1189,12 +1189,23 @@ public abstract class Axis implements Cloneable, Serializable {\n         }\n         if (plotState != null && hotspot != null) {\n             ChartRenderingInfo owner = plotState.getOwner();\n+// start of generated patch\n+if(plotState!=null&&plotState.getOwner()!=null){\n+ChartRenderingInfo owner=plotState.getOwner();\n+EntityCollection entities=owner.getEntityCollection();\n+if(entities!=null){\n+entities.add(new AxisLabelEntity(this,hotspot,this.labelToolTip,this.labelURL));\n+}\n+}\n+// end of generated patch\n+/* start of original code\n                 EntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n                     entities.add(new AxisLabelEntity(this, hotspot, \n                             this.labelToolTip, this.labelURL));\n                 }\n         }\n+end of original code*/\n         return state;\n \n     }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 96,
    "bugId": 23,
    "name": "Patch_38_1",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/axis/Axis.java b/source/org/jfree/chart/axis/Axis.java\nindex 78a6c66..6f2d34b 100644\n--- a/source/org/jfree/chart/axis/Axis.java\n+++ b/source/org/jfree/chart/axis/Axis.java\n@@ -1189,11 +1189,14 @@ public abstract class Axis implements Cloneable, Serializable {\n         }\n         if (plotState != null && hotspot != null) {\n             ChartRenderingInfo owner = plotState.getOwner();\n-                EntityCollection entities = owner.getEntityCollection();\n+                if (owner != null) {\n+\tEntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n                     entities.add(new AxisLabelEntity(this, hotspot, \n                             this.labelToolTip, this.labelURL));\n-                }\n+                }\n+}\n+\n         }\n         return state;\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 97,
    "bugId": 23,
    "name": "Patch_107_1",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/axis/Axis.java b/source/org/jfree/chart/axis/Axis.java\nindex 78a6c66..5de9803 100644\n--- a/source/org/jfree/chart/axis/Axis.java\n+++ b/source/org/jfree/chart/axis/Axis.java\n@@ -1189,11 +1189,14 @@ public abstract class Axis implements Cloneable, Serializable {\n         }\n         if (plotState != null && hotspot != null) {\n             ChartRenderingInfo owner = plotState.getOwner();\n-                EntityCollection entities = owner.getEntityCollection();\n+                if (owner != null) {\n+EntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n                     entities.add(new AxisLabelEntity(this, hotspot, \n                             this.labelToolTip, this.labelURL));\n-                }\n+                }\n+}\n+\n         }\n         return state;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 98,
    "bugId": 23,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/axis/Axis.java b/source/org/jfree/chart/axis/Axis.java\nindex 78a6c66..6f2d34b 100644\n--- a/source/org/jfree/chart/axis/Axis.java\n+++ b/source/org/jfree/chart/axis/Axis.java\n@@ -1189,11 +1189,14 @@ public abstract class Axis implements Cloneable, Serializable {\n         }\n         if (plotState != null && hotspot != null) {\n             ChartRenderingInfo owner = plotState.getOwner();\n-                EntityCollection entities = owner.getEntityCollection();\n+                if (owner != null) {\n+\tEntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n                     entities.add(new AxisLabelEntity(this, hotspot, \n                             this.labelToolTip, this.labelURL));\n-                }\n+                }\n+}\n+\n         }\n         return state;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 99,
    "bugId": 23,
    "name": "Patch_24_1",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/axis/Axis.java b/source/org/jfree/chart/axis/Axis.java\nindex 78a6c66..630cddc 100644\n--- a/source/org/jfree/chart/axis/Axis.java\n+++ b/source/org/jfree/chart/axis/Axis.java\n@@ -1189,11 +1189,14 @@ public abstract class Axis implements Cloneable, Serializable {\n         }\n         if (plotState != null && hotspot != null) {\n             ChartRenderingInfo owner = plotState.getOwner();\n-                EntityCollection entities = owner.getEntityCollection();\n+                if (owner != null) {\n+\tEntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n                     entities.add(new AxisLabelEntity(this, hotspot, \n                             this.labelToolTip, this.labelURL));\n-                }\n+                }\n+\t}\n+\n         }\n         return state;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 100,
    "bugId": 24,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n@@ -256,6 +256,9 @@ protected void drawHorizontalItem(Graphics2D g2,\n \r\n         // BAR X\r\n         Number meanValue = dataset.getMeanValue(row, column);\r\n+        if (meanValue == null) {\r\n+            return;\r\n+        }\r\n \r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r\n@@ -312,7 +315,9 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n         }\r\n \r\n         // standard deviation lines\r\n-            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\r\n+        Number n = dataset.getStdDevValue(row, column);\r\n+        if (n != null) {\r\n+            double valueDelta = n.doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n@@ -341,6 +346,7 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \r\n                                      lowVal, rectY + rectHeight * 0.75);\r\n             g2.draw(line);\r\n+        }\r\n         \r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r\n@@ -400,6 +406,9 @@ protected void drawVerticalItem(Graphics2D g2,\n \r\n         // BAR Y\r\n         Number meanValue = dataset.getMeanValue(row, column);\r\n+        if (meanValue == null) {\r\n+            return;\r\n+        }\r\n \r\n         double value = meanValue.doubleValue();\r\n         double base = 0.0;\r\n@@ -456,7 +465,9 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n         }\r\n \r\n         // standard deviation lines\r\n-            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\r\n+        Number n = dataset.getStdDevValue(row, column);\r\n+        if (n != null) {\r\n+            double valueDelta = n.doubleValue();\r\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n                     + valueDelta, dataArea, yAxisLocation);\r\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n@@ -484,6 +495,7 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\r\n                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);\r\n             g2.draw(line);\r\n+        }\r\n         \r\n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n                 column);\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 101,
    "bugId": 25,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java\n@@ -432,6 +432,25 @@ public void drawItem(Graphics2D g2, CategoryItemRendererState state,\n      *\r\n      * @since 1.0.7\r\n      */\r\n+    public boolean equals(Object obj) {\r\n+        if (obj == this) {\r\n+            return true;\r\n+        }\r\n+        if (!(obj instanceof MinMaxCategoryRenderer)) {\r\n+            return false;\r\n+        }\r\n+        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj;\r\n+        if (this.plotLines != that.plotLines) {\r\n+            return false;\r\n+        }\r\n+        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) {\r\n+            return false;\r\n+        }\r\n+        if (!this.groupStroke.equals(that.groupStroke)) {\r\n+            return false;\r\n+        }\r\n+        return super.equals(obj);\r\n+    }\r\n \r\n     /**\r\n      * Returns an icon.\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 102,
    "bugId": 26,
    "name": "",
    "tool": "Human",
    "diff": "--- a/source/org/jfree/chart/renderer/GrayPaintScale.java\n+++ b/source/org/jfree/chart/renderer/GrayPaintScale.java\n@@ -123,7 +123,7 @@ public double getUpperBound() {\n     public Paint getPaint(double value) {\r\n         double v = Math.max(value, this.lowerBound);\r\n         v = Math.min(v, this.upperBound);\r\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \r\n+        int g = (int) ((v - this.lowerBound) / (this.upperBound \r\n                 - this.lowerBound) * 255.0);\r\n         return new Color(g, g, g);\r\n     }\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 103,
    "bugId": 26,
    "name": "Patch_623_514",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Chart_24/source/org/jfree/chart/renderer/GrayPaintScalejava\n+++ /tmp/Cardumen_Defects4J_Chart_24/source/org/jfree/chart/renderer/GrayPaintScalejava\n@@ -123,8 +123,8 @@\n \tpublic java.awt.Paint getPaint(double value) {\n \t\tdouble v = java.lang.Math.max(value, this.lowerBound);\n \t\tv = java.lang.Math.min(v, this.upperBound);\n-\t\tint g = ((int) (((value - (this.lowerBound)) / ((this.upperBound) - \n-\t\t(this.lowerBound))) * 255.0));\n+\t\tint g = ((int) ((((lowerBound) - v) / ((lowerBound) - v)) * \n+\t\t255.0));\n \t\treturn new java.awt.Color(g, g, g);\n \t}",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 104,
    "bugId": 26,
    "name": "Patch_2_1",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/renderer/GrayPaintScale.java b/source/org/jfree/chart/renderer/GrayPaintScale.java\nindex 1e1e075..e62c43f 100644\n--- a/source/org/jfree/chart/renderer/GrayPaintScale.java\n+++ b/source/org/jfree/chart/renderer/GrayPaintScale.java\n@@ -123,7 +123,7 @@ public class GrayPaintScale\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+        int g = (int) ((v - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 105,
    "bugId": 26,
    "name": "Patch_16_5",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/renderer/GrayPaintScale.java b/source/org/jfree/chart/renderer/GrayPaintScale.java\nindex 1e1e075..e62c43f 100644\n--- a/source/org/jfree/chart/renderer/GrayPaintScale.java\n+++ b/source/org/jfree/chart/renderer/GrayPaintScale.java\n@@ -123,7 +123,7 @@ public class GrayPaintScale\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+        int g = (int) ((v - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 106,
    "bugId": 26,
    "name": "Patch_7_3",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/renderer/GrayPaintScale.java b/source/org/jfree/chart/renderer/GrayPaintScale.java\nindex 1e1e075..e62c43f 100644\n--- a/source/org/jfree/chart/renderer/GrayPaintScale.java\n+++ b/source/org/jfree/chart/renderer/GrayPaintScale.java\n@@ -123,7 +123,7 @@ public class GrayPaintScale\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+        int g = (int) ((v - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 107,
    "bugId": 27,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -152,7 +152,7 @@ public void enterScope(NodeTraversal t) {\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n     for (Candidate c : candidates) {\n-      if (c.canInline()) {\n+      if (c.canInline(t.getScope())) {\n         c.inlineVariable();\n \n         // If definition c has dependencies, then inlining it may have\n@@ -277,7 +277,7 @@ private Node getDefCfgNode() {\n       return defMetadata.node;\n     }\n \n-    private boolean canInline() {\n+    private boolean canInline(final Scope scope) {\n       // Cannot inline a parameter.\n       if (getDefCfgNode().isFunction()) {\n         return false;\n@@ -372,6 +372,12 @@ public boolean apply(Node input) {\n                   case Token.REGEXP:\n                   case Token.NEW:\n                     return true;\n+                  case Token.NAME:\n+                    Var var = scope.getOwnSlot(input.getString());\n+                    if (var != null\n+                        && var.getParentNode().isCatch()) {\n+                      return true;\n+                    }\n                 }\n                 return false;\n               }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 108,
    "bugId": 27,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_3/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2019-08-08 23:34:03.373208090 -0400\n+++ /tmp/Arja_Defects4J_Closure_3/patches_kaxo/Patch_1/patched/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2019-08-08 23:58:13.241874140 -0400\n@@ -152,20 +152,7 @@\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n     for (Candidate c : candidates) {\n-      if (c.canInline()) {\n-        c.inlineVariable();\n-\n-        // If definition c has dependencies, then inlining it may have\n-        // introduced new dependencies for our other inlining candidates.\n-        //\n-        // MustBeReachingVariableDef uses this dependency graph in its\n-        // analysis, so some of these candidates may no longer be valid.\n-        // We keep track of when the variable dependency graph changed\n-        // so that we can back off appropriately.\n-        if (!c.defMetadata.depends.isEmpty()) {\n-          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-        }\n-      }\n+      break;\n     }\n   }\n \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 109,
    "bugId": 27,
    "name": "Patch_1_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_3/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2019-08-09 00:36:54.554115355 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_3/patches_sf5t/Patch_1/patched/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2019-08-09 01:00:45.834216883 -0400\n@@ -152,20 +152,7 @@\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n     for (Candidate c : candidates) {\n-      if (c.canInline()) {\n-        c.inlineVariable();\n-\n-        // If definition c has dependencies, then inlining it may have\n-        // introduced new dependencies for our other inlining candidates.\n-        //\n-        // MustBeReachingVariableDef uses this dependency graph in its\n-        // analysis, so some of these candidates may no longer be valid.\n-        // We keep track of when the variable dependency graph changed\n-        // so that we can back off appropriately.\n-        if (!c.defMetadata.depends.isEmpty()) {\n-          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-        }\n-      }\n+      int index = -1;\n     }\n   }\n \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 110,
    "bugId": 27,
    "name": "Patch_2_2",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_3/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2019-08-09 00:25:19.809857609 -0400\n+++ /tmp/GenProg_Defects4J_Closure_3/patches_opir/Patch_2/patched/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2019-08-09 00:52:33.103206686 -0400\n@@ -152,20 +152,6 @@\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n     for (Candidate c : candidates) {\n-      if (c.canInline()) {\n-        c.inlineVariable();\n-\n-        // If definition c has dependencies, then inlining it may have\n-        // introduced new dependencies for our other inlining candidates.\n-        //\n-        // MustBeReachingVariableDef uses this dependency graph in its\n-        // analysis, so some of these candidates may no longer be valid.\n-        // We keep track of when the variable dependency graph changed\n-        // so that we can back off appropriately.\n-        if (!c.defMetadata.depends.isEmpty()) {\n-          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-        }\n-      }\n     }\n   }\n \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 111,
    "bugId": 27,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 112,
    "bugId": 28,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -610,9 +610,13 @@ public JSType caseNumberType() {\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+        if (resultEqualsValue) {\n           // Objects are restricted to \"Function\", subtypes are left\n+          return ctorType.getGreatestSubtype(type);\n+        } else {\n           // Only filter out subtypes of \"function\"\n+          return type.isSubtype(ctorType) ? null : type;\n+        }\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 113,
    "bugId": 29,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,9 @@ private boolean isInlinableObject(List<Reference> refs) {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+          if (gramps.isDelProp()) {\n+            return false;\n+          }\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 114,
    "bugId": 30,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n@@ -363,9 +363,6 @@ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n-      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n-        registerMismatch(rightType, leftType, null);\n-      } else {\n       // Do not type-check interface methods, because we expect that\n       // they will have dummy implementations that do not match the type\n       // annotations.\n@@ -382,7 +379,6 @@ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n           \"assignment to property \" + propName + \" of \" +\n           getReadableJSTypeName(owner, true),\n           rightType, leftType);\n-      }\n       return false;\n     }\n     return true;\n@@ -402,11 +398,7 @@ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n-      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n-        registerMismatch(rightType, leftType, null);\n-      } else {\n       mismatch(t, n, msg, rightType, leftType);\n-      }\n       return false;\n     }\n     return true;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 115,
    "bugId": 31,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1569,9 +1569,13 @@ private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n       ObjectType interfaceType) {\n     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n     Set<String> currentPropertyNames;\n+    if (implicitProto == null) {\n       // This can be the case if interfaceType is proxy to a non-existent\n       // object (which is a bad type annotation, but shouldn't crash).\n+      currentPropertyNames = ImmutableSet.of();\n+    } else {\n       currentPropertyNames = implicitProto.getOwnPropertyNames();\n+    }\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 116,
    "bugId": 31,
    "name": "Patch_24",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex a0f95db..488b37a 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1571,7 +1571,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     Set<String> currentPropertyNames;\n       // This can be the case if interfaceType is proxy to a non-existent\n       // object (which is a bad type annotation, but shouldn't crash).\n-      currentPropertyNames = implicitProto.getOwnPropertyNames();\n+      if (implicitProto != null) {\n+\tcurrentPropertyNames = implicitProto.getOwnPropertyNames();\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {\n@@ -1585,6 +1586,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n       }\n       currentProperties.put(name, interfaceType);\n     }\n+}\n+\n     for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n       checkInterfaceConflictProperties(t, n, functionName, properties,\n           currentProperties, iType);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 117,
    "bugId": 31,
    "name": "Patch_4_2",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex a0f95db9..45821f32 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1571,6 +1571,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     Set<String> currentPropertyNames;\n       // This can be the case if interfaceType is proxy to a non-existent\n       // object (which is a bad type annotation, but shouldn't crash).\n+    if (implicitProto != null) {\n       currentPropertyNames = implicitProto.getOwnPropertyNames();\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n@@ -1585,6 +1586,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n       }\n       currentProperties.put(name, interfaceType);\n     }\n+    }\n     for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n       checkInterfaceConflictProperties(t, n, functionName, properties,\n           currentProperties, iType);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 118,
    "bugId": 31,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex a0f95db..488b37a 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1571,7 +1571,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     Set<String> currentPropertyNames;\n       // This can be the case if interfaceType is proxy to a non-existent\n       // object (which is a bad type annotation, but shouldn't crash).\n-      currentPropertyNames = implicitProto.getOwnPropertyNames();\n+      if (implicitProto != null) {\n+\tcurrentPropertyNames = implicitProto.getOwnPropertyNames();\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {\n@@ -1585,6 +1586,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n       }\n       currentProperties.put(name, interfaceType);\n     }\n+}\n+\n     for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n       checkInterfaceConflictProperties(t, n, functionName, properties,\n           currentProperties, iType);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 119,
    "bugId": 31,
    "name": "Patch_3_2",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex a0f95db..f4bb6ef 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1571,7 +1571,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     Set<String> currentPropertyNames;\n       // This can be the case if interfaceType is proxy to a non-existent\n       // object (which is a bad type annotation, but shouldn't crash).\n-      currentPropertyNames = implicitProto.getOwnPropertyNames();\n+      if (implicitProto != null) {\n+\tcurrentPropertyNames = implicitProto.getOwnPropertyNames();\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {\n@@ -1585,6 +1586,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n       }\n       currentProperties.put(name, interfaceType);\n     }\n+\t}\n+\n     for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n       checkInterfaceConflictProperties(t, n, functionName, properties,\n           currentProperties, iType);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 120,
    "bugId": 31,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 121,
    "bugId": 32,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,9 @@ private void removeUnreferencedFunctionArgs(Scope fnScope) {\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    if (!removeGlobals) {\n+      return;\n+    }\n \n     Node function = fnScope.getRootNode();\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 122,
    "bugId": 33,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n@@ -187,7 +187,7 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     // makes more sense. Now, resolution via registry is first in order to\n     // avoid triggering the warnings built into the resolution via properties.\n     boolean resolved = resolveViaRegistry(t, enclosing);\n-    if (detectImplicitPrototypeCycle()) {\n+    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }\n \n@@ -199,7 +199,7 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n     }\n \n     resolveViaProperties(t, enclosing);\n-    if (detectImplicitPrototypeCycle()) {\n+    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 123,
    "bugId": 33,
    "name": "Patch_38_21",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/rhino/jstype/NamedType.java b/src/com/google/javascript/rhino/jstype/NamedType.java\nindex 70142c4..012d8f5 100644\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n@@ -187,7 +187,7 @@ class NamedType extends ProxyObjectType {\n     // makes more sense. Now, resolution via registry is first in order to\n     // avoid triggering the warnings built into the resolution via properties.\n     boolean resolved = resolveViaRegistry(t, enclosing);\n-    if (detectImplicitPrototypeCycle()) {\n+    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 124,
    "bugId": 33,
    "name": "Patch_18_1",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/rhino/jstype/NamedType.java b/src/com/google/javascript/rhino/jstype/NamedType.java\nindex 70142c4..012d8f5 100644\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n@@ -187,7 +187,7 @@ class NamedType extends ProxyObjectType {\n     // makes more sense. Now, resolution via registry is first in order to\n     // avoid triggering the warnings built into the resolution via properties.\n     boolean resolved = resolveViaRegistry(t, enclosing);\n-    if (detectImplicitPrototypeCycle()) {\n+    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 125,
    "bugId": 33,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 126,
    "bugId": 34,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n@@ -201,10 +201,14 @@ private boolean canBeRedeclared(Node n, Scope s) {\n       Var var = s.getVar(lhs.getString());\n       return var != null\n           && var.getScope() == s\n+          && !isNamedParameter(var)\n           && !blacklistedVars.contains(var);\n     }\n   }\n \n+  private boolean isNamedParameter(Var v) {\n+    return v.getParentNode().isParamList();\n+  }\n \n   private void applyCollapses() {\n     for (Collapse collapse : collapses) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 127,
    "bugId": 35,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\n+++ b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\n@@ -116,6 +116,7 @@ public static String toModuleName(String requiredFilename,\n   private String normalizeSourceName(String filename) {\n     // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n     // wrestle it back.\n+    filename = filename.replace(\"\\\\\", \"/\");\n \n     if (filename.indexOf(filenamePrefix) == 0) {\n       filename = filename.substring(filenamePrefix.length());\n@@ -180,7 +181,7 @@ private void visitScript(NodeTraversal t, Node script) {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n-      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n+      String moduleName = guessCJSModuleName(script.getSourceFileName());\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 128,
    "bugId": 36,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1311,8 +1311,6 @@ private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 129,
    "bugId": 36,
    "name": "Patch_370_370",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex ae8a3200..12be29c4 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1311,12 +1311,21 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n+} else // start of generated patch\n+if(t.getScope().getVar(property.getString())!=null&&parent.isAssign()){\n+return ;\n+}else if(validator.expectNotNullOrUndefined(t,n,childType,\"No properties on this expression\",getNativeType(OBJECT_TYPE))){\n+checkPropertyAccess(childType,property.getString(),t,n);\n+}\n+// end of generated patch\n+/* start of original code\n     } else if (n.getJSType() != null && parent.isAssign()) {\n       return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n+ end of original code*/\n     ensureTyped(t, n);\n   }\n ",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 130,
    "bugId": 36,
    "name": "Patch_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex ae8a320..b65af82 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1311,7 +1311,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n+    } else if (n.getJSType() == null && parent.isAssign()) {\n       return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 131,
    "bugId": 36,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex ae8a320..b65af82 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1311,7 +1311,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n+    } else if (n.getJSType() == null && parent.isAssign()) {\n       return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 132,
    "bugId": 36,
    "name": "Patch_1_1",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex ae8a320..b65af82 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1311,7 +1311,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n+    } else if (n.getJSType() == null && parent.isAssign()) {\n       return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 133,
    "bugId": 36,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 134,
    "bugId": 37,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n+++ b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n@@ -157,6 +157,12 @@ ReachingUses flowThrough(Node n, ReachingUses input) {\n   }\n \n   private boolean hasExceptionHandler(Node cfgNode) {\n+    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n+    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n+      if (edge.getValue() == Branch.ON_EX) {\n+        return true;\n+      }\n+    }\n     return false;\n   }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 135,
    "bugId": 37,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 136,
    "bugId": 38,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1414,7 +1414,7 @@ static boolean mayBeString(Node n) {\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 137,
    "bugId": 38,
    "name": "Patch_63_4",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex eef2792..eeb12d4 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1414,7 +1414,7 @@ public final class NodeUtil {\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 138,
    "bugId": 38,
    "name": "Patch_34_9",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex eef2792..eeb12d4 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1414,7 +1414,7 @@ public final class NodeUtil {\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 139,
    "bugId": 38,
    "name": "Patch_161_73",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex eef2792..eeb12d4 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1414,7 +1414,7 @@ public final class NodeUtil {\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 140,
    "bugId": 38,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 141,
    "bugId": 39,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -764,7 +764,7 @@ private static Node computeFollowNode(\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 142,
    "bugId": 39,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..16fe8ad6 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -763,9 +763,16 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n+// start of generated patch\n+for(Node finallyNode : cfa.finallyMap.get(parent)){\n+cfa.createEdge(fromNode,Branch.ON_EX,finallyNode);\n+}\n+// end of generated patch\n+/* start of original code\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n+ end of original code*/\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 143,
    "bugId": 40,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1288,8 +1288,12 @@ private JSType getDeclaredType(String sourceName, JSDocInfo info,\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+              JSDocInfo rValueInfo = rValue.getJSDocInfo();\n+              if (rValueInfo != null && rValueInfo.hasType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n+                return rValueInfo.getType().evaluate(scope, typeRegistry);\n+              } else if (rValue.getJSType() != null\n+                  && !rValue.getJSType().isUnknownType()) {\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 144,
    "bugId": 41,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n@@ -123,8 +123,8 @@ private void traverse(Node node) {\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n-        traverse(c);\n         Node next = c.getNext();\n+        traverse(c);\n         c = next;\n       }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 145,
    "bugId": 41,
    "name": "Patch_28_9",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\nindex b51c088..b269e70 100644\n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n@@ -123,8 +123,10 @@ class PeepholeOptimizationsPass\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n-        traverse(c);\n+        \n         Node next = c.getNext();\n+\ttraverse(c);\n+\n         c = next;\n       }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 146,
    "bugId": 41,
    "name": "Patch_10_6",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\nindex b51c088..b269e70 100644\n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n@@ -123,8 +123,10 @@ class PeepholeOptimizationsPass\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n-        traverse(c);\n+        \n         Node next = c.getNext();\n+\ttraverse(c);\n+\n         c = next;\n       }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 147,
    "bugId": 42,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,7 +98,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult()) {\n+    if (n.isExprResult() || n.isBlock()) {\n       return;\n     }\n \n@@ -110,24 +110,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (parent.getType() == Token.COMMA) {\n-      if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n-        return;\n-      }\n-    }\n-    if (\n+    if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 148,
    "bugId": 42,
    "name": "Patch_183_183",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 0d1e95a0..122ae73b 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -115,12 +115,21 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n         return;\n       }\n       if (n == parent.getLastChild()) {\n+// start of generated patch\n+for(Node an : parent.getAncestors()){\n+int ancestorType=parent.getParent().getType();\n+if(ancestorType==Token.COMMA)continue;\n+if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;\n+}\n+// end of generated patch\n+/* start of original code\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n         }\n+ end of original code*/\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 149,
    "bugId": 42,
    "name": "Patch_13_3",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-08 22:18:13.615686350 -0400\n+++ /tmp/Arja_Defects4J_Closure_21/patches_i5hy/Patch_3/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-08 22:48:28.746290081 -0400\n@@ -117,7 +117,8 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n+          if (ancestorType == Token.COMMA)\n+\t\t\tbreak;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n         }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 150,
    "bugId": 42,
    "name": "Patch_64",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 0d1e95a..da75ef3 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -114,7 +114,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n+      if (parent == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 151,
    "bugId": 42,
    "name": "Patch_16_12",
    "tool": "jMutRepair",
    "diff": "--- /tmp/jMutRepair_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffectsjava\n+++ /tmp/jMutRepair_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffectsjava\n@@ -117,7 +117,7 @@\n \t\t\tif (n == (parent.getLastChild())) {\n \t\t\t\tfor (com.google.javascript.rhino.Node an : parent.getAncestors()) {\n \t\t\t\t\tint ancestorType = an.getType();\n-\t\t\t\t\tif (ancestorType == (com.google.javascript.rhino.Token.COMMA)) \t\t\t\t\t\tcontinue;\n+\t\t\t\t\tif (ancestorType >= (com.google.javascript.rhino.Token.COMMA)) \t\t\t\t\t\tcontinue;\n \t\t\t\t\tif ((ancestorType != (com.google.javascript.rhino.Token.EXPR_RESULT)) && (ancestorType != (com.google.javascript.rhino.Token.BLOCK))) \t\t\t\t\t\treturn;else\n \t\t\t\t\t\tbreak;\n \t\t\t\t}",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 152,
    "bugId": 42,
    "name": "Patch_556_343",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 0d1e95a..1b232df 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -114,7 +114,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n+      if ((parent == null)) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 153,
    "bugId": 42,
    "name": "Patch_400_219",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 0d1e95a..ca45135 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -114,7 +114,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n+      if ((n == parent.getLastChild()) && (n.isExprResult())) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 154,
    "bugId": 42,
    "name": "Patch_14_7",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-09 20:01:52.431846732 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_21/patches_7sd0/Patch_7/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-09 20:24:04.938659036 -0400\n@@ -117,7 +117,8 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n+          if (ancestorType == Token.COMMA)\n+\t\t\tbreak;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n         }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 155,
    "bugId": 42,
    "name": "Patch_7_3",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-09 20:22:47.772160451 -0400\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_vku5/Patch_3/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-09 20:44:16.460063036 -0400\n@@ -114,14 +114,6 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 156,
    "bugId": 42,
    "name": "Patch_8_8",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 157,
    "bugId": 43,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -99,6 +99,9 @@ public boolean apply(Node n) {\n           return true;\n         }\n \n+        if (n.isDelProp()) {\n+          return true;\n+        }\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 158,
    "bugId": 43,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 159,
    "bugId": 44,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -167,17 +167,23 @@ public void applyAlias() {\n \n   private class AliasedTypeNode implements AliasUsage {\n     private final Node typeReference;\n+    private final Node aliasDefinition;\n     private final String aliasName;\n \n-    AliasedTypeNode(Node typeReference,\n+    AliasedTypeNode(Node typeReference, Node aliasDefinition,\n         String aliasName) {\n       this.typeReference = typeReference;\n+      this.aliasDefinition = aliasDefinition;\n       this.aliasName = aliasName;\n     }\n \n     @Override\n     public void applyAlias() {\n-      typeReference.setString(aliasName);\n+      String typeName = typeReference.getString();\n+      String aliasExpanded =\n+          Preconditions.checkNotNull(aliasDefinition.getQualifiedName());\n+      Preconditions.checkState(typeName.startsWith(aliasName));\n+      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));\n     }\n   }\n \n@@ -465,7 +471,7 @@ private void fixTypeNode(Node typeNode) {\n         Var aliasVar = aliases.get(baseName);\n         if (aliasVar != null) {\n           Node aliasedNode = aliasVar.getInitialValue();\n-          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));\n+          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));\n         }\n       }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 160,
    "bugId": 45,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1285,7 +1285,7 @@ Node parseInputs() {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if (options.dependencyOptions.needsManagement()) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 161,
    "bugId": 45,
    "name": "Patch_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 8898f77..97f8b05 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1285,7 +1285,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if (options.dependencyOptions.needsManagement() || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 162,
    "bugId": 45,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 8898f77..97f8b05 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1285,7 +1285,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if (options.dependencyOptions.needsManagement() || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 163,
    "bugId": 45,
    "name": "Patch_17_16",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 8898f77..97f8b05 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1285,7 +1285,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if (options.dependencyOptions.needsManagement() || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 164,
    "bugId": 45,
    "name": "Patch_39_35",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 8898f77..d58251e 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1285,7 +1285,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if ((options.dependencyOptions.needsManagement() && options.closurePass) || !(options.enables(DiagnosticGroups.CHECK_TYPES))) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 165,
    "bugId": 45,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 166,
    "bugId": 46,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -217,7 +217,8 @@ private Node tryFoldSimpleFunctionCall(Node n) {\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+      if (value != null && value.getNext() == null &&\n+          NodeUtil.isImmutableValue(value)) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 167,
    "bugId": 47,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -169,7 +169,9 @@ protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n \n+      case Token.THIS:\n         // \"this\" references aren't currently modeled in the CFG.\n+        break;\n \n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 168,
    "bugId": 47,
    "name": "Patch_6_6",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c855..1631dd08 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -167,6 +167,15 @@ public abstract class ChainableReverseAbstractInterpreter\n         JSType origType = node.getJSType();\n         origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n+// start of generated patch\n+case Token.THIS :\n+\n+break;\n+default :\n+throw new IllegalArgumentException(\"Node cannot be refined. \\n\"+node.toStringTree());\n+\n+// end of generated patch\n+/* start of original code\n         break;\n \n         // \"this\" references aren't currently modeled in the CFG.\n@@ -174,6 +183,7 @@ public abstract class ChainableReverseAbstractInterpreter\n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n             node.toStringTree());\n+ end of original code*/\n     }\n   }\n ",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 169,
    "bugId": 47,
    "name": "Patch_124_16",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c85..94a2a46 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -172,8 +172,7 @@ public abstract class ChainableReverseAbstractInterpreter\n         // \"this\" references aren't currently modeled in the CFG.\n \n       default:\n-        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n-            node.toStringTree());\n+        \n     }\n   }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 170,
    "bugId": 48,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -1448,8 +1448,14 @@ private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+    for (int i = 0; current != null; i++) {\n+      if (i != intIndex) {\n+        if (mayHaveSideEffects(current)) {\n+          return n;\n+        }\n+      } else {\n         elem = current;\n+      }\n \n       current = current.getNext();\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 171,
    "bugId": 49,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -275,8 +275,8 @@ private void findAliases(NodeTraversal t) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n+        if (parent.isVar() &&\n+            n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n           String name = n.getString();\n           Var aliasVar = scope.getVar(name);\n           aliases.put(name, aliasVar);\n@@ -284,15 +284,16 @@ private void findAliases(NodeTraversal t) {\n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n+        } else if (v.isBleedingFunction()) {\n           // Bleeding functions already get a BAD_PARAMETERS error, so just\n           // do nothing.\n+        } else if (parent.getType() == Token.LP) {\n           // Parameters of the scope function also get a BAD_PARAMETERS\n           // error.\n         } else {\n           // TODO(robbyw): Support using locals for private variables.\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n-        }\n       }\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 172,
    "bugId": 50,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -98,44 +98,20 @@ public void visit(NodeTraversal t, Node n, Node parent) {\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n+    if (n.isExprResult() || n.isBlock()) {\n       return;\n-        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n+    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n       return;\n-      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 173,
    "bugId": 50,
    "name": "Patch_504_504",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex b9aa412c..80a021ee 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -109,6 +109,14 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n+// start of generated patch\n+for(Node an : parent.getAncestors()){\n+int ancestorType=parent.getParent().getType();\n+if(ancestorType==Token.COMMA)continue;\n+if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;\n+}\n+// end of generated patch\n+/* start of original code\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)\n@@ -118,6 +126,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n           else\n             break;\n         }\n+ end of original code*/\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 174,
    "bugId": 50,
    "name": "Patch_4_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-09 22:32:45.599511172 -0400\n+++ /tmp/Arja_Defects4J_Closure_22/patches_a94h/Patch_1/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-09 22:52:50.236175851 -0400\n@@ -95,38 +95,6 @@\n       return;\n     }\n \n-    // Do not try to remove a block or an expr result. We already handle\n-    // these cases when we visit the child, and the peephole passes will\n-    // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 175,
    "bugId": 50,
    "name": "Patch_182",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex b9aa412..376e39f 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -108,7 +108,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n+      if (gramps == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 176,
    "bugId": 50,
    "name": "Patch_55_43",
    "tool": "jMutRepair",
    "diff": "--- /tmp/jMutRepair_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffectsjava\n+++ /tmp/jMutRepair_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffectsjava\n@@ -113,7 +113,7 @@\n \t\t\t\t\tint ancestorType = an.getType();\n \t\t\t\t\tif (ancestorType == (com.google.javascript.rhino.Token.COMMA))\n \t\t\t\t\t\tcontinue;\n-\t\t\t\t\tif ((ancestorType != (com.google.javascript.rhino.Token.EXPR_RESULT)) && (ancestorType != (com.google.javascript.rhino.Token.BLOCK)))\n+\t\t\t\t\tif ((ancestorType != (com.google.javascript.rhino.Token.EXPR_RESULT)) && (ancestorType >= (com.google.javascript.rhino.Token.BLOCK)))\n \t\t\t\t\t\treturn;else\n \n \t\t\t\t\t\tbreak;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 177,
    "bugId": 50,
    "name": "Patch_15_12",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffectsjava\n+++ /tmp/jGenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffectsjava\n@@ -114,7 +114,7 @@\n \t\t\t\t\tif (ancestorType == (com.google.javascript.rhino.Token.COMMA)) \n \t\t\t\t\t{ \t\t\t\t\t\tcontinue;}\n \t\t\t\t\tif ((ancestorType != (com.google.javascript.rhino.Token.EXPR_RESULT)) && (ancestorType != (com.google.javascript.rhino.Token.BLOCK)))\n-\t\t\t\t\t\treturn;else\n+\t\t\t\t\t{}else\n \n \t\t\t\t\t\tbreak;\n \t\t\t\t}",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 178,
    "bugId": 50,
    "name": "Patch_1682_739",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex b9aa412..ab5b32a 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -108,7 +108,8 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n+      if ((n.isEmpty() ||\n+        n.isComma())) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 179,
    "bugId": 50,
    "name": "Patch_1279_454",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex b9aa412..d0fc9aa 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -108,7 +108,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n+      if ((n == parent.getLastChild()) && !(parent.getType() == Token.COMMA)) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 180,
    "bugId": 50,
    "name": "Patch_1_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-09 20:24:08.342608268 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_22/patches_lrw4/Patch_1/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-09 20:45:15.254601073 -0400\n@@ -105,20 +105,6 @@\n       return;\n         }\n     }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n            n == parent.getFirstChild().getNext().getNext())) {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 181,
    "bugId": 50,
    "name": "Patch_1_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-09 20:44:19.520023512 -0400\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_ouoc/Patch_1/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-09 21:05:39.065135177 -0400\n@@ -114,9 +114,11 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n+\t\t\tbreak;\n+\t\telse {\n+\t\t\tfinal String PARAM_NAME = \"jscomp_throw_param\";\n+\t\t\tbreak;\n+\t\t}\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 182,
    "bugId": 50,
    "name": "Patch_8_8",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 183,
    "bugId": 51,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\n+++ b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\n@@ -125,6 +125,7 @@ private String normalizeSourceName(String filename) {\n       AbstractPostOrderCallback {\n \n     private int scriptNodeCount = 0;\n+    private Set<String> modulesWithExports = Sets.newHashSet();\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n@@ -204,6 +205,9 @@ private void visitScript(NodeTraversal t, Node script) {\n      */\n     private void emitOptionalModuleExportsOverride(Node script,\n         String moduleName) {\n+      if (!modulesWithExports.contains(moduleName)) {\n+        return;\n+      }\n \n       Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n           IR.string(\"module$exports\"));\n@@ -225,6 +229,7 @@ private void visitModuleExports(Node prop) {\n       Node exports = prop.getChildAtIndex(1);\n       exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n       exports.setString(\"module$exports\");\n+      modulesWithExports.add(moduleName);\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 184,
    "bugId": 52,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1033,9 +1033,9 @@ private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n   }\n \n   private FlowScope traverseNew(Node n, FlowScope scope) {\n+    scope = traverseChildren(n, scope);\n \n     Node constructor = n.getFirstChild();\n-    scope = traverse(constructor, scope);\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {\n@@ -1052,13 +1052,11 @@ private FlowScope traverseNew(Node n, FlowScope scope) {\n         }\n         if (ct != null && ct.isConstructor()) {\n           type = ct.getInstanceType();\n+          backwardsInferenceFromCallSite(n, ct);\n         }\n       }\n     }\n     n.setJSType(type);\n-    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n-      scope = traverse(arg, scope);\n-    }\n     return scope;\n   }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 185,
    "bugId": 53,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/rhino/IR.java\n+++ b/src/com/google/javascript/rhino/IR.java\n@@ -108,6 +108,9 @@ public static Node block(Node ... stmts) {\n     return block;\n   }\n \n+  private static Node blockUnchecked(Node stmt) {\n+    return new Node(Token.BLOCK, stmt);\n+  }\n \n   public static Node script(Node ... stmts) {\n     // TODO(johnlenz): finish setting up the SCRIPT node\n@@ -221,8 +224,8 @@ public static Node labelName(String name) {\n   }\n \n   public static Node tryFinally(Node tryBody, Node finallyBody) {\n-    Preconditions.checkState(tryBody.isLabelName());\n-    Preconditions.checkState(finallyBody.isLabelName());\n+    Preconditions.checkState(tryBody.isBlock());\n+    Preconditions.checkState(finallyBody.isBlock());\n     Node catchBody = block().copyInformationFrom(tryBody);\n     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n   }\n@@ -230,7 +233,7 @@ public static Node tryFinally(Node tryBody, Node finallyBody) {\n   public static Node tryCatch(Node tryBody, Node catchNode) {\n     Preconditions.checkState(tryBody.isBlock());\n     Preconditions.checkState(catchNode.isCatch());\n-    Node catchBody = block(catchNode).copyInformationFrom(catchNode);\n+    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n     return new Node(Token.TRY, tryBody, catchBody);\n   }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 186,
    "bugId": 54,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -154,6 +154,7 @@ private boolean isVarInlineForbidden(Var var) {\n      */\n     private boolean isInlinableObject(List<Reference> refs) {\n       boolean ret = false;\n+      Set<String> validProperties = Sets.newHashSet();\n       for (Reference ref : refs) {\n         Node name = ref.getNode();\n         Node parent = ref.getParent();\n@@ -178,6 +179,14 @@ private boolean isInlinableObject(List<Reference> refs) {\n           // We short-circuit this problem by bailing out if we see a reference\n           // to a property that isn't defined on the object literal. This\n           // isn't a perfect algorithm, but it should catch most cases.\n+          String propName = parent.getLastChild().getString();\n+          if (!validProperties.contains(propName)) {\n+            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n+              validProperties.add(propName);\n+            } else {\n+              return false;\n+            }\n+          }\n           continue;\n         }\n \n@@ -213,6 +222,7 @@ private boolean isInlinableObject(List<Reference> refs) {\n             return false;\n           }\n \n+          validProperties.add(child.getString());\n \n           Node childVal = child.getFirstChild();\n           // Check if childVal is the parent of any of the passed in\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 187,
    "bugId": 55,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -154,7 +154,7 @@ public void exitScope(NodeTraversal t) {}\n \n   @Override\n   public void process(Node externs, Node root) {\n-    (new NodeTraversal(compiler, this)).traverse(root);\n+    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n@@ -68,6 +68,7 @@\n   private static class Definition {\n     final Node node;\n     final Set<Var> depends = Sets.newHashSet();\n+    private boolean unknownDependencies = false;\n \n     Definition(Node node) {\n       this.node = node;\n@@ -393,9 +394,13 @@ private void computeDependence(final Definition def, Node rValue) {\n         new AbstractCfgNodeTraversalCallback() {\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n+        if (n.isName()) {\n           Var dep = jsScope.getVar(n.getString());\n+          if (dep == null) {\n+            def.unknownDependencies = true;\n+          } else {\n             def.depends.add(dep);\n+          }\n         }\n       }\n     });\n@@ -427,6 +432,9 @@ boolean dependsOnOuterScopeVars(String name, Node useNode) {\n     GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n     FlowState<MustDef> state = n.getAnnotation();\n     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n+    if (def.unknownDependencies) {\n+      return true;\n+    }\n \n     for (Var s : def.depends) {\n       if (s.scope != jsScope) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 188,
    "bugId": 56,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1282,7 +1282,6 @@ Node parseInputs() {\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 189,
    "bugId": 56,
    "name": "Patch_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5..afba4f0 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1281,8 +1281,7 @@ public class Compiler extends AbstractCompiler {\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n-      if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+      if (options.dependencyOptions.needsManagement() || !options.skipAllPasses &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 190,
    "bugId": 56,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5..afba4f0 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1281,8 +1281,7 @@ public class Compiler extends AbstractCompiler {\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n-      if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+      if (options.dependencyOptions.needsManagement() || !options.skipAllPasses &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 191,
    "bugId": 56,
    "name": "Patch_41_31",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5..3ceaa76 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1282,7 +1282,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+          (jsRoot != null) &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 192,
    "bugId": 56,
    "name": "Patch_39_39",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5..179feea 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1281,9 +1281,9 @@ public class Compiler extends AbstractCompiler {\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n-      if (options.dependencyOptions.needsManagement() &&\n+      if ((options.dependencyOptions.needsManagement() &&\n           !options.skipAllPasses &&\n-          options.closurePass) {\n+          options.closurePass) || !(options.enables(DiagnosticGroups.CHECK_TYPES))) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 193,
    "bugId": 56,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 194,
    "bugId": 57,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1355,12 +1355,14 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n     // Track the start of the line to count whitespace that\n     // the tokenizer skipped. Because this case is rare, it's easier\n     // to do this here than in the tokenizer.\n+    int lineStartChar = -1;\n \n     do {\n       switch (token) {\n         case STAR:\n           if (ignoreStar) {\n             // Mark the position after the star as the new start of the line.\n+            lineStartChar = stream.getCharno() + 1;\n           } else {\n             // The star is part of the comment.\n             if (builder.length() > 0) {\n@@ -1379,6 +1381,7 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n           }\n \n           ignoreStar = true;\n+          lineStartChar = 0;\n           token = next();\n           continue;\n \n@@ -1386,7 +1389,19 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n           ignoreStar = false;\n           state = State.SEARCHING_ANNOTATION;\n \n+          boolean isEOC = token == JsDocToken.EOC;\n+          if (!isEOC) {\n+            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {\n+              int numSpaces = stream.getCharno() - lineStartChar;\n+              for (int i = 0; i < numSpaces; i++) {\n+                builder.append(' ');\n+              }\n+              lineStartChar = -1;\n+            } else if (builder.length() > 0) {\n               // All tokens must be separated by a space.\n+              builder.append(' ');\n+            }\n+          }\n \n           if (token == JsDocToken.EOC ||\n               token == JsDocToken.EOF ||\n@@ -1411,9 +1426,6 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n             return new ExtractionInfo(multilineText, token);\n           }\n \n-          if (builder.length() > 0) {\n-            builder.append(' ');\n-          }\n           builder.append(toString(token));\n \n           line = stream.getRemainingJSDocLine();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 195,
    "bugId": 58,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -554,6 +554,9 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n   @Override\n   public void matchConstraint(ObjectType constraintObj) {\n     // We only want to match contraints on anonymous types.\n+    if (hasReferenceName()) {\n+      return;\n+    }\n \n     // Handle the case where the constraint object is a record type.\n     //\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 196,
    "bugId": 58,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_33/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2019-08-10 04:16:17.727546252 -0400\n+++ /tmp/Arja_Defects4J_Closure_33/patches_h3z6/Patch_1/patched/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2019-08-10 04:35:39.170615308 -0400\n@@ -555,27 +555,6 @@\n   public void matchConstraint(ObjectType constraintObj) {\n     // We only want to match contraints on anonymous types.\n \n-    // Handle the case where the constraint object is a record type.\n-    //\n-    // param constraintObj {{prop: (number|undefined)}}\n-    // function f(constraintObj) {}\n-    // f({});\n-    //\n-    // We want to modify the object literal to match the constraint, by\n-    // taking any each property on the record and trying to match\n-    // properties on this object.\n-    if (constraintObj.isRecordType()) {\n-      for (String prop : constraintObj.getOwnPropertyNames()) {\n-        JSType propType = constraintObj.getPropertyType(prop);\n-        if (!isPropertyTypeDeclared(prop)) {\n-          JSType typeToInfer = propType;\n-          if (!hasProperty(prop)) {\n-            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n-                .getLeastSupertype(propType);\n-          }\n-          defineInferredProperty(prop, typeToInfer, null);\n-        }\n-      }\n-    }\n+    \n   }\n }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 197,
    "bugId": 58,
    "name": "Patch_12_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_33/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2019-08-10 08:45:30.497187791 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_33/patches_g6t3/Patch_1/patched/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2019-08-10 09:07:11.248300021 -0400\n@@ -555,27 +555,6 @@\n   public void matchConstraint(ObjectType constraintObj) {\n     // We only want to match contraints on anonymous types.\n \n-    // Handle the case where the constraint object is a record type.\n-    //\n-    // param constraintObj {{prop: (number|undefined)}}\n-    // function f(constraintObj) {}\n-    // f({});\n-    //\n-    // We want to modify the object literal to match the constraint, by\n-    // taking any each property on the record and trying to match\n-    // properties on this object.\n-    if (constraintObj.isRecordType()) {\n-      for (String prop : constraintObj.getOwnPropertyNames()) {\n-        JSType propType = constraintObj.getPropertyType(prop);\n-        if (!isPropertyTypeDeclared(prop)) {\n-          JSType typeToInfer = propType;\n-          if (!hasProperty(prop)) {\n-            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n-                .getLeastSupertype(propType);\n-          }\n-          defineInferredProperty(prop, typeToInfer, null);\n-        }\n-      }\n-    }\n+    \n   }\n }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 198,
    "bugId": 58,
    "name": "Patch_1_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_33/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2019-08-10 10:04:57.547268424 -0400\n+++ /tmp/GenProg_Defects4J_Closure_33/patches_1gbp/Patch_1/patched/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2019-08-10 10:25:49.577276601 -0400\n@@ -555,27 +555,6 @@\n   public void matchConstraint(ObjectType constraintObj) {\n     // We only want to match contraints on anonymous types.\n \n-    // Handle the case where the constraint object is a record type.\n-    //\n-    // param constraintObj {{prop: (number|undefined)}}\n-    // function f(constraintObj) {}\n-    // f({});\n-    //\n-    // We want to modify the object literal to match the constraint, by\n-    // taking any each property on the record and trying to match\n-    // properties on this object.\n-    if (constraintObj.isRecordType()) {\n-      for (String prop : constraintObj.getOwnPropertyNames()) {\n-        JSType propType = constraintObj.getPropertyType(prop);\n-        if (!isPropertyTypeDeclared(prop)) {\n-          JSType typeToInfer = propType;\n-          if (!hasProperty(prop)) {\n-            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n-                .getLeastSupertype(propType);\n-          }\n-          defineInferredProperty(prop, typeToInfer, null);\n-        }\n-      }\n-    }\n+    \n   }\n }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 199,
    "bugId": 58,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 200,
    "bugId": 59,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/InlineCostEstimator.java\n+++ b/src/com/google/javascript/jscomp/InlineCostEstimator.java\n@@ -99,5 +99,9 @@ void addIdentifier(String identifier) {\n      * Constants (true, false, null) are considered basically free,\n      * because it's likely that they will get folded when we're done.\n      */\n+    @Override\n+    void addConstant(String newcode) {\n+      add(\"0\");\n+    }\n   }\n }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 201,
    "bugId": 60,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -119,9 +119,7 @@ void add(Node n, Context context) {\n         cc.addOp(opstr, true);\n         addExpr(last, p, rhsContext);\n       } else {\n-        addExpr(first, p, context);\n-        cc.addOp(opstr, true);\n-        addExpr(last, p + 1, rhsContext);\n+        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n       }\n       return;\n     }\n@@ -751,7 +749,7 @@ private void unrollBinaryOperator(\n     Node current = firstNonOperator;\n     do {\n       current = current.getParent();\n-      cc.listSeparator();\n+      cc.addOp(opStr, true);\n       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n     } while (current != n);\n   }\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n@@ -331,7 +331,7 @@ void endCaseBody() {\n     @Override\n     void appendOp(String op, boolean binOp) {\n       if (binOp) {\n-        if (getLastChar() != ' ') {\n+        if (getLastChar() != ' ' && op.charAt(0) != ',') {\n           append(\" \");\n         }\n         append(op);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 202,
    "bugId": 61,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1118,21 +1118,8 @@ private void inferPropertyTypesToMatchConstraint(\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+    if (constraintObj != null) {\n+      type.matchConstraint(constraintObj);\n     }\n   }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 203,
    "bugId": 61,
    "name": "Patch_138_81",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 13e1092..a04cd51 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1119,7 +1119,7 @@ class TypeInference\n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n     if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n+      ObjectType objType = ObjectType.cast(type.collapseUnion());\n       if (objType != null) {\n         for (String prop : constraintObj.getOwnPropertyNames()) {\n           JSType propType = constraintObj.getPropertyType(prop);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 204,
    "bugId": 61,
    "name": "Patch_90_59",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 13e1092..a04cd51 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1119,7 +1119,7 @@ class TypeInference\n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n     if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n+      ObjectType objType = ObjectType.cast(type.collapseUnion());\n       if (objType != null) {\n         for (String prop : constraintObj.getOwnPropertyNames()) {\n           JSType propType = constraintObj.getPropertyType(prop);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 205,
    "bugId": 62,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n@@ -538,7 +538,7 @@ private void traverseFunction(Node n, Node parent) {\n \n     // Body\n     Preconditions.checkState(body.getNext() == null &&\n-            body.isBlock());\n+            body.isBlock(), body);\n     traverseBranch(body, n);\n \n     popScope();\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -664,9 +664,13 @@ Node processFunctionNode(FunctionNode functionNode) {\n       node.addChildToBack(lp);\n \n       Node bodyNode = transform(functionNode.getBody());\n+      if (!bodyNode.isBlock()) {\n         // When in ideMode Rhino tries to parse some constructs the compiler\n         // doesn't support, repair it here. see Rhino's\n         // Parser#parseFunctionBodyExpr.\n+        Preconditions.checkState(config.isIdeMode);\n+        bodyNode = IR.block();\n+      }\n       parseDirectives(bodyNode);\n       node.addChildToBack(bodyNode);\n      return node;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 206,
    "bugId": 63,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,9 @@ private boolean canInline(\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+          if (convention.getSingletonGetterClassName(callNode) != null) {\n+            return false;\n+          }\n         }\n       }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 207,
    "bugId": 64,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -377,10 +377,10 @@ String toStringHelper(boolean forAnnotations) {\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n+        sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n \n         ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n+        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n           sb.append(\", ...\");\n           break;\n         }\n@@ -391,7 +391,7 @@ String toStringHelper(boolean forAnnotations) {\n       prettyPrint = true;\n       return sb.toString();\n     } else {\n-      return \"{...}\";\n+      return forAnnotations ? \"?\" : \"{...}\";\n     }\n   }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 208,
    "bugId": 65,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -729,6 +729,7 @@ private void interpretAssigns() {\n             assignedToUnknownValue = true;\n           }\n \n+          boolean maybeEscaped = false;\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;\n@@ -736,9 +737,12 @@ private void interpretAssigns() {\n                 assign.assignNode.getLastChild(), true)) {\n               assignedToUnknownValue = true;\n             }\n+            if (assign.maybeAliased) {\n+              maybeEscaped = true;\n+            }\n           }\n \n-          if (assignedToUnknownValue && hasPropertyAssign) {\n+          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {\n             changes = markReferencedVar(var) || changes;\n             maybeUnreferenced.remove(current);\n             current--;\n@@ -901,7 +905,7 @@ void apply() {\n       this.nameNode = nameNode;\n       this.isPropertyAssign = isPropertyAssign;\n \n-      this.maybeAliased = !assignNode.getParent().isExprResult();\n+      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);\n       this.mayHaveSecondarySideEffects =\n           maybeAliased ||\n           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 209,
    "bugId": 65,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 210,
    "bugId": 66,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -242,7 +242,7 @@ void addNumber(double x) {\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if ((x < 0 || negativeZero) && prev == '-') {\n       add(\" \");\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 211,
    "bugId": 66,
    "name": "Patch_19_19",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 4381487c..e6ec35d1 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -242,9 +242,16 @@ abstract class CodeConsumer {\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n+// start of generated patch\n+if(prev=='-'){\n+add(\" \");\n+}\n+// end of generated patch\n+/* start of original code\n     if (x < 0 && prev == '-') {\n       add(\" \");\n     }\n+ end of original code*/\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 212,
    "bugId": 66,
    "name": "Patch_2",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 4381487..6d637e8 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -242,7 +242,7 @@ abstract class CodeConsumer {\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if (x <= 0 && prev == '-') {\n       add(\" \");\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 213,
    "bugId": 66,
    "name": "Patch_2_2",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 4381487c..6d637e80 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -242,7 +242,7 @@ abstract class CodeConsumer {\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if (x <= 0 && prev == '-') {\n       add(\" \");\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 214,
    "bugId": 66,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 4381487..6d637e8 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -242,7 +242,7 @@ abstract class CodeConsumer {\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if (x <= 0 && prev == '-') {\n       add(\" \");\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 215,
    "bugId": 66,
    "name": "Patch_3_3",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 4381487..cfdbdd8 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -242,7 +242,7 @@ abstract class CodeConsumer {\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if (x<=0 && prev == '-') {\n       add(\" \");\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 216,
    "bugId": 66,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 217,
    "bugId": 67,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -632,11 +632,9 @@ public void visit(NodeTraversal t, Node n, Node parent) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n+          JsName name = getName(ns.name, true);\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n-          }\n         }\n       }\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 218,
    "bugId": 67,
    "name": "Patch_3_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 088a993..f73c012 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -632,7 +632,7 @@ final class NameAnalyzer implements CompilerPass {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n+          JsName name = getName(ns.name, true);\n           if (name != null) {\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 219,
    "bugId": 67,
    "name": "Patch_15_4",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 088a993..f73c012 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -632,7 +632,7 @@ final class NameAnalyzer implements CompilerPass {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n+          JsName name = getName(ns.name, true);\n           if (name != null) {\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 220,
    "bugId": 68,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -565,8 +565,15 @@ Node processExpressionStatement(ExpressionStatement statementNode) {\n \n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n+      if (loopNode.isForEach()) {\n+        errorReporter.error(\n+            \"unsupported language extension: for each\",\n+            sourceName,\n+            loopNode.getLineno(), \"\", 0);\n \n         // Return the bare minimum to put the AST in a valid state.\n+        return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n+      }\n       return newNode(\n           Token.FOR,\n           transform(loopNode.getIterator()),\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 221,
    "bugId": 69,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n@@ -289,6 +289,9 @@ FunctionTypeBuilder inferFromOverriddenFunction(\n       }\n \n       // Clone any remaining params that aren't in the function literal.\n+      while (oldParams.hasNext()) {\n+        paramBuilder.newParameterFromNode(oldParams.next());\n+      }\n \n       parametersNode = paramBuilder.build();\n     }\n@@ -480,6 +483,12 @@ FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n     }\n \n     // Copy over any old parameters that aren't in the param list.\n+    if (!isVarArgs) {\n+      while (oldParameterType != null && !isVarArgs) {\n+        builder.newParameterFromNode(oldParameterType);\n+        oldParameterType = oldParameterType.getNext();\n+      }\n+    }\n \n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 222,
    "bugId": 70,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -191,11 +191,13 @@ void add(String newcode) {\n       // need space to separate. This is not pretty printing.\n       // For example: \"return foo;\"\n       append(\" \");\n+    } else if (c == '/' && getLastChar() == '/') {\n       // Do not allow a forward slash to appear after a DIV.\n       // For example,\n       // REGEXP DIV REGEXP\n       // is valid and should print like\n       // / // / /\n+      append(\" \");\n     }\n \n     append(newcode);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 223,
    "bugId": 71,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -390,50 +390,51 @@ private void identifyNameNode(\n   private JSType getNativeType(JSTypeNative nativeType) {\n     return typeRegistry.getNativeType(nativeType);\n   }\n \n   private abstract class AbstractScopeBuilder\n       implements NodeTraversal.Callback {\n \n     /**\n      * The scope that we're builidng.\n      */\n     final Scope scope;\n \n     private final List<DeferredSetType> deferredSetTypes =\n         Lists.newArrayList();\n \n     /**\n      * Functions that we found in the global scope and not in externs.\n      */\n     private final List<Node> nonExternFunctions = Lists.newArrayList();\n \n     /**\n      * Object literals with a @lends annotation aren't analyzed until we\n      * reach the root of the statement they're defined in.\n      *\n      * This ensures that if there are any @lends annotations on the object\n      * literals, the type on the @lends annotation resolves correctly.\n      *\n      * For more information, see\n      * http://code.google.com/p/closure-compiler/issues/detail?id=314\n      */\n+    private List<Node> lentObjectLiterals = null;\n \n     /**\n      * Type-less stubs.\n      *\n      * If at the end of traversal, we still don't have types for these\n      * stubs, then we should declare UNKNOWN types.\n      */\n     private final List<StubDeclaration> stubDeclarations =\n         Lists.newArrayList();\n \n     /**\n      * The current source file that we're in.\n      */\n     private String sourceName = null;\n \n     /**\n      * The InputId of the current node.\n      */\n     private InputId inputId;\n \n@@ -498,90 +499,106 @@ public final boolean shouldTraverse(NodeTraversal t, Node n,\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       inputId = t.getInputId();\n       attachLiteralTypes(t, n);\n \n       switch (n.getType()) {\n         case Token.CALL:\n           checkForClassDefiningCalls(t, n, parent);\n           checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\n           break;\n \n         case Token.FUNCTION:\n           if (t.getInput() == null || !t.getInput().isExtern()) {\n             nonExternFunctions.add(n);\n           }\n \n           // Hoisted functions are handled during pre-traversal.\n           if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\n             defineFunctionLiteral(n, parent);\n           }\n           break;\n \n         case Token.ASSIGN:\n           // Handle initialization of properties.\n           Node firstChild = n.getFirstChild();\n           if (firstChild.isGetProp() &&\n               firstChild.isQualifiedName()) {\n             maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n                 firstChild, n, firstChild.getNext());\n           }\n           break;\n \n         case Token.CATCH:\n           defineCatch(n, parent);\n           break;\n \n         case Token.VAR:\n           defineVar(n, parent);\n           break;\n \n         case Token.GETPROP:\n           // Handle stubbed properties.\n           if (parent.isExprResult() &&\n               n.isQualifiedName()) {\n             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n           }\n           break;\n       }\n \n       // Analyze any @lends object literals in this statement.\n+      if (n.getParent() != null && NodeUtil.isStatement(n) &&\n+          lentObjectLiterals != null) {\n+        for (Node objLit : lentObjectLiterals) {\n+          defineObjectLiteral(objLit);\n+        }\n+        lentObjectLiterals.clear();\n+      }\n     }\n \n     private void attachLiteralTypes(NodeTraversal t, Node n) {\n       switch (n.getType()) {\n         case Token.NULL:\n           n.setJSType(getNativeType(NULL_TYPE));\n           break;\n \n         case Token.VOID:\n           n.setJSType(getNativeType(VOID_TYPE));\n           break;\n \n         case Token.STRING:\n           // Defer keys to the Token.OBJECTLIT case\n           if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n             n.setJSType(getNativeType(STRING_TYPE));\n           }\n           break;\n \n         case Token.NUMBER:\n           n.setJSType(getNativeType(NUMBER_TYPE));\n           break;\n \n         case Token.TRUE:\n         case Token.FALSE:\n           n.setJSType(getNativeType(BOOLEAN_TYPE));\n           break;\n \n         case Token.REGEXP:\n           n.setJSType(getNativeType(REGEXP_TYPE));\n           break;\n \n         case Token.OBJECTLIT:\n+          JSDocInfo info = n.getJSDocInfo();\n+          if (info != null &&\n+              info.getLendsName() != null) {\n+            if (lentObjectLiterals == null) {\n+              lentObjectLiterals = Lists.newArrayList();\n+            }\n+            lentObjectLiterals.add(n);\n+          } else {\n             defineObjectLiteral(n);\n+          }\n           break;\n \n           // NOTE(nicksantos): If we ever support Array tuples,\n           // we will need to put ARRAYLIT here as well.\n       }\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 224,
    "bugId": 72,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -137,22 +137,6 @@ boolean defineProperty(String propertyName, JSType type,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 225,
    "bugId": 72,
    "name": "Patch_21_21",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nindex 7289803e..c4ff612d 100755\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -139,6 +139,19 @@ class RecordType extends PrototypeObjectType {\n \n   @Override\n   public JSType getLeastSupertype(JSType that) {\n+// start of generated patch\n+if(!that.isRecordType()){\n+return super.getLeastSupertype(that);\n+}\n+RecordTypeBuilder builder=new RecordTypeBuilder(registry);\n+for(String property : properties.keySet()){\n+if(that.toMaybeRecordType().hasProperty(property)&&that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(getPropertyType(property))){\n+builder.addProperty(property,getPropertyType(property),getPropertyNode(property));\n+}\n+}\n+return getLeastSupertype(this,that);\n+// end of generated patch\n+/* start of original code\n     if (!that.isRecordType()) {\n       return super.getLeastSupertype(that);\n     }\n@@ -152,6 +165,7 @@ class RecordType extends PrototypeObjectType {\n       }\n     }\n     return builder.build();\n+ end of original code*/\n   }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 226,
    "bugId": 72,
    "name": "Patch_9",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nold mode 100755\nnew mode 100644\nindex 7289803..9c61b02\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -137,22 +137,7 @@ class RecordType extends PrototypeObjectType {\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+  \n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 227,
    "bugId": 72,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nold mode 100755\nnew mode 100644\nindex 7289803..9c61b02\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -137,22 +137,7 @@ class RecordType extends PrototypeObjectType {\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+  \n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 228,
    "bugId": 72,
    "name": "Patch_37_6",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nold mode 100755\nnew mode 100644\nindex 7289803..5cc8b64\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -139,7 +139,7 @@ class RecordType extends PrototypeObjectType {\n \n   @Override\n   public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n+    if (!that.isNumberObjectType()) {\n       return super.getLeastSupertype(that);\n     }\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 229,
    "bugId": 72,
    "name": "Patch_1_1",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nold mode 100755\nnew mode 100644\nindex 7289803..9c61b02\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -137,22 +137,7 @@ class RecordType extends PrototypeObjectType {\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+  \n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 230,
    "bugId": 72,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 231,
    "bugId": 73,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n@@ -486,8 +486,8 @@ private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n       // Adjust the line/column here to be start at 1.\n       Builder x = OriginalMapping.newBuilder()\n         .setOriginalFile(sources[entry.getSourceFileId()])\n-        .setLineNumber(entry.getSourceLine())\n-        .setColumnPosition(entry.getSourceColumn());\n+        .setLineNumber(entry.getSourceLine() + 1)\n+        .setColumnPosition(entry.getSourceColumn() + 1);\n       if (entry.getNameId() != UNMAPPED) {\n         x.setIdentifier(names[entry.getNameId()]);\n       }\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n@@ -135,10 +135,15 @@ public void addMapping(\n     // zero based.\n     // We don't change this for the v1 or v2 source maps but for\n     // v3 we make them both 0 based.\n+    int lineBaseOffset = 1;\n+    if (generator instanceof SourceMapGeneratorV1\n+        || generator instanceof SourceMapGeneratorV2) {\n+      lineBaseOffset = 0;\n+    }\n \n     generator.addMapping(\n         sourceFile, originalName,\n-        new FilePosition(node.getLineno(), node.getCharno()),\n+        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),\n         outputStartPosition, outputEndPosition);\n   }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 232,
    "bugId": 74,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1518,11 +1518,14 @@ void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n+      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n         // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+        if (info != null) {\n+          inferred = false;\n+        } else if (!scope.isDeclared(qName, false) &&\n+                   n.isUnscopedQualifiedName()) {\n+          inferred = false;\n+        }\n       }\n \n       if (!inferred) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 233,
    "bugId": 75,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n@@ -88,14 +88,6 @@ public void enterScope(NodeTraversal t) {\n       renamer = nameStack.peek().forChildScope();\n     }\n \n-    if (declarationRoot.getType() == Token.FUNCTION) {\n-      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-        String name = c.getString();\n-        renamer.addDeclaredName(name);\n-      }\n-      Node functionBody = declarationRoot.getLastChild();\n-      findDeclaredNames(functionBody, null, renamer);\n-    }  else \n     if (declarationRoot.getType() != Token.FUNCTION) {\n       // Add the block declarations\n       findDeclaredNames(declarationRoot, null, renamer);\n@@ -127,11 +119,22 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n             renamer.addDeclaredName(name);\n           }\n \n+          nameStack.push(renamer);\n+        }\n+        break;\n \n+      case Token.LP: {\n+          Renamer renamer = nameStack.peek().forChildScope();\n \n           // Add the function parameters\n+          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+          }\n \n           // Add the function body declarations\n+          Node functionBody = n.getNext();\n+          findDeclaredNames(functionBody, null, renamer);\n \n           nameStack.push(renamer);\n         }\n@@ -170,13 +173,16 @@ public void visit(NodeTraversal t, Node n, Node parent) {\n \n       case Token.FUNCTION:\n         // Remove the function body scope\n+        nameStack.pop();\n         // Remove function recursive name (if any).\n         nameStack.pop();\n         break;\n \n+      case Token.LP:\n         // Note: The parameters and function body variables live in the\n         // same scope, we introduce the scope when in the \"shouldTraverse\"\n         // visit of LP, but remove it when when we exit the function above.\n+        break;\n \n       case Token.CATCH:\n         // Remove catch except name from the stack of names.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 234,
    "bugId": 76,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n@@ -373,7 +373,7 @@ private Node tryFoldArrayJoin(Node n) {\n \n     Node right = callTarget.getNext();\n     if (right != null) {\n-      if (!NodeUtil.isImmutableValue(right)) {\n+      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {\n         return n;\n       }\n     }\n@@ -386,7 +386,12 @@ private Node tryFoldArrayJoin(Node n) {\n       return n;\n     }\n \n+    if (right != null && right.getType() == Token.STRING\n+        && \",\".equals(right.getString())) {\n       // \",\" is the default, it doesn't need to be explicit\n+      n.removeChild(right);\n+      reportCodeChange();\n+    }\n \n     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 235,
    "bugId": 77,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -328,6 +328,9 @@ private void replaceAssignmentExpression(Var v, Reference ref,\n       }\n \n       Node replacement;\n+      if (nodes.isEmpty()) {\n+        replacement = new Node(Token.TRUE);\n+      } else {\n         // All assignments evaluate to true, so make sure that the\n         // expr statement evaluates to true in case it matters.\n         nodes.add(new Node(Token.TRUE));\n@@ -347,6 +350,7 @@ private void replaceAssignmentExpression(Var v, Reference ref,\n         }\n         cur.addChildToFront(nodes.get(i));\n         cur.addChildToFront(nodes.get(i + 1));\n+      }\n \n       Node replace = ref.getParent();\n       replacement.copyInformationFromForTree(replace);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 236,
    "bugId": 78,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -238,7 +238,7 @@ void addNumber(double x) {\n       add(\" \");\n     }\n \n-    if ((long) x == x) {\n+    if ((long) x == x && !isNegativeZero(x)) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 237,
    "bugId": 78,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 238,
    "bugId": 79,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -742,7 +742,7 @@ static boolean isSimpleNumber(String s) {\n         return false;\n       }\n     }\n-    return len > 0;\n+    return len > 0 && s.charAt(0) != '0';\n   }\n \n   static double getSimpleNumber(String s) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 239,
    "bugId": 80,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -252,7 +252,8 @@ public void initOptions(CompilerOptions options) {\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+    if (options.checkGlobalThisLevel.isOn() &&\n+        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 240,
    "bugId": 80,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_59/src/com/google/javascript/jscomp/Compiler.java\t2019-08-10 16:42:49.663444746 -0400\n+++ /tmp/Arja_Defects4J_Closure_59/patches_sibh/Patch_1/patched/com/google/javascript/jscomp/Compiler.java\t2019-08-10 17:02:18.547001441 -0400\n@@ -252,12 +252,6 @@\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n-      options.setWarningLevel(\n-          DiagnosticGroups.GLOBAL_THIS,\n-          options.checkGlobalThisLevel);\n-    }\n-\n     if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n       options.setWarningLevel(\n           DiagnosticGroups.ES5_STRICT,\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 241,
    "bugId": 80,
    "name": "Patch_53_8",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b3ca246..1248cda 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -252,11 +252,7 @@ public class Compiler extends AbstractCompiler {\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n-      options.setWarningLevel(\n-          DiagnosticGroups.GLOBAL_THIS,\n-          options.checkGlobalThisLevel);\n-    }\n+    \n \n     if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n       options.setWarningLevel(\n@@ -272,6 +268,12 @@ public class Compiler extends AbstractCompiler {\n     guards.add(options.getWarningsGuard());\n \n     ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n+\tif (options.checkGlobalThisLevel.isOn()) {\n+      options.setWarningLevel(\n+          DiagnosticGroups.GLOBAL_THIS,\n+          options.checkGlobalThisLevel);\n+    }\n+\n \n     // All passes must run the variable check. This synthesizes\n     // variables later so that the compiler doesn't crash. It also",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 242,
    "bugId": 80,
    "name": "Patch_25_19",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b3ca246..f39c57f 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -252,7 +252,7 @@ public class Compiler extends AbstractCompiler {\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+    if ((options.checkGlobalThisLevel.isOn()) && !(options.enables(DiagnosticGroups.CHECK_TYPES))) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 243,
    "bugId": 80,
    "name": "Patch_12_11",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b3ca246..1248cda 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -252,11 +252,7 @@ public class Compiler extends AbstractCompiler {\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n-      options.setWarningLevel(\n-          DiagnosticGroups.GLOBAL_THIS,\n-          options.checkGlobalThisLevel);\n-    }\n+    \n \n     if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n       options.setWarningLevel(\n@@ -272,6 +268,12 @@ public class Compiler extends AbstractCompiler {\n     guards.add(options.getWarningsGuard());\n \n     ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n+\tif (options.checkGlobalThisLevel.isOn()) {\n+      options.setWarningLevel(\n+          DiagnosticGroups.GLOBAL_THIS,\n+          options.checkGlobalThisLevel);\n+    }\n+\n \n     // All passes must run the variable check. This synthesizes\n     // variables later so that the compiler doesn't crash. It also",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 244,
    "bugId": 80,
    "name": "Patch_2_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_59/src/com/google/javascript/jscomp/Compiler.java\\t2019-08-11 18:15:10.477585979 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_59/patches_dmmq/Patch_1/patched/com/google/javascript/jscomp/Compiler.java\\t2019-08-11 18:35:02.446770581 -0400\n@@ -252,12 +252,6 @@\n           CheckLevel.OFF);\n     }\n\n-    if (options.checkGlobalThisLevel.isOn()) {\n-      options.setWarningLevel(\n-          DiagnosticGroups.GLOBAL_THIS,\n-          options.checkGlobalThisLevel);\n-    }\n-\n     if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n       options.setWarningLevel(\n           DiagnosticGroups.ES5_STRICT,\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 245,
    "bugId": 80,
    "name": "Patch_3_2",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_59/src/com/google/javascript/jscomp/Compiler.java\t2019-08-11 15:22:29.548827304 -0400\n+++ /tmp/GenProg_Defects4J_Closure_59/patches_9yxs/Patch_2/patched/com/google/javascript/jscomp/Compiler.java\t2019-08-11 15:42:14.854050012 -0400\n@@ -252,12 +252,6 @@\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n-      options.setWarningLevel(\n-          DiagnosticGroups.GLOBAL_THIS,\n-          options.checkGlobalThisLevel);\n-    }\n-\n     if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n       options.setWarningLevel(\n           DiagnosticGroups.ES5_STRICT,\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 246,
    "bugId": 80,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 247,
    "bugId": 81,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/FunctionRewriter.java\n+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java\n@@ -114,7 +114,8 @@ public Node parseHelperCode(Reducer reducer) {\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+    return NodeUtil.isFunctionExpression(n)\n+        && !NodeUtil.isGetOrSetKey(n.getParent());\n   }\n \n   /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 248,
    "bugId": 81,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-10 15:05:25.685771047 -0400\n+++ /tmp/Arja_Defects4J_Closure_55/patches_rylk/Patch_1/patched/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-10 15:26:39.495499663 -0400\n@@ -114,7 +114,7 @@\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+    return false;\n   }\n \n   /**\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 249,
    "bugId": 81,
    "name": "Patch_56_2",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-11 07:58:43.539488576 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_55/patches_paaq/Patch_2/patched/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-11 08:18:45.471196126 -0400\n@@ -114,7 +114,7 @@\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+    return false;\n   }\n \n   /**\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 250,
    "bugId": 81,
    "name": "Patch_34_7",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-11 12:28:15.904598757 -0400\n+++ /tmp/GenProg_Defects4J_Closure_55/patches_40l6/Patch_7/patched/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-11 12:50:23.133009981 -0400\n@@ -114,7 +114,7 @@\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+    return false;\n   }\n \n   /**\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 251,
    "bugId": 81,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 252,
    "bugId": 82,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1410,7 +1410,13 @@ void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n           // then they are responsible for making sure that the object literal's\n           // implicit prototype is set up appropriately. We just obey\n           // the @extends tag.\n-          if (!qVar.isTypeInferred()) {\n+          ObjectType qVarType = ObjectType.cast(qVar.getType());\n+          if (qVarType != null &&\n+              rhsValue != null &&\n+              rhsValue.getType() == Token.OBJECTLIT) {\n+            typeRegistry.resetImplicitPrototype(\n+                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n+          } else if (!qVar.isTypeInferred()) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to some arbitrary expression,\n             // there's not much we can do. We just ignore the expression,\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n@@ -338,7 +338,6 @@ public void setPrototypeBasedOn(ObjectType baseType) {\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() ||\n-        baseType.isUnknownType() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType() ||\n         !(baseType instanceof PrototypeObjectType)) {\n@@ -363,14 +362,18 @@ public boolean setPrototype(PrototypeObjectType prototype) {\n       return false;\n     }\n \n-    boolean replacedPrototype = prototype != null;\n+    PrototypeObjectType oldPrototype = this.prototype;\n+    boolean replacedPrototype = oldPrototype != null;\n \n     this.prototype = prototype;\n     this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n     this.prototype.setOwnerFunction(this);\n \n+    if (oldPrototype != null) {\n       // Disassociating the old prototype makes this easier to debug--\n       // we don't have to worry about two prototypes running around.\n+      oldPrototype.setOwnerFunction(null);\n+    }\n \n     if (isConstructor() || isInterface()) {\n       FunctionType superClass = getSuperClassConstructor();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 253,
    "bugId": 83,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/SourceFile.java\n+++ b/src/com/google/javascript/jscomp/SourceFile.java\n@@ -239,7 +239,11 @@ public String getLine(int lineNumber) {\n       // If next new line cannot be found, there are two cases\n       // 1. pos already reaches the end of file, then null should be returned\n       // 2. otherwise, return the contents between pos and the end of file.\n+      if (pos >= js.length()) {\n         return null;\n+      } else {\n+        return js.substring(pos, js.length());\n+      }\n     } else {\n       return js.substring(pos, js.indexOf('\\n', pos));\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 254,
    "bugId": 84,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n@@ -203,8 +203,12 @@ private void computeGenKill(Node n, BitSet gen, BitSet kill,\n             // for(var x in y) {...}\n             lhs = lhs.getLastChild();\n           }\n+          if (NodeUtil.isName(lhs)) {\n             addToSetIfLocal(lhs, kill);\n             addToSetIfLocal(lhs, gen);\n+          } else {\n+            computeGenKill(lhs, gen, kill, conditional);\n+          }\n           computeGenKill(rhs, gen, kill, conditional);\n         }\n         return;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 255,
    "bugId": 85,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n@@ -194,7 +194,7 @@ private static String extractClassNameIfGoog(Node node, Node parent,\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+          if (target != null && target.getType() == Token.STRING) {\n             className = target.getString();\n           }\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 256,
    "bugId": 85,
    "name": "Patch_45_45",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/ClosureCodingConvention.java b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\nindex c507c924..558d01b8 100644\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n@@ -194,9 +194,16 @@ public class ClosureCodingConvention extends DefaultCodingConvention {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n+// start of generated patch\n+if(target!=null&&target.getType()==Token.STRING){\n+className=target.getString();\n+}\n+// end of generated patch\n+/* start of original code\n           if (target != null) {\n             className = target.getString();\n           }\n+ end of original code*/\n         }\n       }\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 257,
    "bugId": 86,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ private String format(JSError error, boolean warning) {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 258,
    "bugId": 86,
    "name": "Patch_979_979",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884c..c1488582 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -94,6 +94,20 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n+// start of generated patch\n+if(excerpt.equals(LINE)&&0<=charno&&charno<=sourceExcerpt.length()){\n+for(int i=0;i<charno;i++){\n+char c=sourceExcerpt.charAt(i);\n+if(Character.isWhitespace(c)){\n+b.append(c);\n+}else {\n+b.append(' ');\n+}\n+}\n+b.append(\"^\\n\");\n+}\n+// end of generated patch\n+/* start of original code\n       if (excerpt.equals(LINE)\n           && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n@@ -106,6 +120,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n         }\n         b.append(\"^\\n\");\n       }\n+ end of original code*/\n     }\n     return b.toString();\n   }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 259,
    "bugId": 86,
    "name": "Patch_1_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..420dbc0 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 260,
    "bugId": 86,
    "name": "Patch_14_14",
    "tool": "jMutRepair",
    "diff": "--- /tmp/jMutRepair_Defects4J_Closure_62/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n+++ /tmp/jMutRepair_Defects4J_Closure_62/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n@@ -94,8 +94,8 @@\n \n \n \n-\t\t\tif (((excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n-\t\t\t(0 <= charno)) && (charno < (sourceExcerpt.length()))) {\n+\t\t\tif (((this.excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n+\t\t\t(0 <= charno)) && (charno <= (sourceExcerpt.length()))) {\n \t\t\t\tfor (int i = 0; i < charno; i++) {\n \t\t\t\t\tchar c = sourceExcerpt.charAt(i);\n \t\t\t\t\tif (java.lang.Character.isWhitespace(c)) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 261,
    "bugId": 86,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884c..7c3857fc 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno || charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 262,
    "bugId": 86,
    "name": "Patch_6_5",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..420dbc0 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 263,
    "bugId": 86,
    "name": "Patch_8_8",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..ff1e396 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno<=sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 264,
    "bugId": 87,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -105,6 +105,8 @@ static TernaryValue getImpureBooleanValue(Node n) {\n         // ignoring side-effects\n         return TernaryValue.TRUE;\n \n+      case Token.VOID:\n+        return TernaryValue.FALSE;\n \n       default:\n         return getPureBooleanValue(n);\n@@ -133,7 +135,10 @@ static TernaryValue getPureBooleanValue(Node n) {\n         return TernaryValue.FALSE;\n \n       case Token.VOID:\n+        if (!mayHaveSideEffects(n.getFirstChild())) {\n           return TernaryValue.FALSE;\n+        }\n+        break;\n \n       case Token.NAME:\n         String name = n.getString();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 265,
    "bugId": 88,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ private String format(JSError error, boolean warning) {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 266,
    "bugId": 88,
    "name": "Patch_979_979",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884c..c1488582 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -94,6 +94,20 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n+// start of generated patch\n+if(excerpt.equals(LINE)&&0<=charno&&charno<=sourceExcerpt.length()){\n+for(int i=0;i<charno;i++){\n+char c=sourceExcerpt.charAt(i);\n+if(Character.isWhitespace(c)){\n+b.append(c);\n+}else {\n+b.append(' ');\n+}\n+}\n+b.append(\"^\\n\");\n+}\n+// end of generated patch\n+/* start of original code\n       if (excerpt.equals(LINE)\n           && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n@@ -106,6 +120,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n         }\n         b.append(\"^\\n\");\n       }\n+ end of original code*/\n     }\n     return b.toString();\n   }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 267,
    "bugId": 88,
    "name": "Patch_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..420dbc0 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 268,
    "bugId": 88,
    "name": "Patch_14_14",
    "tool": "jMutRepair",
    "diff": "--- /tmp/jMutRepair_Defects4J_Closure_63/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n+++ /tmp/jMutRepair_Defects4J_Closure_63/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n@@ -94,8 +94,8 @@\n \n \n \n-\t\t\tif (((excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n-\t\t\t(0 <= charno)) && (charno < (sourceExcerpt.length()))) {\n+\t\t\tif (((this.excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n+\t\t\t(0 <= charno)) && (charno <= (sourceExcerpt.length()))) {\n \t\t\t\tfor (int i = 0; i < charno; i++) {\n \t\t\t\t\tchar c = sourceExcerpt.charAt(i);\n \t\t\t\t\tif (java.lang.Character.isWhitespace(c)) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 269,
    "bugId": 88,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/build/lib/rhino.jar b/build/lib/rhino.jar\nindex f9154683..513dc1e3 100644\nBinary files a/build/lib/rhino.jar and b/build/lib/rhino.jar differ\ndiff --git a/build/lib/rhino1_7R3pre/js.jar b/build/lib/rhino1_7R3pre/js.jar\nindex f551981d..c7ccc39b 100644\nBinary files a/build/lib/rhino1_7R3pre/js.jar and b/build/lib/rhino1_7R3pre/js.jar differ\ndiff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884c..7c3857fc 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno || charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 270,
    "bugId": 88,
    "name": "Patch_6_5",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..420dbc0 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 271,
    "bugId": 88,
    "name": "Patch_8_8",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..ff1e396 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno<=sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 272,
    "bugId": 89,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -955,6 +955,12 @@ static boolean functionCallHasSideEffects(\n       }\n \n       // Functions in the \"Math\" namespace have no side effects.\n+      if (nameNode.getFirstChild().getType() == Token.NAME) {\n+        String namespaceName = nameNode.getFirstChild().getString();\n+        if (namespaceName.equals(\"Math\")) {\n+          return false;\n+        }\n+      }\n \n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 273,
    "bugId": 90,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1429,7 +1429,7 @@ public Void call() throws Exception {\n \n         // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n         // for the first input file\n-        String code = toSource(root, sourceMap);\n+        String code = toSource(root, sourceMap, inputSeqNum == 0);\n         if (!code.isEmpty()) {\n           cb.append(code);\n \n@@ -1458,19 +1458,19 @@ public Void call() throws Exception {\n   @Override\n   String toSource(Node n) {\n     initCompilerOptionsIfTesting();\n-    return toSource(n, null);\n+    return toSource(n, null, true);\n   }\n \n   /**\n    * Generates JavaScript source code for an AST.\n    */\n-  private String toSource(Node n, SourceMap sourceMap) {\n+  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n-    builder.setTagAsStrict(\n+    builder.setTagAsStrict(firstOutput &&\n         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n     builder.setLineLengthThreshold(options.lineLengthThreshold);\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 274,
    "bugId": 91,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1012,7 +1012,7 @@ static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+        case '\\0': sb.append(\"\\\\000\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 275,
    "bugId": 92,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -513,7 +513,9 @@ public void visit(NodeTraversal t, Node n, Node parent) {\n         // Object literal keys are handled with OBJECTLIT\n         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n           ensureTyped(t, n, STRING_TYPE);\n+        } else {\n           // Object literal keys are not typeable\n+          typeable = false;\n         }\n         break;\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 276,
    "bugId": 92,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 277,
    "bugId": 93,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,7 @@ static String strEscape(String s, char quote,\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 278,
    "bugId": 93,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74fe..6392591a 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,6 +1042,14 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n+// start of generated patch\n+if(c>0x1f&&c<0x7f){\n+sb.append(c);\n+}else {\n+appendHexJavaScriptRepresentation(sb,c);\n+}\n+// end of generated patch\n+/* start of original code\n             if (c > 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n@@ -1050,6 +1058,7 @@ class CodeGenerator {\n               // so we play it safe and unicode escape them.\n               appendHexJavaScriptRepresentation(sb, c);\n             }\n+ end of original code*/\n           }\n       }\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 279,
    "bugId": 93,
    "name": "Patch_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74f..823d897 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 280,
    "bugId": 93,
    "name": "Patch_5_5",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74fe..823d897a 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 281,
    "bugId": 93,
    "name": "Patch_11_9",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74f..823d897 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 282,
    "bugId": 93,
    "name": "Patch_8_8",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74f..fc0d0f4 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (c > 0x1f && c<0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 283,
    "bugId": 94,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n@@ -315,7 +315,7 @@ private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+          && assign.getParent().getType() == Token.EXPR_RESULT) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 284,
    "bugId": 95,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -904,8 +904,8 @@ private Node tryFoldComparison(Node n, Node left, Node right) {\n           && right.getString().equals(\"undefined\"))\n           || (Token.VOID == right.getType()\n               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n-    int lhType = left.getType();\n-    int rhType = right.getType();\n+    int lhType = getNormalizedNodeType(left);\n+    int rhType = getNormalizedNodeType(right);\n     switch (lhType) {\n       case Token.VOID:\n         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n@@ -1071,6 +1071,19 @@ private Node tryFoldComparison(Node n, Node left, Node right) {\n   /**\n    * @return Translate NOT expressions into TRUE or FALSE when possible.\n    */\n+  private int getNormalizedNodeType(Node n) {\n+    int type = n.getType();\n+    if (type == Token.NOT) {\n+      TernaryValue value = NodeUtil.getPureBooleanValue(n);\n+      switch (value) {\n+        case TRUE:\n+          return Token.TRUE;\n+        case FALSE:\n+          return Token.FALSE;\n+      }\n+    }\n+    return type;\n+  }\n \n   /**\n    * The result of the comparison as a Boolean or null if the\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 285,
    "bugId": 96,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n@@ -413,7 +413,7 @@ private void checkPropertyVisibility(NodeTraversal t,\n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+      boolean isOverride = parent.getJSDocInfo() != null &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 286,
    "bugId": 97,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -865,9 +865,9 @@ boolean parse() {\n                         }\n                         break;\n                     }\n+                  }\n \n                   token = eatTokensUntilEOL();\n-                  }\n                   continue retry;\n               }\n             }\n@@ -1706,6 +1706,7 @@ private Node parseBasicTypeExpression(JsDocToken token) {\n       }\n     }\n \n+    restoreLookAhead(token);\n     return reportGenericTypeSyntaxWarning();\n   }\n \n@@ -1758,6 +1759,7 @@ private Node parseFunctionType(JsDocToken token) {\n     // NOTE(nicksantos): We're not implementing generics at the moment, so\n     // just throw out TypeParameters.\n     if (token != JsDocToken.LP) {\n+      restoreLookAhead(token);\n       return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 287,
    "bugId": 97,
    "name": "Patch_6659_6659",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex 26a56a7a..446f18c2 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1757,9 +1757,17 @@ public final class JsDocInfoParser {\n   private Node parseFunctionType(JsDocToken token) {\n     // NOTE(nicksantos): We're not implementing generics at the moment, so\n     // just throw out TypeParameters.\n+// start of generated patch\n+if(token!=JsDocToken.LP){\n+restoreLookAhead(token);\n+return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n+}\n+// end of generated patch\n+/* start of original code\n     if (token != JsDocToken.LP) {\n       return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n     }\n+ end of original code*/\n \n     Node functionType = newNode(Token.FUNCTION);\n     Node parameters = null;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 288,
    "bugId": 98,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1577,6 +1577,13 @@ private void visitCall(NodeTraversal t, Node n) {\n \n       // Functions with explcit 'this' types must be called in a GETPROP\n       // or GETELEM.\n+      if (functionType.isOrdinaryFunction() &&\n+          !functionType.getTypeOfThis().isUnknownType() &&\n+          !functionType.getTypeOfThis().isNativeObjectType() &&\n+          !(child.getType() == Token.GETELEM ||\n+            child.getType() == Token.GETPROP)) {\n+        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n+      }\n \n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 289,
    "bugId": 99,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1742,7 +1742,7 @@ private void declareArguments(Node functionNode) {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+                  jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 290,
    "bugId": 99,
    "name": "Patch_17_11",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 210bb66..aa7e245 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1742,7 +1742,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+                  jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 291,
    "bugId": 99,
    "name": "Patch_71_24",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 210bb66..aa7e245 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1742,7 +1742,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+                  jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 292,
    "bugId": 100,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n@@ -149,6 +149,8 @@ private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n                 \"inline_\",\n                 isCallInLoop)));\n     // Make label names unique to this instance.\n+    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)\n+        .process(null, fnNode);\n   }\n \n   static class LabelNameSupplier implements Supplier<String> {\n--- a/src/com/google/javascript/jscomp/RenameLabels.java\n+++ b/src/com/google/javascript/jscomp/RenameLabels.java\n@@ -212,7 +212,7 @@ private void visitLabel(Node node, Node parent) {\n       String name = nameNode.getString();\n       LabelInfo li = getLabelInfo(name);\n       // This is a label...\n-      if (li.referenced) {\n+      if (li.referenced || !removeUnused) {\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n           // ... and it is used, give it the short name.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 293,
    "bugId": 101,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n@@ -297,26 +297,40 @@ private boolean isVariableStillLiveWithinExpression(\n           // If the currently node is the first child of\n           // AND/OR, be conservative only consider the READs\n           // of the second operand.\n+          if (n.getNext() != null) {\n+            state = isVariableReadBeforeKill(\n+                n.getNext(), variable);\n+            if (state == VariableLiveness.KILL) {\n+              state = VariableLiveness.MAYBE_LIVE;\n+            }\n+          }\n+          break;\n \n         case Token.HOOK:\n           // If current node is the condition, check each following\n           // branch, otherwise it is a conditional branch and the\n           // other branch can be ignored.\n+          if (n.getNext() != null && n.getNext().getNext() != null) {\n+            state = checkHookBranchReadBeforeKill(\n+                n.getNext(), n.getNext().getNext(), variable);\n+          }\n+          break;\n \n         default:\n           for(Node sibling = n.getNext(); sibling != null;\n               sibling = sibling.getNext()) {\n-            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n             state = isVariableReadBeforeKill(sibling, variable);\n+            if (state != VariableLiveness.MAYBE_LIVE) {\n+              break;\n+            }\n+          }\n+      }\n \n       // If we see a READ or KILL there is no need to continue.\n       if (state == VariableLiveness.READ) {\n         return true;\n       } else if (state == VariableLiveness.KILL) {\n         return false;\n-            }\n-          }\n-      }\n       }\n       n = n.getParent();\n     }\n@@ -337,6 +351,9 @@ private boolean isVariableStillLiveWithinExpression(\n    */\n   private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\n+    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION\n+      return VariableLiveness.MAYBE_LIVE;\n+    }\n \n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n@@ -359,9 +376,25 @@ private VariableLiveness isVariableReadBeforeKill(\n       // Conditionals\n       case Token.OR:\n       case Token.AND:\n+        VariableLiveness v1 = isVariableReadBeforeKill(\n+          n.getFirstChild(), variable);\n+        VariableLiveness v2 = isVariableReadBeforeKill(\n+          n.getLastChild(), variable);\n         // With a AND/OR the first branch always runs, but the second is\n         // may not.\n+        if (v1 != VariableLiveness.MAYBE_LIVE) {\n+          return v1;\n+        } else if (v2 == VariableLiveness.READ) {\n+          return VariableLiveness.READ;\n+        } else {\n+          return VariableLiveness.MAYBE_LIVE;\n+        }\n       case Token.HOOK:\n+        VariableLiveness first = isVariableReadBeforeKill(\n+            n.getFirstChild(), variable);\n+        if (first != VariableLiveness.MAYBE_LIVE) {\n+          return first;\n+        }\n         return checkHookBranchReadBeforeKill(\n             n.getFirstChild().getNext(), n.getLastChild(), variable);\n \n@@ -369,13 +402,11 @@ private VariableLiveness isVariableReadBeforeKill(\n         // Expressions are evaluated left-right, depth first.\n         for (Node child = n.getFirstChild();\n             child != null; child = child.getNext()) {\n-          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n           VariableLiveness state = isVariableReadBeforeKill(child, variable);\n           if (state != VariableLiveness.MAYBE_LIVE) {\n             return state;\n           }\n         }\n-      }\n     }\n \n     return VariableLiveness.MAYBE_LIVE;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 294,
    "bugId": 102,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n@@ -119,7 +119,7 @@ private void reportCodeChange(String changeDescription) {\n   public void process(Node externs, Node root) {\n     new NodeTraversal(\n         compiler, new NormalizeStatements(compiler, assertOnChange))\n-        .traverse(root);\n+        .traverseRoots(externs, root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n@@ -218,6 +218,7 @@ private void createSynthesizedExternVar(String varName) {\n     getSynthesizedExternsRoot().addChildToBack(\n         new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n+    compiler.reportCodeChange();\n   }\n \n   /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 295,
    "bugId": 103,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -963,6 +963,7 @@ static String strEscape(String s, char quote,\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n+        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 296,
    "bugId": 104,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -310,7 +310,10 @@ static Double getNumberValue(Node n) {\n   }\n \n   static Double getStringNumberValue(String rawJsString) {\n+    if (rawJsString.contains(\"\\u000b\")) {\n       // vertical tab is not always whitespace\n+      return null;\n+    }\n \n     String s = trimJsWhiteSpace(rawJsString);\n     // return ScriptRuntime.toNumber(s);\n@@ -372,7 +375,7 @@ static String trimJsWhiteSpace(String s) {\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\n       case '\\u000B': // <VT>\n-        return TernaryValue.TRUE;\n+        return TernaryValue.UNKNOWN;  // IE says \"no\", EcmaScript says \"yes\"\n       case ' ': // <SP>\n       case '\\n': // <LF>\n       case '\\r': // <CR>\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 297,
    "bugId": 105,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -708,14 +708,12 @@ private Node performArithmeticOp(int opType, Node left, Node right) {\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 298,
    "bugId": 105,
    "name": "Patch_19_6",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-10 23:04:10.925417809 -0400\n+++ /tmp/Arja_Defects4J_Closure_78/patches_uol3/Patch_6/patched/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-10 23:24:26.888439424 -0400\n@@ -708,14 +708,12 @@\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 299,
    "bugId": 105,
    "name": "Patch_232_122",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-12 10:36:08.007359108 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_78/patches_kfko/Patch_122/patched/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-12 10:55:36.969312147 -0400\n@@ -708,14 +708,13 @@\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+          Node parameterName = Node.newString(Token.NAME, \"jscomp_throw_param\");\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 300,
    "bugId": 105,
    "name": "Patch_21_15",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-12 08:42:54.553141085 -0400\n+++ /tmp/GenProg_Defects4J_Closure_78/patches_1y5r/Patch_15/patched/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-12 09:03:04.323153375 -0400\n@@ -708,14 +708,13 @@\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+          int start = 0;\n           return null;\n         }\n         result = lval / rval;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 301,
    "bugId": 106,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -331,7 +331,10 @@ public BooleanOptionHandler(\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+        String param = null;\n+        try {\n+          param = params.getParameter(0);\n+        } catch (CmdLineException e) {}\n \n         if (param == null) {\n           setter.addValue(true);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 302,
    "bugId": 107,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1259,6 +1259,7 @@ static boolean isBooleanResultHelper(Node n) {\n       // Inversion\n       case Token.NOT:\n       // delete operator returns a boolean.\n+      case Token.DELPROP:\n         return true;\n       default:\n         return false;\n@@ -2907,6 +2908,7 @@ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n         return true;\n+      case Token.DELPROP:\n       case Token.IN:\n         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n         return true;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 303,
    "bugId": 108,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -514,6 +514,13 @@ Node processFunctionNode(FunctionNode functionNode) {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n+        int functionType = functionNode.getFunctionType();\n+        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n+          errorReporter.error(\n+            \"unnamed function statement\",\n+            sourceName,\n+            functionNode.getLineno(), \"\", 0);\n+        }\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 304,
    "bugId": 109,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n@@ -160,7 +160,9 @@ public boolean isNoObjectType() {\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n+        (registry.getNativeFunctionType(\n+             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n   }\n \n   public boolean isNumberObjectType() {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 305,
    "bugId": 110,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n@@ -150,20 +150,7 @@ private Node tryRemoveUnconditionalBranching(Node n) {\n       return n;\n     }\n \n-    if (n.getParent() == null) {\n-      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n-      if (outEdges.size() == 1) {\n-        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n-      }\n-    }\n     switch (n.getType()) {\n-      case Token.BLOCK:\n-        if (n.hasChildren()) {\n-          Node first = n.getFirstChild();\n-          return tryRemoveUnconditionalBranching(first);\n-        } else {\n-          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));\n-        }\n       case Token.RETURN:\n         if (n.hasChildren()) {\n           break;\n@@ -180,7 +167,7 @@ private Node tryRemoveUnconditionalBranching(Node n) {\n             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n \n           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n-          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\n+          Node fallThrough = computeFollowing(n);\n           Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n           if (nextCfgNode == fallThrough) {\n             removeDeadExprStatementSafely(n);\n@@ -193,6 +180,13 @@ private Node tryRemoveUnconditionalBranching(Node n) {\n \n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n+    while (next != null && next.getType() == Token.BLOCK) {\n+      if (next.hasChildren()) {\n+        next = next.getFirstChild();\n+      } else {\n+        next = computeFollowing(next);\n+      }\n+    }\n     return next;\n   }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 306,
    "bugId": 111,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -2462,7 +2462,7 @@ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return false;\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 307,
    "bugId": 111,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_86/src/com/google/javascript/jscomp/NodeUtil.java\t2019-08-11 02:24:31.909415027 -0400\n+++ /tmp/Arja_Defects4J_Closure_86/patches_lkci/Patch_1/patched/com/google/javascript/jscomp/NodeUtil.java\t2019-08-11 02:36:14.933208918 -0400\n@@ -2459,10 +2459,7 @@\n             || isToStringMethodCall(value)\n             || locals.apply(value);\n       case Token.NEW:\n-        // TODO(nicksantos): This needs to be changed so that it\n-        // returns true iff we're sure the value was never aliased from inside\n-        // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return false;\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 308,
    "bugId": 111,
    "name": "Patch_8_4",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_86/src/com/google/javascript/jscomp/NodeUtil.java\t2019-08-12 19:13:16.108236485 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_86/patches_rrlx/Patch_4/patched/com/google/javascript/jscomp/NodeUtil.java\t2019-08-12 19:25:20.472318617 -0400\n@@ -2459,10 +2459,7 @@\n             || isToStringMethodCall(value)\n             || locals.apply(value);\n       case Token.NEW:\n-        // TODO(nicksantos): This needs to be changed so that it\n-        // returns true iff we're sure the value was never aliased from inside\n-        // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return false;\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 309,
    "bugId": 111,
    "name": "Patch_38_25",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_86/src/com/google/javascript/jscomp/NodeUtil.java\t2019-08-12 17:28:55.433238713 -0400\n+++ /tmp/GenProg_Defects4J_Closure_86/patches_s16k/Patch_25/patched/com/google/javascript/jscomp/NodeUtil.java\t2019-08-12 17:41:37.766163818 -0400\n@@ -2459,10 +2459,7 @@\n             || isToStringMethodCall(value)\n             || locals.apply(value);\n       case Token.NEW:\n-        // TODO(nicksantos): This needs to be changed so that it\n-        // returns true iff we're sure the value was never aliased from inside\n-        // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return false;\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 310,
    "bugId": 111,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 311,
    "bugId": 112,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -338,6 +338,13 @@ Node processArrayLiteral(ArrayLiteral literalNode) {\n     @Override\n     Node processAssignment(Assignment assignmentNode) {\n       Node assign = processInfixExpression(assignmentNode);\n+      Node target = assign.getFirstChild();\n+      if (!validAssignmentTarget(target)) {\n+        errorReporter.error(\n+          \"invalid assignment target\",\n+          sourceName,\n+          target.getLineno(), \"\", 0);\n+      }\n       return assign;\n     }\n \n@@ -794,6 +801,17 @@ Node processUnaryExpression(UnaryExpression exprNode) {\n         operand.setDouble(-operand.getDouble());\n         return operand;\n       } else {\n+        if (type == Token.INC || type == Token.DEC) {\n+          if (!validAssignmentTarget(operand)) {\n+            String msg = (type == Token.INC)\n+                ? \"invalid increment target\"\n+                : \"invalid decrement target\";\n+            errorReporter.error(\n+              msg,\n+              sourceName,\n+              operand.getLineno(), \"\", 0);\n+          }\n+        }\n \n         Node node = newNode(type, operand);\n         if (exprNode.isPostfix()) {\n@@ -803,6 +821,15 @@ Node processUnaryExpression(UnaryExpression exprNode) {\n       }\n     }\n \n+    private boolean validAssignmentTarget(Node target) {\n+      switch (target.getType()) {\n+        case Token.NAME:\n+        case Token.GETPROP:\n+        case Token.GETELEM:\n+          return true;\n+      }\n+      return false;\n+    }\n \n     @Override\n     Node processVariableDeclaration(VariableDeclaration declarationNode) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 312,
    "bugId": 113,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -481,6 +481,9 @@ private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n     Node greatGramps = gramps.getParent();\n     Node greatGreatGramps = greatGramps.getParent();\n \n+    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {\n+      checkForHosedThisReferences(rvalue, refName.docInfo, refName);\n+    }\n \n     // Create the new alias node.\n     Node nameNode = NodeUtil.newName(\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n@@ -917,7 +917,7 @@ boolean canCollapseUnannotatedChildNames() {\n       }\n \n       // If this is aliased, then its properties can't be collapsed either.\n-      if (type != Type.FUNCTION && aliasingGets > 0) {\n+      if (aliasingGets > 0) {\n         return false;\n       }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 313,
    "bugId": 114,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n@@ -324,9 +324,15 @@ private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n+        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n         // The expression to which the assignment is made is evaluated before\n         // the RHS is evaluated (normal left to right evaluation) but the KILL\n         // occurs after the RHS is evaluated.\n+        Node rhs = n.getNext();\n+        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n+        if (state == VariableLiveness.READ) {\n+          return state;\n+        }\n         return VariableLiveness.KILL;\n       } else {\n         return VariableLiveness.READ;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 314,
    "bugId": 114,
    "name": "Patch_2_2",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\t2019-08-11 02:48:25.697964329 -0400\n+++ /tmp/Arja_Defects4J_Closure_88/patches_5kgc/Patch_2/patched/com/google/javascript/jscomp/DeadAssignmentsElimination.java\t2019-08-11 03:00:01.786668843 -0400\n@@ -324,10 +324,6 @@\n       Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n-        // The expression to which the assignment is made is evaluated before\n-        // the RHS is evaluated (normal left to right evaluation) but the KILL\n-        // occurs after the RHS is evaluated.\n-        return VariableLiveness.KILL;\n       } else {\n         return VariableLiveness.READ;\n       }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 315,
    "bugId": 114,
    "name": "Patch_2_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\t2019-08-12 21:29:27.370333317 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_88/patches_w6j9/Patch_1/patched/com/google/javascript/jscomp/DeadAssignmentsElimination.java\t2019-08-12 21:41:44.429519316 -0400\n@@ -324,10 +324,6 @@\n       Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n-        // The expression to which the assignment is made is evaluated before\n-        // the RHS is evaluated (normal left to right evaluation) but the KILL\n-        // occurs after the RHS is evaluated.\n-        return VariableLiveness.KILL;\n       } else {\n         return VariableLiveness.READ;\n       }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 316,
    "bugId": 114,
    "name": "Patch_3_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_88/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\t2019-08-12 18:12:41.559543243 -0400\n+++ /tmp/GenProg_Defects4J_Closure_88/patches_men0/Patch_1/patched/com/google/javascript/jscomp/DeadAssignmentsElimination.java\t2019-08-12 18:24:35.995404949 -0400\n@@ -324,10 +324,7 @@\n       Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n-        // The expression to which the assignment is made is evaluated before\n-        // the RHS is evaluated (normal left to right evaluation) but the KILL\n-        // occurs after the RHS is evaluated.\n-        return VariableLiveness.KILL;\n+        int type = n.getType();\n       } else {\n         return VariableLiveness.READ;\n       }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 317,
    "bugId": 115,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -520,17 +520,29 @@ private boolean isFoldableExpressBlock(Node n) {\n     if (n.getType() == Token.BLOCK) {\n       if (n.hasOneChild()) {\n         Node maybeExpr = n.getFirstChild();\n+        if (maybeExpr.getType() == Token.EXPR_RESULT) {\n           // IE has a bug where event handlers behave differently when\n           // their return value is used vs. when their return value is in\n           // an EXPR_RESULT. It's pretty freaking weird. See:\n           // http://code.google.com/p/closure-compiler/issues/detail?id=291\n           // We try to detect this case, and not fold EXPR_RESULTs\n           // into other expressions.\n+          if (maybeExpr.getFirstChild().getType() == Token.CALL) {\n+            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n+            if (calledFn.getType() == Token.GETELEM) {\n+              return false;\n+            } else if (calledFn.getType() == Token.GETPROP &&\n+                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n+              return false;\n+            }\n+          }\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+          return true;\n+        }\n+        return false;\n       }\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 318,
    "bugId": 116,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -786,7 +786,7 @@ void replace() {\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot = namespace.lastIndexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 319,
    "bugId": 117,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -896,9 +896,16 @@ void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n       // scope where the root object appears. This helps out people\n       // who declare \"global\" names in an anonymous namespace.\n       Scope scopeToDeclareIn = scope;\n+      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n+          isQnameRootedInGlobalScope(n)) {\n+        Scope globalScope = scope.getGlobalScope();\n \n         // don't try to declare in the global scope if there's\n         // already a symbol there with this name.\n+        if (!globalScope.isDeclared(variableName, false)) {\n+          scopeToDeclareIn = scope.getGlobalScope();\n+        }\n+      }\n \n       // declared in closest scope?\n       if (scopeToDeclareIn.isDeclared(variableName, false)) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 320,
    "bugId": 118,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n@@ -181,7 +181,7 @@ public boolean apply(JSType type) {\n       // create interfaces JSType, ObjectType, FunctionType etc and have\n       // separate implementation instead of the class hierarchy, so that\n       // union types can also be object types, etc.\n-      if (!type.isSubtype(\n+      if (!type.restrictByNotNullOrUndefined().isSubtype(\n               typeRegistry.getNativeType(OBJECT_TYPE))) {\n         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n         return false;\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n@@ -877,6 +877,9 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n     // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n     // the name for them.\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis != null) {\n+      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n+    }\n     if (maybeTypeOfThis instanceof ObjectType) {\n       typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 321,
    "bugId": 119,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -326,14 +326,33 @@ static boolean isValidDefineValue(Node val, Set<String> defines) {\n         return true;\n \n       // Binary operators are only valid if both children are valid.\n+      case Token.ADD:\n       case Token.BITAND:\n       case Token.BITNOT:\n       case Token.BITOR:\n       case Token.BITXOR:\n+      case Token.DIV:\n+      case Token.EQ:\n+      case Token.GE:\n+      case Token.GT:\n+      case Token.LE:\n+      case Token.LSH:\n+      case Token.LT:\n+      case Token.MOD:\n+      case Token.MUL:\n+      case Token.NE:\n+      case Token.RSH:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+      case Token.SUB:\n+      case Token.URSH:\n+        return isValidDefineValue(val.getFirstChild(), defines)\n+            && isValidDefineValue(val.getLastChild(), defines);\n \n       // Uniary operators are valid if the child is valid.\n       case Token.NOT:\n       case Token.NEG:\n+      case Token.POS:\n         return isValidDefineValue(val.getFirstChild(), defines);\n \n       // Names are valid if and only if they are defines themselves.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 322,
    "bugId": 120,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,15 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+      Node gramps = parent.getParent();\n+      if (NodeUtil.isObjectLitKey(parent, gramps)) {\n+        JSDocInfo maybeLends = gramps.getJSDocInfo();\n+        if (maybeLends != null &&\n+            maybeLends.getLendsName() != null &&\n+            maybeLends.getLendsName().endsWith(\".prototype\")) {\n+          return false;\n+        }\n+      }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 323,
    "bugId": 121,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -786,7 +786,7 @@ void replace() {\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot = namespace.lastIndexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 324,
    "bugId": 122,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -695,7 +695,8 @@ private Node tryFoldShift(Node n, Node left, Node right) {\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+          long lvalLong = lvalInt & 0xffffffffL;\n+          result = lvalLong >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 325,
    "bugId": 123,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1406,10 +1406,13 @@ private void visitParameterList(NodeTraversal t, Node call,\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+           (parameters.hasNext() ||\n+            parameter != null && parameter.isVarArgs())) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n+      if (parameters.hasNext()) {\n         parameter = parameters.next();\n+      }\n       argument = arguments.next();\n       ordinal++;\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 326,
    "bugId": 124,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -430,10 +430,8 @@ protected CompilerOptions createOptions() {\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n \n+    options.closurePass = flags.process_closure_primitives;\n     initOptionsFromFlags(options);\n     return options;\n   }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 327,
    "bugId": 125,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -96,6 +96,13 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       // var a = function() { }; // or\n       // function a() {} // or\n       // a.x = function() {};\n+      int pType = parent.getType();\n+      if (!(pType == Token.BLOCK ||\n+            pType == Token.SCRIPT ||\n+            pType == Token.NAME ||\n+            pType == Token.ASSIGN)) {\n+        return false;\n+      }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {\n@@ -143,7 +150,7 @@ private boolean shouldReportThis(Node n, Node parent) {\n     }\n \n     // Also report a THIS with a property access.\n-    return false;\n+    return parent != null && NodeUtil.isGet(parent);\n   }\n \n   /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 328,
    "bugId": 126,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -354,15 +354,23 @@ Reference getInitializingReferenceForConstants() {\n     boolean isAssignedOnceInLifetime() {\n       Reference ref = getOneAndOnlyAssignment();\n       if (ref == null) {\n         return false;\n       }\n \n       // Make sure this assignment is not in a loop.\n+      for (BasicBlock block = ref.getBasicBlock();\n+           block != null; block = block.getParent()) {\n+        if (block.isFunction) {\n+          break;\n+        } else if (block.isLoop) {\n+          return false;\n+        }\n+      }\n \n       return true;\n     }\n \n     /**\n      * @return The one and only assignment. Returns if there are 0 or 2+\n      *    assignments.\n      */\n@@ -523,41 +531,52 @@ Scope getScope() {\n     public String getSourceName() {\n       return sourceName;\n     }\n   }\n \n   /**\n    * Represents a section of code that is uninterrupted by control structures\n    * (conditional or iterative logic).\n    */\n   static final class BasicBlock {\n \n     private final BasicBlock parent;\n \n     /**\n      * Determines whether the block may not be part of the normal control flow,\n      * but instead \"hoisted\" to the top of the scope.\n      */\n     private final boolean isHoisted;\n \n     /**\n      * Whether this block denotes a function scope.\n      */\n+    private final boolean isFunction;\n \n     /**\n      * Whether this block denotes a loop.\n      */\n+    private final boolean isLoop;\n \n     /**\n      * Creates a new block.\n      * @param parent The containing block.\n      * @param root The root node of the block.\n      */\n     BasicBlock(BasicBlock parent, Node root) {\n       this.parent = parent;\n \n       // only named functions may be hoisted.\n       this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);\n \n+      this.isFunction = root.getType() == Token.FUNCTION;\n \n+      if (root.getParent() != null) {\n+        int pType = root.getParent().getType();\n+        this.isLoop = pType == Token.DO ||\n+            pType == Token.WHILE ||\n+            pType == Token.FOR;\n+      } else {\n+        this.isLoop = false;\n+      }\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 329,
    "bugId": 127,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -89,6 +89,7 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n       if (jsDoc != null &&\n           (jsDoc.isConstructor() ||\n+           jsDoc.isInterface() ||\n            jsDoc.hasThisType() ||\n            jsDoc.isOverride())) {\n         return false;\n@@ -122,13 +123,17 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       } else {\n         // Only traverse the right side if it's not an assignment to a prototype\n         // property or subproperty.\n+        if (NodeUtil.isGet(lhs)) {\n           if (lhs.getType() == Token.GETPROP &&\n               lhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n-          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n+          Node llhs = lhs.getFirstChild();\n+          if (llhs.getType() == Token.GETPROP &&\n+              llhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n+        }\n       }\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 330,
    "bugId": 128,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n@@ -288,7 +288,7 @@ JSType meet(JSType that) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+    if (!result.isNoType()) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 331,
    "bugId": 129,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n@@ -1474,22 +1474,24 @@ void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n+    StringBuilder sb = null;\n     int foldedSize = 0;\n     Node elem = arrayNode.getFirstChild();\n     // Merges adjacent String nodes.\n     while (elem != null) {\n       if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n+        if (sb == null) {\n+          sb = new StringBuilder();\n+        } else {\n           sb.append(joinString);\n         }\n         sb.append(NodeUtil.getStringValue(elem));\n       } else {\n-        if (sb.length() > 0) {\n+        if (sb != null) {\n           // + 2 for the quotes.\n           foldedSize += sb.length() + 2;\n           arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n+          sb = null;\n         }\n         foldedSize += InlineCostEstimator.getCost(elem);\n         arrayFoldedChildren.add(elem);\n@@ -1497,7 +1499,7 @@ void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n       elem = elem.getNext();\n     }\n \n-    if (sb.length() > 0) {\n+    if (sb != null) {\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 332,
    "bugId": 130,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n@@ -904,6 +904,10 @@ boolean canCollapseUnannotatedChildNames() {\n       // Don't try to collapse if the one global set is a twin reference.\n       // We could theoretically handle this case in CollapseProperties, but\n       // it's probably not worth the effort.\n+      Preconditions.checkNotNull(declaration);\n+      if (declaration.getTwin() != null) {\n+        return false;\n+      }\n \n       if (isClassOrEnum) {\n         return true;\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n@@ -186,9 +186,7 @@ public void markName(String name, int lineno, int charno) {\n    * @return {@code true} if the description was recorded.\n    */\n   public boolean recordBlockDescription(String description) {\n-    if (parseDocumentation) {\n     populated = true;\n-    }\n     return currentInfo.documentBlock(description);\n   }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 333,
    "bugId": 131,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n@@ -86,12 +86,12 @@ private void reportCodeChange(String changeDescription) {\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n+    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 334,
    "bugId": 131,
    "name": "Patch_17_17",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java\nindex 4aa4555..d1757e2 100644\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n@@ -86,12 +86,14 @@ class Normalize implements CompilerPass, Callback {\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+    \n+    removeDuplicateDeclarations(root);\n+\tif (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 335,
    "bugId": 132,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -891,6 +891,7 @@ private static boolean mayThrowException(Node n) {\n       case Token.ASSIGN:\n       case Token.INC:\n       case Token.DEC:\n+      case Token.INSTANCEOF:\n         return true;\n       case Token.FUNCTION:\n         return false;\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n@@ -760,9 +760,16 @@ public JSTypeSystem(AbstractCompiler compiler) {\n       }\n       // If the property does not exist on the referenced type but the original\n       // type is an object type, see if any subtype has the property.\n+      if (foundType == null) {\n+        ObjectType maybeType = ObjectType.cast(\n+            registry.getGreatestSubtypeWithProperty(type, field));\n         // getGreatestSubtypeWithProperty does not guarantee that the property\n         // is defined on the returned type, it just indicates that it might be,\n         // so we have to double check.\n+        if (maybeType != null && maybeType.hasOwnProperty(field)) {\n+          foundType = maybeType;\n+        }\n+      }\n       return foundType;\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 336,
    "bugId": 133,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -859,6 +859,7 @@ protected CompilerOptions createOptions() {\n       // so we might as well inline it. But shut off the i18n warnings,\n       // because the user didn't really ask for i18n.\n       options.messageBundle = new EmptyMessageBundle();\n+      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);\n     }\n \n     return options;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 337,
    "bugId": 133,
    "name": "Patch_3_3",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex 93b35475..58ed7dfa 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -849,6 +849,12 @@ public class CommandLineRunner extends\n       } catch (IOException e) {\n         throw new RuntimeException(\"Reading XTB file\", e);\n       }\n+} else // start of generated patch\n+if(options.messageBundle!=null){\n+options.messageBundle=new EmptyMessageBundle();\n+}\n+// end of generated patch\n+/* start of original code\n     } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n       // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n       // translations file, they might reasonably try to write their own\n@@ -860,6 +866,7 @@ public class CommandLineRunner extends\n       // because the user didn't really ask for i18n.\n       options.messageBundle = new EmptyMessageBundle();\n     }\n+ end of original code*/\n \n     return options;\n   }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 338,
    "bugId": 133,
    "name": "Patch_4_4",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_107/src/com/google/javascript/jscomp/CommandLineRunner.java\t2019-08-11 01:38:29.457044271 -0400\n+++ /tmp/Arja_Defects4J_Closure_107/patches_kyto/Patch_4/patched/com/google/javascript/jscomp/CommandLineRunner.java\t2019-08-11 02:02:05.697382650 -0400\n@@ -850,15 +850,6 @@\n         throw new RuntimeException(\"Reading XTB file\", e);\n       }\n     } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n-      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n-      // translations file, they might reasonably try to write their own\n-      // implementation of goog.getMsg that makes the substitution at\n-      // run-time.\n-      //\n-      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n-      // so we might as well inline it. But shut off the i18n warnings,\n-      // because the user didn't really ask for i18n.\n-      options.messageBundle = new EmptyMessageBundle();\n     }\n \n     return options;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 339,
    "bugId": 133,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex 93b3547..54f5f08 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -858,7 +858,7 @@ public class CommandLineRunner extends\n       // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n       // so we might as well inline it. But shut off the i18n warnings,\n       // because the user didn't really ask for i18n.\n-      options.messageBundle = new EmptyMessageBundle();\n+      \n     }\n \n     return options;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 340,
    "bugId": 133,
    "name": "Patch_6_3",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_107/src/com/google/javascript/jscomp/CommandLineRunner.java\t2019-08-13 17:10:51.413908459 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_107/patches_8mez/Patch_3/patched/com/google/javascript/jscomp/CommandLineRunner.java\t2019-08-13 17:33:10.480258852 -0400\n@@ -850,15 +850,7 @@\n         throw new RuntimeException(\"Reading XTB file\", e);\n       }\n     } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n-      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n-      // translations file, they might reasonably try to write their own\n-      // implementation of goog.getMsg that makes the substitution at\n-      // run-time.\n-      //\n-      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n-      // so we might as well inline it. But shut off the i18n warnings,\n-      // because the user didn't really ask for i18n.\n-      options.messageBundle = new EmptyMessageBundle();\n+      int start = 0;\n     }\n \n     return options;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 341,
    "bugId": 133,
    "name": "Patch_1_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_107/src/com/google/javascript/jscomp/CommandLineRunner.java\t2019-08-13 15:06:31.704248185 -0400\n+++ /tmp/GenProg_Defects4J_Closure_107/patches_opji/Patch_1/patched/com/google/javascript/jscomp/CommandLineRunner.java\t2019-08-13 15:36:53.034326265 -0400\n@@ -850,15 +850,6 @@\n         throw new RuntimeException(\"Reading XTB file\", e);\n       }\n     } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n-      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n-      // translations file, they might reasonably try to write their own\n-      // implementation of goog.getMsg that makes the substitution at\n-      // run-time.\n-      //\n-      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n-      // so we might as well inline it. But shut off the i18n warnings,\n-      // because the user didn't really ask for i18n.\n-      options.messageBundle = new EmptyMessageBundle();\n     }\n \n     return options;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 342,
    "bugId": 134,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -256,6 +256,7 @@ public void applyAlias() {\n     private final Map<String, Var> aliases = Maps.newHashMap();\n \n     // Also temporary and cleared for each scope.\n+    private final Set<Node> injectedDecls = Sets.newHashSet();\n \n     // Suppose you create an alias.\n     // var x = goog.x;\n@@ -313,6 +314,7 @@ public void exitScope(NodeTraversal t) {\n \n       if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n+        injectedDecls.clear();\n         aliases.clear();\n         forbiddenLocals.clear();\n         transformation = null;\n@@ -429,6 +431,7 @@ private void findAliases(NodeTraversal t) {\n             } else {\n               grandparent.addChildBefore(newDecl, varNode);\n             }\n+            injectedDecls.add(newDecl.getFirstChild());\n           }\n \n           // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n@@ -578,7 +581,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {\n         // When we inject declarations, we duplicate jsdoc. Make sure\n         // we only process that jsdoc once.\n         JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n+        if (info != null && !injectedDecls.contains(n)) {\n           for (Node node : info.getTypeNodes()) {\n             fixTypeNode(node);\n           }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 343,
    "bugId": 135,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1905,7 +1905,11 @@ private Node parseTypeExpression(JsDocToken token) {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+    if (token == JsDocToken.QMARK) {\n+      return newNode(Token.QMARK);\n+    } else {\n+      return parseBasicTypeExpression(token);\n+    }\n   }\n \n   /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 344,
    "bugId": 135,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex e30c3509..3e66860a 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1905,7 +1905,12 @@ public final class JsDocInfoParser {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n+// start of generated patch\n+return parseTypeExpression(token);\n+// end of generated patch\n+/* start of original code\n           return parseTypeName(token);\n+ end of original code*/\n   }\n \n   /**",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 345,
    "bugId": 135,
    "name": "Patch_50_3",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex e30c350..cb61d8c 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1905,7 +1905,7 @@ public final class JsDocInfoParser {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+          return parseAndRecordTypeNode(token);\n   }\n \n   /**",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 346,
    "bugId": 135,
    "name": "Patch_4_3",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex e30c350..cb61d8c 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1905,7 +1905,7 @@ public final class JsDocInfoParser {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+          return parseAndRecordTypeNode(token);\n   }\n \n   /**",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 347,
    "bugId": 135,
    "name": "Patch_2_1",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex e30c350..cb61d8c 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1905,7 +1905,7 @@ public final class JsDocInfoParser {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+          return parseAndRecordTypeNode(token);\n   }\n \n   /**",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 348,
    "bugId": 136,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n@@ -722,8 +722,20 @@ private String formatFoundRequired(String description, JSType found,\n    *     to an Object type, if possible.\n    */\n   String getReadableJSTypeName(Node n, boolean dereference) {\n+    JSType type = getJSType(n);\n+    if (dereference) {\n+      ObjectType dereferenced = type.dereference();\n+      if (dereferenced != null) {\n+        type = dereferenced;\n+      }\n+    }\n \n     // The best type name is the actual type name.\n+    if (type.isFunctionPrototypeType() ||\n+        (type.toObjectType() != null &&\n+         type.toObjectType().getConstructor() != null)) {\n+      return type.toString();\n+    }\n \n     // If we're analyzing a GETPROP, the property may be inherited by the\n     // prototype chain. So climb the prototype chain and find out where\n@@ -753,18 +765,6 @@ String getReadableJSTypeName(Node n, boolean dereference) {\n       }\n     }\n \n-    JSType type = getJSType(n);\n-    if (dereference) {\n-      ObjectType dereferenced = type.dereference();\n-      if (dereferenced != null) {\n-        type = dereferenced;\n-      }\n-    }\n-    if (type.isFunctionPrototypeType() ||\n-        (type.toObjectType() != null &&\n-         type.toObjectType().getConstructor() != null)) {\n-      return type.toString();\n-    }\n     String qualifiedName = n.getQualifiedName();\n     if (qualifiedName != null) {\n       return qualifiedName;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 349,
    "bugId": 136,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_117/src/com/google/javascript/jscomp/TypeValidator.java\t2019-08-11 05:36:17.152281494 -0400\n+++ /tmp/Arja_Defects4J_Closure_117/patches_eprm/Patch_1/patched/com/google/javascript/jscomp/TypeValidator.java\t2019-08-11 05:58:26.511489937 -0400\n@@ -725,34 +725,6 @@\n \n     // The best type name is the actual type name.\n \n-    // If we're analyzing a GETPROP, the property may be inherited by the\n-    // prototype chain. So climb the prototype chain and find out where\n-    // the property was originally defined.\n-    if (n.isGetProp()) {\n-      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n-      if (objectType != null) {\n-        String propName = n.getLastChild().getString();\n-        if (objectType.getConstructor() != null &&\n-            objectType.getConstructor().isInterface()) {\n-          objectType = FunctionType.getTopDefiningInterface(\n-              objectType, propName);\n-        } else {\n-          // classes\n-          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n-            objectType = objectType.getImplicitPrototype();\n-          }\n-        }\n-\n-        // Don't show complex function names or anonymous types.\n-        // Instead, try to get a human-readable type name.\n-        if (objectType != null &&\n-            (objectType.getConstructor() != null ||\n-             objectType.isFunctionPrototypeType())) {\n-          return objectType.toString() + \".\" + propName;\n-        }\n-      }\n-    }\n-\n     JSType type = getJSType(n);\n     if (dereference) {\n       ObjectType dereferenced = type.dereference();\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 350,
    "bugId": 136,
    "name": "Patch_137_91",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeValidator.java b/src/com/google/javascript/jscomp/TypeValidator.java\nindex bcd024a..0f0c2ad 100644\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n@@ -728,7 +728,21 @@ class TypeValidator {\n     // If we're analyzing a GETPROP, the property may be inherited by the\n     // prototype chain. So climb the prototype chain and find out where\n     // the property was originally defined.\n-    if (n.isGetProp()) {\n+    \n+\n+    JSType type = getJSType(n);\n+    if (dereference) {\n+      ObjectType dereferenced = type.dereference();\n+      if (dereferenced != null) {\n+        type = dereferenced;\n+      }\n+    }\n+    if (type.isFunctionPrototypeType() ||\n+        (type.toObjectType() != null &&\n+         type.toObjectType().getConstructor() != null)) {\n+      return type.toString();\n+    }\n+\tif (n.isGetProp()) {\n       ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n       if (objectType != null) {\n         String propName = n.getLastChild().getString();\n@@ -753,18 +767,6 @@ class TypeValidator {\n       }\n     }\n \n-    JSType type = getJSType(n);\n-    if (dereference) {\n-      ObjectType dereferenced = type.dereference();\n-      if (dereferenced != null) {\n-        type = dereferenced;\n-      }\n-    }\n-    if (type.isFunctionPrototypeType() ||\n-        (type.toObjectType() != null &&\n-         type.toObjectType().getConstructor() != null)) {\n-      return type.toString();\n-    }\n     String qualifiedName = n.getQualifiedName();\n     if (qualifiedName != null) {\n       return qualifiedName;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 351,
    "bugId": 136,
    "name": "Patch_53_19",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_117/src/com/google/javascript/jscomp/TypeValidator.java\t2019-08-14 02:07:54.434849435 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_117/patches_dgl3/Patch_19/patched/com/google/javascript/jscomp/TypeValidator.java\t2019-08-14 02:29:55.860661853 -0400\n@@ -725,34 +725,6 @@\n \n     // The best type name is the actual type name.\n \n-    // If we're analyzing a GETPROP, the property may be inherited by the\n-    // prototype chain. So climb the prototype chain and find out where\n-    // the property was originally defined.\n-    if (n.isGetProp()) {\n-      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n-      if (objectType != null) {\n-        String propName = n.getLastChild().getString();\n-        if (objectType.getConstructor() != null &&\n-            objectType.getConstructor().isInterface()) {\n-          objectType = FunctionType.getTopDefiningInterface(\n-              objectType, propName);\n-        } else {\n-          // classes\n-          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n-            objectType = objectType.getImplicitPrototype();\n-          }\n-        }\n-\n-        // Don't show complex function names or anonymous types.\n-        // Instead, try to get a human-readable type name.\n-        if (objectType != null &&\n-            (objectType.getConstructor() != null ||\n-             objectType.isFunctionPrototypeType())) {\n-          return objectType.toString() + \".\" + propName;\n-        }\n-      }\n-    }\n-\n     JSType type = getJSType(n);\n     if (dereference) {\n       ObjectType dereferenced = type.dereference();\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 352,
    "bugId": 136,
    "name": "Patch_94_35",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_117/src/com/google/javascript/jscomp/TypeValidator.java\t2019-08-13 23:58:05.775697913 -0400\n+++ /tmp/GenProg_Defects4J_Closure_117/patches_5zlj/Patch_35/patched/com/google/javascript/jscomp/TypeValidator.java\t2019-08-14 00:19:29.463834626 -0400\n@@ -725,34 +725,6 @@\n \n     // The best type name is the actual type name.\n \n-    // If we're analyzing a GETPROP, the property may be inherited by the\n-    // prototype chain. So climb the prototype chain and find out where\n-    // the property was originally defined.\n-    if (n.isGetProp()) {\n-      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n-      if (objectType != null) {\n-        String propName = n.getLastChild().getString();\n-        if (objectType.getConstructor() != null &&\n-            objectType.getConstructor().isInterface()) {\n-          objectType = FunctionType.getTopDefiningInterface(\n-              objectType, propName);\n-        } else {\n-          // classes\n-          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n-            objectType = objectType.getImplicitPrototype();\n-          }\n-        }\n-\n-        // Don't show complex function names or anonymous types.\n-        // Instead, try to get a human-readable type name.\n-        if (objectType != null &&\n-            (objectType.getConstructor() != null ||\n-             objectType.isFunctionPrototypeType())) {\n-          return objectType.toString() + \".\" + propName;\n-        }\n-      }\n-    }\n-\n     JSType type = getJSType(n);\n     if (dereference) {\n       ObjectType dereferenced = type.dereference();\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 353,
    "bugId": 136,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 354,
    "bugId": 137,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1189,9 +1189,15 @@ private boolean inferTemplatedTypesForCall(\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n-\n+    Map<TemplateType, JSType> inferred = Maps.filterKeys(\n+        inferTemplateTypesFromParameters(fnType, n),\n+        new Predicate<TemplateType>() {\n+\n+          @Override\n+          public boolean apply(TemplateType key) {\n+            return keys.contains(key);\n+          }}\n+        );\n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 355,
    "bugId": 138,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -575,7 +575,7 @@ private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 356,
    "bugId": 139,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -326,7 +326,7 @@ private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+      if (provided != null || requiresLevel.isOn()) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 357,
    "bugId": 139,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 358,
    "bugId": 140,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -694,14 +694,6 @@ private CanInlineResult canInlineReferenceDirectly(\n \n     Node block = fnNode.getLastChild();\n \n-    boolean hasSideEffects = false;\n-    if (block.hasChildren()) {\n-      Preconditions.checkState(block.hasOneChild());\n-      Node stmt = block.getFirstChild();\n-      if (stmt.isReturn()) {\n-        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n-      }\n-    }\n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n \n@@ -727,9 +719,6 @@ private CanInlineResult canInlineReferenceDirectly(\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 359,
    "bugId": 140,
    "name": "Patch_154_154",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 73d6a4b3..92fc3a1b 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -698,9 +698,16 @@ class FunctionInjector {\n     if (block.hasChildren()) {\n       Preconditions.checkState(block.hasOneChild());\n       Node stmt = block.getFirstChild();\n+// start of generated patch\n+if(stmt.getFirstChild().isReturn()){\n+hasSideEffects=NodeUtil.mayHaveSideEffects(stmt.getFirstChild(),compiler);\n+}\n+// end of generated patch\n+/* start of original code\n       if (stmt.isReturn()) {\n         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n       }\n+ end of original code*/\n     }\n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 360,
    "bugId": 140,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-11 04:46:32.023061844 -0400\n+++ /tmp/Arja_Defects4J_Closure_115/patches_z8wr/Patch_1/patched/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-11 05:11:02.710789945 -0400\n@@ -727,9 +727,6 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 361,
    "bugId": 140,
    "name": "Patch_21_7",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 73d6a4b..7df8a60 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -695,13 +695,7 @@ class FunctionInjector {\n     Node block = fnNode.getLastChild();\n \n     boolean hasSideEffects = false;\n-    if (block.hasChildren()) {\n-      Preconditions.checkState(block.hasOneChild());\n-      Node stmt = block.getFirstChild();\n-      if (stmt.isReturn()) {\n-        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n-      }\n-    }\n+    \n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 362,
    "bugId": 140,
    "name": "Patch_8_8",
    "tool": "jKali",
    "diff": "--- /tmp/jKali_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjectorjava\n+++ /tmp/jKali_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjectorjava\n@@ -728,7 +728,7 @@\n \t\t\tif (fnParam != null) {\n \t\t\t\tif (cArg != null) {\n \t\t\t\t\tif (hasSideEffects && (com.google.javascript.jscomp.NodeUtil.canBeSideEffected(cArg))) {\n-\t\t\t\t\t\treturn com.google.javascript.jscomp.FunctionInjector.CanInlineResult.NO;\n+\n \t\t\t\t\t}",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 363,
    "bugId": 140,
    "name": "Patch_40_14",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 73d6a4b3..e6216d62 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -695,7 +695,7 @@ class FunctionInjector {\n     Node block = fnNode.getLastChild();\n \n     boolean hasSideEffects = false;\n-    if (block.hasChildren()) {\n+    if (block.isFromExterns()) {\n       Preconditions.checkState(block.hasOneChild());\n       Node stmt = block.getFirstChild();\n       if (stmt.isReturn()) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 364,
    "bugId": 140,
    "name": "Patch_118_12",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 73d6a4b..d92daae 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -695,7 +695,7 @@ class FunctionInjector {\n     Node block = fnNode.getLastChild();\n \n     boolean hasSideEffects = false;\n-    if (block.hasChildren()) {\n+    if ((!isDirectCallNodeReplacementPossible(fnNode))) {\n       Preconditions.checkState(block.hasOneChild());\n       Node stmt = block.getFirstChild();\n       if (stmt.isReturn()) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 365,
    "bugId": 140,
    "name": "Patch_5_3",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 73d6a4b..c2a648c 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -695,7 +695,7 @@ class FunctionInjector {\n     Node block = fnNode.getLastChild();\n \n     boolean hasSideEffects = false;\n-    if (block.hasChildren()) {\n+    if ((block.hasChildren()) && (!block.hasChildren())) {\n       Preconditions.checkState(block.hasOneChild());\n       Node stmt = block.getFirstChild();\n       if (stmt.isReturn()) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 366,
    "bugId": 140,
    "name": "Patch_4_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-14 01:01:54.701269530 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_115/patches_lpy8/Patch_1/patched/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-14 01:22:55.692961375 -0400\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 367,
    "bugId": 140,
    "name": "Patch_8_2",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-13 22:49:35.765894855 -0400\n+++ /tmp/GenProg_Defects4J_Closure_115/patches_lqr1/Patch_1/patched/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-13 23:13:20.834910972 -0400\n@@ -695,13 +695,6 @@\n     Node block = fnNode.getLastChild();\n \n     boolean hasSideEffects = false;\n-    if (block.hasChildren()) {\n-      Preconditions.checkState(block.hasOneChild());\n-      Node stmt = block.getFirstChild();\n-      if (stmt.isReturn()) {\n-        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n-      }\n-    }\n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 368,
    "bugId": 140,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 369,
    "bugId": 141,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -694,6 +694,15 @@ private CanInlineResult canInlineReferenceDirectly(\n \n     Node block = fnNode.getLastChild();\n \n+    boolean hasSideEffects = false;  // empty function case\n+    if (block.hasChildren()) {\n+      Preconditions.checkState(block.hasOneChild());\n+      Node stmt = block.getFirstChild();\n+      if (stmt.isReturn()) {\n+        hasSideEffects = NodeUtil.mayHaveSideEffects(\n+            stmt.getFirstChild(), compiler);\n+      }\n+    }\n \n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n@@ -720,6 +729,9 @@ private CanInlineResult canInlineReferenceDirectly(\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n+          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+            return CanInlineResult.NO;\n+          }\n \n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 370,
    "bugId": 142,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\n@@ -51,7 +51,8 @@\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+          return topType.isAllType() ?\n+              getNativeType(ARRAY_TYPE) : topType;\n         }\n \n         @Override\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 371,
    "bugId": 143,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -355,6 +355,7 @@ private void findAliases(NodeTraversal t) {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n         boolean isVar = parent.isVar();\n+        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n           recordAlias(v);\n         } else if (v.isBleedingFunction()) {\n@@ -363,12 +364,13 @@ private void findAliases(NodeTraversal t) {\n         } else if (parent.getType() == Token.LP) {\n           // Parameters of the scope function also get a BAD_PARAMETERS\n           // error.\n-        } else if (isVar) {\n+        } else if (isVar || isFunctionDecl) {\n+          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n           Node grandparent = parent.getParent();\n-          Node value = n.hasChildren() ?\n-              v.getInitialValue().detachFromParent() :\n+          Node value = v.getInitialValue() != null ?\n+              v.getInitialValue() :\n               null;\n-          Node varNode = parent;\n+          Node varNode = null;\n \n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);\n@@ -380,7 +382,9 @@ private void findAliases(NodeTraversal t) {\n \n           // First, we need to free up the function expression (EXPR)\n           // to be used in another expression.\n+          if (isFunctionDecl) {\n             // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+            Node existingName = v.getNameNode();\n \n             // We can't keep the local name on the function expression,\n             // because IE is buggy and will leak the name into the global\n@@ -389,9 +393,19 @@ private void findAliases(NodeTraversal t) {\n             //\n             // This will only cause problems if this is a hoisted, recursive\n             // function, and the programmer is using the hoisting.\n+            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n+            value.replaceChild(existingName, newName);\n \n+            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n+            grandparent.replaceChild(parent, varNode);\n+          } else {\n+            if (value != null) {\n               // If this is a VAR, we can just detach the expression and\n               // the tree will still be valid.\n+              value.detachFromParent();\n+            }\n+            varNode = parent;\n+          }\n \n           // Add $jscomp.scope.name = EXPR;\n           // Make sure we copy over all the jsdoc and debug info.\n@@ -405,7 +419,11 @@ private void findAliases(NodeTraversal t) {\n             NodeUtil.setDebugInformation(\n                 newDecl.getFirstChild().getFirstChild(), n, name);\n \n+            if (isHoisted) {\n+              grandparent.addChildToFront(newDecl);\n+            } else {\n               grandparent.addChildBefore(newDecl, varNode);\n+            }\n           }\n \n           // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n@@ -551,6 +551,9 @@ public Node getChildBefore(Node child) {\n       return null;\n     }\n     Node n = first;\n+    if (n == null) {\n+      throw new RuntimeException(\"node is not a child\");\n+    }\n \n     while (n.next != child) {\n       n = n.next;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 372,
    "bugId": 144,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n@@ -492,6 +492,9 @@ private void handleObjectLit(NodeTraversal t, Node n) {\n           child != null;\n           child = child.getNext()) {\n         // Maybe STRING, GET, SET\n+        if (child.isQuotedString()) {\n+          continue;\n+        }\n \n         // We should never see a mix of numbers and strings.\n         String name = child.getString();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 373,
    "bugId": 145,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,9 @@ boolean isAssignedOnceInLifetime() {\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+          if (ref.getSymbol().getScope() != ref.scope) {\n+            return false;\n+          }\n           break;\n         } else if (block.isLoop) {\n           return false;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 374,
    "bugId": 146,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n@@ -363,6 +363,7 @@ public void collect(JSModule module, Scope scope, Node n) {\n                 isSet = true;\n                 type = Name.Type.FUNCTION;\n                 break;\n+              case Token.CATCH:\n               case Token.INC:\n               case Token.DEC:\n                 isSet = true;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 375,
    "bugId": 147,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -301,10 +301,12 @@ private void inlineNonConstants(\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+          referenceInfo.isAssignedOnceInLifetime() &&\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n+          (isInlineableDeclaredConstant(v, referenceInfo) ||\n+           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n           Node nameNode = refs.get(i).getNode();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 376,
    "bugId": 148,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -282,7 +282,7 @@ void add(Node n, Context context) {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+        Context rhsContext = getContextForNoInOperator(context);\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 377,
    "bugId": 149,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -249,7 +249,8 @@ private Node transformBlock(AstNode node) {\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+    Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\");\n+    if (p.matcher(comment.getValue()).find()) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 378,
    "bugId": 149,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 379,
    "bugId": 150,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,10 +138,6 @@ void tryMinimizeExits(Node n, int exitType, String labelName) {\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n     }\n \n     // Just a 'label'.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 380,
    "bugId": 150,
    "name": "Patch_32_32",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..817547ad 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,10 +138,21 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n+// start of generated patch\n+if(!n.isName()){\n+return ;\n+}\n+if(NodeUtil.hasFinally(n)){\n+Node finallyBlock=n.getLastChild();\n+tryMinimizeExits(finallyBlock,exitType,labelName);\n+}\n+// end of generated patch\n+/* start of original code\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n+ end of original code*/\n     }\n \n     // Just a 'label'.",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 381,
    "bugId": 150,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-11 08:42:04.502157309 -0400\n+++ /tmp/Arja_Defects4J_Closure_126/patches_jjv5/Patch_1/patched/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-11 09:05:19.376403652 -0400\n@@ -134,14 +134,6 @@\n         Node catchCodeBlock = catchNode.getLastChild();\n         tryMinimizeExits(catchCodeBlock, exitType, labelName);\n       }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n     }\n \n     // Just a 'label'.\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 382,
    "bugId": 150,
    "name": "Patch_16_7",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f17..0cf101f 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,10 +138,7 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+      \n     }\n \n     // Just a 'label'.\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 383,
    "bugId": 150,
    "name": "Patch_2_2",
    "tool": "jKali",
    "diff": "--- /tmp/jKali_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPointsjava\n+++ /tmp/jKali_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPointsjava\n@@ -138,7 +138,7 @@\n \n \n \n-\t\t\tif (com.google.javascript.jscomp.NodeUtil.hasFinally(n)) {\n+\t\t\tif (false) {\n \t\t\t\tcom.google.javascript.rhino.Node finallyBlock = n.getLastChild();\n \t\t\t\ttryMinimizeExits(finallyBlock, exitType, labelName);\n \t\t\t}",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 384,
    "bugId": 150,
    "name": "Patch_19_12",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPointsjava\n+++ /tmp/jGenProg_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPointsjava\n@@ -138,10 +138,10 @@\n \n \n \n-\t\t\tif (com.google.javascript.jscomp.NodeUtil.hasFinally(n)) {\n-\t\t\t\tcom.google.javascript.rhino.Node finallyBlock = n.getLastChild();\n-\t\t\t\ttryMinimizeExits(finallyBlock, exitType, labelName);\n-\t\t\t}\n+\n+\n+\n+\n \t\t}\n ",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 385,
    "bugId": 150,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..69c0ba44 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,7 +138,7 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n+      if (NodeUtil.isImmutableValue(n)) {\n         Node finallyBlock = n.getLastChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 386,
    "bugId": 150,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f17..ab2b0c4 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,7 +138,7 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n+      if ((n.isIf())) {\n         Node finallyBlock = n.getLastChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 387,
    "bugId": 150,
    "name": "Patch_2_2",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f17..29503e4 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,7 +138,7 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n+      if ((NodeUtil.hasFinally(n)) && (n.isLabel())) {\n         Node finallyBlock = n.getLastChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 388,
    "bugId": 150,
    "name": "Patch_9_2",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-13 22:55:30.981631648 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_126/patches_qwe1/Patch_2/patched/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-13 23:17:11.110207799 -0400\n@@ -140,7 +140,7 @@\n        */\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+        StringBuilder builder = new StringBuilder();\n       }\n     }\n \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 389,
    "bugId": 150,
    "name": "Patch_9_5",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-13 22:51:28.523554508 -0400\n+++ /tmp/GenProg_Defects4J_Closure_126/patches_efag/Patch_5/patched/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-13 23:13:06.909516277 -0400\n@@ -140,7 +140,6 @@\n        */\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n     }\n \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 390,
    "bugId": 150,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 391,
    "bugId": 151,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/ExploitAssigns.java\n+++ b/src/com/google/javascript/jscomp/ExploitAssigns.java\n@@ -210,7 +210,9 @@ private boolean isSafeReplacement(Node node, Node replacement) {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n+    while (node.isGetProp()) {\n       node = node.getFirstChild();\n+    }\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 392,
    "bugId": 151,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 393,
    "bugId": 152,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n@@ -167,13 +167,22 @@ private void tryRemoveUnconditionalBranching(Node n) {\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n \n+    private boolean inFinally(Node parent, Node child) {\n+      if (parent == null || parent.isFunction()) {\n+        return false;\n+      } else if (NodeUtil.isTryFinallyNode(parent, child)) {\n+        return true;\n+      } else {\n+        return inFinally(parent.getParent(), parent);\n+      }\n+    }\n \n     private Node computeFollowing(Node n) {\n       Node next = ControlFlowAnalysis.computeFollowNode(n);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 394,
    "bugId": 153,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1658,7 +1658,7 @@ private void visitNew(NodeTraversal t, Node n) {\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+      if (fnType != null && fnType.hasInstanceType()) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 395,
    "bugId": 153,
    "name": "Patch_48_48",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 4e053258..e04f78dd 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1658,12 +1658,22 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n+// start of generated patch\n+if(fnType!=null&&fnType.isConstructor()){\n+visitParameterList(t,n,fnType);\n+ensureTyped(t,n,fnType.getInstanceType());\n+}else {\n+ensureTyped(t,n);\n+}\n+// end of generated patch\n+/* start of original code\n       if (fnType != null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n+ end of original code*/\n     } else {\n       report(t, n, NOT_A_CONSTRUCTOR);\n       ensureTyped(t, n);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 396,
    "bugId": 153,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_125/src/com/google/javascript/jscomp/TypeCheck.java\t2019-08-11 08:17:47.587830849 -0400\n+++ /tmp/Arja_Defects4J_Closure_125/patches_9ox1/Patch_1/patched/com/google/javascript/jscomp/TypeCheck.java\t2019-08-11 08:41:59.410095210 -0400\n@@ -1658,12 +1658,6 @@\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n-        visitParameterList(t, n, fnType);\n-        ensureTyped(t, n, fnType.getInstanceType());\n-      } else {\n-        ensureTyped(t, n);\n-      }\n     } else {\n       report(t, n, NOT_A_CONSTRUCTOR);\n       ensureTyped(t, n);\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 397,
    "bugId": 153,
    "name": "Patch_4_4",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 4e05325..69291a6 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1658,7 +1658,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+      if ((type.isConstructor())) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 398,
    "bugId": 153,
    "name": "Patch_1_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_125/src/com/google/javascript/jscomp/TypeCheck.java\t2019-08-13 22:32:03.466866445 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_125/patches_xmdf/Patch_1/patched/com/google/javascript/jscomp/TypeCheck.java\t2019-08-13 22:55:26.181657677 -0400\n@@ -1658,12 +1658,7 @@\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n-        visitParameterList(t, n, fnType);\n-        ensureTyped(t, n, fnType.getInstanceType());\n-      } else {\n-        ensureTyped(t, n);\n-      }\n+      final String paramName = \"jscomp_throw_param\";\n     } else {\n       report(t, n, NOT_A_CONSTRUCTOR);\n       ensureTyped(t, n);\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 399,
    "bugId": 153,
    "name": "Patch_1_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_125/src/com/google/javascript/jscomp/TypeCheck.java\t2019-08-13 22:28:47.237616112 -0400\n+++ /tmp/GenProg_Defects4J_Closure_125/patches_6m11/Patch_1/patched/com/google/javascript/jscomp/TypeCheck.java\t2019-08-13 22:51:22.875616630 -0400\n@@ -1658,12 +1658,6 @@\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n-        visitParameterList(t, n, fnType);\n-        ensureTyped(t, n, fnType.getInstanceType());\n-      } else {\n-        ensureTyped(t, n);\n-      }\n     } else {\n       report(t, n, NOT_A_CONSTRUCTOR);\n       ensureTyped(t, n);\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 400,
    "bugId": 153,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 401,
    "bugId": 154,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -782,13 +782,16 @@ private void unrollBinaryOperator(\n \n   static boolean isSimpleNumber(String s) {\n     int len = s.length();\n+    if (len == 0) {\n+      return false;\n+    }\n     for (int index = 0; index < len; index++) {\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+    return len == 1 || s.charAt(0) != '0';\n   }\n \n   static double getSimpleNumber(String s) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 402,
    "bugId": 154,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 403,
    "bugId": 155,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -590,18 +590,22 @@ public static Number createNumber(final String str) throws NumberFormatException\n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n+            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                 final Float f = createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                     return f;\n                 }\n+            }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n+            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                 final Double d = createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                     return d;\n                 }\n+            }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 404,
    "bugId": 156,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n@@ -89,6 +89,9 @@ public static Locale toLocale(final String str) {\n         if (str == null) {\n             return null;\n         }\n+        if (str.contains(\"#\")) { // LANG-879 - Cannot handle Java 7 script & extensions\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n         final int len = str.length();\n         if (len < 2) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 405,
    "bugId": 157,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n@@ -94,6 +94,26 @@ public static Locale toLocale(final String str) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch0 = str.charAt(0);\n+        if (ch0 == '_') {\n+            if (len < 3) {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            final char ch1 = str.charAt(1);\n+            final char ch2 = str.charAt(2);\n+            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            if (len == 3) {\n+                return new Locale(\"\", str.substring(1, 3));\n+            }\n+            if (len < 5) {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            if (str.charAt(3) != '_') {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            return new Locale(\"\", str.substring(1, 3), str.substring(4));\n+        } else {\n             final char ch1 = str.charAt(1);\n             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n@@ -125,6 +145,7 @@ public static Locale toLocale(final String str) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 406,
    "bugId": 158,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -169,7 +169,7 @@ private void inlineAliases(GlobalNamespace namespace) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 407,
    "bugId": 158,
    "name": "Patch_4_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-11 15:34:19.872765841 -0400\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yd1l/Patch_1/patched/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-11 15:56:17.329232939 -0400\n@@ -169,21 +169,6 @@\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n-          name.aliasingGets > 0) {\n-        // {@code name} meets condition (b). Find all of its local aliases\n-        // and try to inline them.\n-        List<Ref> refs = Lists.newArrayList(name.getRefs());\n-        for (Ref ref : refs) {\n-          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n-            }\n-          }\n-        }\n-      }\n-\n       // Check if {@code name} has any aliases left after the\n       // local-alias-inlining above.\n       if ((name.type == Name.Type.OBJECTLIT ||\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 408,
    "bugId": 158,
    "name": "Patch_1_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-14 04:11:19.541376628 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_3c48/Patch_1/patched/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-14 04:33:31.684602309 -0400\n@@ -169,21 +169,6 @@\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n-          name.aliasingGets > 0) {\n-        // {@code name} meets condition (b). Find all of its local aliases\n-        // and try to inline them.\n-        List<Ref> refs = Lists.newArrayList(name.getRefs());\n-        for (Ref ref : refs) {\n-          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n-            }\n-          }\n-        }\n-      }\n-\n       // Check if {@code name} has any aliases left after the\n       // local-alias-inlining above.\n       if ((name.type == Name.Type.OBJECTLIT ||\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 409,
    "bugId": 158,
    "name": "Patch_1_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-14 03:55:33.367353396 -0400\n+++ /tmp/GenProg_Defects4J_Closure_130/patches_yur4/Patch_1/patched/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-14 04:16:48.673401682 -0400\n@@ -169,21 +169,6 @@\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n-          name.aliasingGets > 0) {\n-        // {@code name} meets condition (b). Find all of its local aliases\n-        // and try to inline them.\n-        List<Ref> refs = Lists.newArrayList(name.getRefs());\n-        for (Ref ref : refs) {\n-          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n-            }\n-          }\n-        }\n-      }\n-\n       // Check if {@code name} has any aliases left after the\n       // local-alias-inlining above.\n       if ((name.type == Name.Type.OBJECTLIT ||\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 410,
    "bugId": 158,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 411,
    "bugId": 159,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java\n@@ -28,7 +28,7 @@\n  */\n public class LookupTranslator extends CharSequenceTranslator {\n \n-    private final HashMap<CharSequence, CharSequence> lookupMap;\n+    private final HashMap<String, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;\n \n@@ -43,12 +43,12 @@\n      * @param lookup CharSequence[][] table of size [*][2]\n      */\n     public LookupTranslator(final CharSequence[]... lookup) {\n-        lookupMap = new HashMap<CharSequence, CharSequence>();\n+        lookupMap = new HashMap<String, CharSequence>();\n         int _shortest = Integer.MAX_VALUE;\n         int _longest = 0;\n         if (lookup != null) {\n             for (final CharSequence[] seq : lookup) {\n-                this.lookupMap.put(seq[0], seq[1]);\n+                this.lookupMap.put(seq[0].toString(), seq[1]);\n                 final int sz = seq[0].length();\n                 if (sz < _shortest) {\n                     _shortest = sz;\n@@ -74,7 +74,7 @@ public int translate(final CharSequence input, final int index, final Writer out\n         // descend so as to get a greedy algorithm\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n-            final CharSequence result = lookupMap.get(subSeq);\n+            final CharSequence result = lookupMap.get(subSeq.toString());\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 412,
    "bugId": 160,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n@@ -163,6 +163,9 @@ private void annotateCalls(Node n) {\n       Node first = n.getFirstChild();\n \n       // ignore cast nodes.\n+      while (first.isCast()) {\n+        first = first.getFirstChild();\n+      }\n \n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 413,
    "bugId": 161,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -464,11 +464,20 @@ public static Number createNumber(final String str) throws NumberFormatException\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n+            char firstSigDigit = 0; // strip leading zeroes\n+            for(int i = pfxLen; i < str.length(); i++) {\n+                firstSigDigit = str.charAt(i);\n+                if (firstSigDigit == '0') { // count leading zeroes\n+                    pfxLen++;\n+                } else {\n+                    break;\n+                }\n+            }\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n+            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long\n                 return createBigInteger(str);\n             }\n-            if (hexDigits > 8) { // too many for an int\n+            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 414,
    "bugId": 162,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,9 @@ private Node tryMinimizeIf(Node n) {\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+              !mayEffectMutableState(lhs) &&\n+              (!mayHaveSideEffects(cond) ||\n+                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 415,
    "bugId": 163,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -92,7 +92,7 @@ public final void translate(CharSequence input, Writer out) throws IOException {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+                pos += Character.charCount(Character.codePointAt(input, pt));\n             }\n         }\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 416,
    "bugId": 163,
    "name": "Patch_18_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\nindex 4d010ea..0500460 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -92,7 +92,7 @@ public abstract class CharSequenceTranslator {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+                pos += Character.charCount(Character.codePointAt(input, pt));\n             }\n         }\n     }\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 417,
    "bugId": 163,
    "name": "Patch_10_8",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\nindex 4d010ea..0500460 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -92,7 +92,7 @@ public abstract class CharSequenceTranslator {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+                pos += Character.charCount(Character.codePointAt(input, pt));\n             }\n         }\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 418,
    "bugId": 163,
    "name": "Patch_2_2",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\nindex 4d010ea..0500460 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -92,7 +92,7 @@ public abstract class CharSequenceTranslator {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+                pos += Character.charCount(Character.codePointAt(input, pt));\n             }\n         }\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 419,
    "bugId": 164,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -2398,6 +2398,7 @@ private void skipEOLs() {\n    */\n   private String getRemainingJSDocLine() {\n     String result = stream.getRemainingJSDocLine();\n+    unreadToken = NO_UNREAD_TOKEN;\n     return result;\n   }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 420,
    "bugId": 165,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -449,9 +449,6 @@ public static Number createNumber(String str) throws NumberFormatException {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n-        if (str.startsWith(\"--\")) {\n-            return null;\n-        }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n             if (str.startsWith(\"-\")) { // drop -\n@@ -718,10 +715,13 @@ public static BigDecimal createBigDecimal(String str) {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n+        if (str.trim().startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n+            throw new NumberFormatException(str + \" is not a valid number.\");\n+        }\n         return new BigDecimal(str);\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 421,
    "bugId": 165,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex d49da7f..dc96426 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -450,7 +450,7 @@ public class NumberUtils {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n-            return null;\n+if (str.startsWith(\"--\")==true){throw new NumberFormatException();}            return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 422,
    "bugId": 165,
    "name": "Patch_5_3",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex d49da7f..efa89f0 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -449,9 +449,7 @@ public class NumberUtils {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n-        if (str.startsWith(\"--\")) {\n-            return null;\n-        }\n+        \n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n             if (str.startsWith(\"-\")) { // drop -\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 423,
    "bugId": 165,
    "name": "Patch_23_2",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex d49da7f..7522c29 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -449,7 +449,7 @@ public class NumberUtils {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n-        if (str.startsWith(\"--\")) {\n+        if (str.startsWith(\"--\", INTEGER_ONE)) {\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 424,
    "bugId": 165,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex d49da7f..5115fe5 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -449,7 +449,7 @@ public class NumberUtils {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n-        if (str.startsWith(\"--\")) {\n+        if ((StringUtils.isBlank(str))) {\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 425,
    "bugId": 165,
    "name": "Patch_2_2",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex d49da7f..f5e5b68 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -449,7 +449,7 @@ public class NumberUtils {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n-        if (str.startsWith(\"--\")) {\n+        if ((str.startsWith(\"--\")) && (StringUtils.isBlank(str))) {\n             return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 426,
    "bugId": 166,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n@@ -191,12 +191,13 @@ public static boolean isJSIdentifier(String s) {\n       int length = s.length();\n \n       if (length == 0 ||\n+          Character.isIdentifierIgnorable(s.charAt(0)) ||\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+        if (Character.isIdentifierIgnorable(s.charAt(i)) ||\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 427,
    "bugId": 166,
    "name": "Patch_2_2",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_131/src/com/google/javascript/rhino/TokenStream.java\t2019-08-11 15:56:21.453209360 -0400\n+++ /tmp/Arja_Defects4J_Closure_131/patches_52pm/Patch_2/patched/com/google/javascript/rhino/TokenStream.java\t2019-08-11 16:20:53.936790048 -0400\n@@ -196,10 +196,7 @@\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n-            !Character.isJavaIdentifierPart(s.charAt(i))) {\n-          return false;\n-        }\n+        return false;\n       }\n \n       return true;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 428,
    "bugId": 166,
    "name": "Patch_81_27",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_131/src/com/google/javascript/rhino/TokenStream.java\t2019-08-14 04:33:36.812366762 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_131/patches_1yxv/Patch_27/patched/com/google/javascript/rhino/TokenStream.java\t2019-08-14 04:56:13.536519149 -0400\n@@ -196,10 +196,7 @@\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n-            !Character.isJavaIdentifierPart(s.charAt(i))) {\n-          return false;\n-        }\n+        return false;\n       }\n \n       return true;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 429,
    "bugId": 166,
    "name": "Patch_190_70",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_131/src/com/google/javascript/rhino/TokenStream.java\t2019-08-14 04:16:52.577448423 -0400\n+++ /tmp/GenProg_Defects4J_Closure_131/patches_rek5/Patch_70/patched/com/google/javascript/rhino/TokenStream.java\t2019-08-14 04:40:33.951011824 -0400\n@@ -196,10 +196,7 @@\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n-            !Character.isJavaIdentifierPart(s.charAt(i))) {\n-          return false;\n-        }\n+        return false;\n       }\n \n       return true;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 430,
    "bugId": 166,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 431,
    "bugId": 167,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\n@@ -1095,7 +1095,6 @@ static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n     private static class TimeZoneNameRule implements Rule {\n         private final Locale mLocale;\n         private final int mStyle;\n-        private final TimeZone zone;\n         private final String mStandard;\n         private final String mDaylight;\n \n@@ -1109,7 +1108,6 @@ static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local\n         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n             mLocale = locale;\n             mStyle = style;\n-            zone = timeZone;\n             \n             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n@@ -1131,6 +1129,7 @@ public int estimateLength() {\n          */\n         @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            TimeZone zone = calendar.getTimeZone();\n             if (zone.useDaylightTime()\n                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 432,
    "bugId": 168,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -301,17 +301,8 @@ public Date parse(String source, ParsePosition pos) {\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 433,
    "bugId": 168,
    "name": "Patch_44_2",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex a01159b..aaef1f7 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -304,13 +304,7 @@ public class FastDateParser implements DateParser, Serializable {\n         boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n+            \n             wasWhite= false;\n             switch(c) {\n             case '\\'':\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 434,
    "bugId": 168,
    "name": "Patch_119_5",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex a01159b..aaef1f7 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -304,13 +304,7 @@ public class FastDateParser implements DateParser, Serializable {\n         boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n+            \n             wasWhite= false;\n             switch(c) {\n             case '\\'':",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 435,
    "bugId": 168,
    "name": "Patch_7_7",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex a01159b..44c2db8 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -304,7 +304,7 @@ public class FastDateParser implements DateParser, Serializable {\n         boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n+            if((Character.isWhitespace(c)) && !(!wasWhite)) {\n                 if(!wasWhite) {\n                     wasWhite= true;\n                     regex.append(\"\\\\s*+\");",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 436,
    "bugId": 168,
    "name": "Patch_21_6",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex a01159b..aaef1f7 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -304,13 +304,7 @@ public class FastDateParser implements DateParser, Serializable {\n         boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n+            \n             wasWhite= false;\n             switch(c) {\n             case '\\'':",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 437,
    "bugId": 169,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n@@ -242,6 +242,10 @@ public static String random(int count, int start, int end, boolean letters, bool\n                     start = ' ';                \n                 }\n             }\n+        } else {\n+            if (end <= start) {\n+                throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n+            }\n         }\n \n         char[] buffer = new char[count];\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 438,
    "bugId": 170,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -141,6 +141,9 @@ private void init() {\n             currentFormatField= nextFormatField;\n             currentStrategy= nextStrategy;\n         }\n+        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\n+            throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n+        }\n         if(currentStrategy.addRegex(this, regex)) {\n             collector.add(currentStrategy);\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 439,
    "bugId": 171,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n@@ -217,58 +217,77 @@ public static Object deserialize(InputStream inputStream) {\n     public static Object deserialize(byte[] objectData) {\n         if (objectData == null) {\n             throw new IllegalArgumentException(\"The byte[] must not be null\");\n         }\n         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n         return deserialize(bais);\n     }\n \n     /**\n      * <p>Custom specialization of the standard JDK {@link java.io.ObjectInputStream}\n      * that uses a custom  <code>ClassLoader</code> to resolve a class.\n      * If the specified <code>ClassLoader</code> is not able to resolve the class,\n      * the context classloader of the current thread will be used.\n      * This way, the standard deserialization work also in web-application\n      * containers and application servers, no matter in which of the\n      * <code>ClassLoader</code> the particular class that encapsulates\n      * serialization/deserialization lives. </p>\n      * \n      * <p>For more in-depth information about the problem for which this\n      * class here is a workaround, see the JIRA issue LANG-626. </p>\n      */\n      static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {\n+        private static final Map<String, Class<?>> primitiveTypes = \n+                new HashMap<String, Class<?>>();\n         private ClassLoader classLoader;\n         \n         /**\n          * Constructor.\n          * @param in The <code>InputStream</code>.\n          * @param classLoader classloader to use\n          * @throws IOException if an I/O error occurs while reading stream header.\n          * @see java.io.ObjectInputStream\n          */\n         public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {\n             super(in);\n             this.classLoader = classLoader;\n \n+            primitiveTypes.put(\"byte\", byte.class);\n+            primitiveTypes.put(\"short\", short.class);\n+            primitiveTypes.put(\"int\", int.class);\n+            primitiveTypes.put(\"long\", long.class);\n+            primitiveTypes.put(\"float\", float.class);\n+            primitiveTypes.put(\"double\", double.class);\n+            primitiveTypes.put(\"boolean\", boolean.class);\n+            primitiveTypes.put(\"char\", char.class);\n+            primitiveTypes.put(\"void\", void.class);\n         }\n \n         /**\n          * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>\n          * of the current <code>Thread</code> to resolve the class.\n          * @param desc An instance of class <code>ObjectStreamClass</code>.\n          * @return A <code>Class</code> object corresponding to <code>desc</code>.\n          * @throws IOException Any of the usual Input/Output exceptions.\n          * @throws ClassNotFoundException If class of a serialized object cannot be found.\n          */\n         @Override\n         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n             String name = desc.getName();\n             try {\n                 return Class.forName(name, false, classLoader);\n             } catch (ClassNotFoundException ex) {\n+                try {\n                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n+                } catch (ClassNotFoundException cnfe) {\n+                    Class<?> cls = primitiveTypes.get(name);\n+                    if (cls != null)\n+                        return cls;\n+                    else\n+                        throw cnfe;\n+                }\n             }\n         }\n \n     }\n \n }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 440,
    "bugId": 171,
    "name": "Patch_12_3",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/SerializationUtils.java b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\nindex 1ee636c..8010115 100644\n--- a/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n@@ -251,23 +251,7 @@ public class SerializationUtils {\n \n         }\n \n-        /**\n-         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>\n-         * of the current <code>Thread</code> to resolve the class.\n-         * @param desc An instance of class <code>ObjectStreamClass</code>.\n-         * @return A <code>Class</code> object corresponding to <code>desc</code>.\n-         * @throws IOException Any of the usual Input/Output exceptions.\n-         * @throws ClassNotFoundException If class of a serialized object cannot be found.\n-         */\n-        @Override\n-        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n-            String name = desc.getName();\n-            try {\n-                return Class.forName(name, false, classLoader);\n-            } catch (ClassNotFoundException ex) {\n-                    return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n-            }\n-        }\n+        \n \n     }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 441,
    "bugId": 171,
    "name": "Patch_10_7",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/SerializationUtils.java b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\nindex 1ee636c..8010115 100644\n--- a/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n@@ -251,23 +251,7 @@ public class SerializationUtils {\n \n         }\n \n-        /**\n-         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>\n-         * of the current <code>Thread</code> to resolve the class.\n-         * @param desc An instance of class <code>ObjectStreamClass</code>.\n-         * @return A <code>Class</code> object corresponding to <code>desc</code>.\n-         * @throws IOException Any of the usual Input/Output exceptions.\n-         * @throws ClassNotFoundException If class of a serialized object cannot be found.\n-         */\n-        @Override\n-        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n-            String name = desc.getName();\n-            try {\n-                return Class.forName(name, false, classLoader);\n-            } catch (ClassNotFoundException ex) {\n-                    return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n-            }\n-        }\n+        \n \n     }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 442,
    "bugId": 172,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n@@ -227,14 +227,21 @@ public static String random(int count, int start, int end, boolean letters, bool\n         } else if (count < 0) {\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n+        if (chars != null && chars.length == 0) {\n+            throw new IllegalArgumentException(\"The chars array must not be empty\");\n+        }\n \n         if (start == 0 && end == 0) {\n+            if (chars != null) {\n+                end = chars.length;\n+            } else {\n                 if (!letters && !numbers) {\n                     end = Integer.MAX_VALUE;\n                 } else {\n                     end = 'z' + 1;\n                     start = ' ';                \n                 }\n+            }\n         }\n \n         char[] buffer = new char[count];\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 443,
    "bugId": 173,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -492,10 +492,10 @@ private void init() {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n+                if (tokenLen == 2) {\n                     rule = TwoDigitYearField.INSTANCE;\n+                } else {\n+                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 444,
    "bugId": 173,
    "name": "Patch_28_23",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex e043323..a708f4e 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -492,7 +492,7 @@ public class FastDateFormat extends Format {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n+                if ((tokenLen >= 4) || !(tokenLen == 2)) {\n                     rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                 } else {\n                     rule = TwoDigitYearField.INSTANCE;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 445,
    "bugId": 173,
    "name": "Patch_24_24",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex e043323..a708f4e 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -492,7 +492,7 @@ public class FastDateFormat extends Format {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n+                if ((tokenLen >= 4) || !(tokenLen == 2)) {\n                     rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                 } else {\n                     rule = TwoDigitYearField.INSTANCE;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 446,
    "bugId": 174,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -80,26 +80,20 @@ public final void translate(CharSequence input, Writer out) throws IOException {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n+        int len = input.length();\n         while (pos < len) {\n             int consumed = translate(input, pos, out);\n             if (consumed == 0) {\n                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n                 out.write(c);\n+                pos+= c.length;\n+                continue;\n             }\n-            else {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n                 pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n             }\n-            pos++;\n         }\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 447,
    "bugId": 175,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -785,7 +785,10 @@ public static boolean equals(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == null || cs2 == null) {\n             return false;\n         }\n+        if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n+        }\n+        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 448,
    "bugId": 176,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -455,7 +455,7 @@ public static Number createNumber(String str) throws NumberFormatException {\n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 449,
    "bugId": 177,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n@@ -216,9 +216,9 @@ private static boolean isAssignable(Type type, ParameterizedType toParameterized\n                 toClass, typeVarAssigns);\n \n         // now to check each type argument\n-        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n-            Type toTypeArg = entry.getValue();\n-            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n+        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {\n+            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);\n+            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);\n \n             // parameters must either be absent from the subject type, within\n             // the bounds of the wildcard type, or be an exact match to the\n@@ -672,7 +672,7 @@ private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type\n                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n \n         // has target class been reached?\n-        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n+        if (toClass.equals(cls)) {\n             return typeVarAssigns;\n         }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 450,
    "bugId": 178,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n@@ -262,7 +262,7 @@ public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 451,
    "bugId": 178,
    "name": "Patch_85_53",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/DateUtils.java b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\nindex 9a24c00..11ed8b4 100644\n--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n@@ -262,7 +262,7 @@ public class DateUtils {\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(MODIFY_TRUNCATE) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 452,
    "bugId": 179,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n@@ -37,7 +37,7 @@\n     public int translate(CharSequence input, int index, Writer out) throws IOException {\n         int seqEnd = input.length();\n         // Uses -2 to ensure there is something after the &#\n-        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n+        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n             int start = index + 2;\n             boolean isHex = false;\n \n@@ -47,11 +47,16 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 isHex = true;\n \n                 // Check there's more than just an x after the &#\n+                if(start == seqEnd) {\n+                    return 0;\n+                }\n             }\n \n             int end = start;\n             // Note that this supports character codes without a ; on the end\n-            while(input.charAt(end) != ';') \n+            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||\n+                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||\n+                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )\n             {\n                 end++;\n             }\n@@ -76,8 +81,9 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 out.write(entityValue);\n             }\n \n+            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');\n \n-            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n+            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n         }\n         return 0;\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 453,
    "bugId": 179,
    "name": "Patch_758_78",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\nindex 68891ac..5cf5c62 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n@@ -37,7 +37,7 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {\n     public int translate(CharSequence input, int index, Writer out) throws IOException {\n         int seqEnd = input.length();\n         // Uses -2 to ensure there is something after the &#\n-        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n+        if(input.charAt(index) == '&' && index < seqEnd - 4 && input.charAt(index + 1) == '#') {\n             int start = index + 2;\n             boolean isHex = false;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 454,
    "bugId": 180,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n@@ -70,6 +70,7 @@\n  */\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID = -2362048321261811743L;\n+    private static final int HASH_SEED = 31;\n \n     private static final String DUMMY_PATTERN = \"\";\n     private static final String ESCAPED_QUOTE = \"''\";\n@@ -260,12 +261,42 @@ public void setFormatsByArgumentIndex(Format[] newFormats) {\n      * @param obj the object to compare to\n      * @return true if this object equals the other, otherwise false\n      */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (!super.equals(obj)) {\n+            return false;\n+        }\n+        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {\n+          return false;\n+        }\n+        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n+        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n+            return false;\n+        }\n+        if (ObjectUtils.notEqual(registry, rhs.registry)) {\n+            return false;\n+        }\n+        return true;\n+    }\n \n     /**\n      * Return the hashcode.\n      *\n      * @return the hashcode\n      */\n+    @Override\n+    public int hashCode() {\n+        int result = super.hashCode();\n+        result = HASH_SEED * result + ObjectUtils.hashCode(registry);\n+        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);\n+        return result;\n+    }\n \n     /**\n      * Get a custom format from a format description.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 455,
    "bugId": 181,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n@@ -580,8 +580,14 @@ public Fraction pow(int power) {\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n+        if ((u == 0) || (v == 0)) {\n+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n+                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+            }\n+            return Math.abs(u) + Math.abs(v);\n+        }\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 456,
    "bugId": 181,
    "name": "Patch_8_8",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/Fraction.java b/src/main/java/org/apache/commons/lang3/math/Fraction.java\nindex b36a156..6627221 100644\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n@@ -581,7 +581,7 @@ public final class Fraction extends Number implements Comparable<Fraction> {\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 457,
    "bugId": 181,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/Fraction.java b/src/main/java/org/apache/commons/lang3/math/Fraction.java\nindex b36a156..04f1e4c 100644\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n@@ -581,7 +581,7 @@ public final class Fraction extends Number implements Comparable<Fraction> {\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(u) <= 1 && Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 458,
    "bugId": 181,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/Fraction.java b/src/main/java/org/apache/commons/lang3/math/Fraction.java\nindex b36a156..04f1e4c 100644\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n@@ -581,7 +581,7 @@ public final class Fraction extends Number implements Comparable<Fraction> {\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(u) <= 1 && Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 459,
    "bugId": 181,
    "name": "Patch_1_1",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/Fraction.java b/src/main/java/org/apache/commons/lang3/math/Fraction.java\nindex b36a156..0fdfc36 100644\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n@@ -581,7 +581,7 @@ public final class Fraction extends Number implements Comparable<Fraction> {\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(u)==1 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 460,
    "bugId": 182,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3295,7 +3295,7 @@ public static String join(Object[] array, char separator, int startIndex, int en\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder(noOfItems * 16);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n@@ -3380,7 +3380,7 @@ public static String join(Object[] array, String separator, int startIndex, int\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n+        StringBuilder buf = new StringBuilder(noOfItems * 16);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 461,
    "bugId": 182,
    "name": "Patch_121_20",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..4441214 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3380,7 +3380,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n+        StringBuilder buf = new StringBuilder((16) + separator.length());\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 462,
    "bugId": 182,
    "name": "Patch_53_10",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..919cc6a 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3295,7 +3295,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder((16) + 1);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 463,
    "bugId": 182,
    "name": "Patch_5_3",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..7f1e65a 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3295,7 +3295,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder(noOfItems + 1);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 464,
    "bugId": 182,
    "name": "Patch_13_8",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..b80ac21 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3380,7 +3380,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n+        StringBuilder buf = new StringBuilder(noOfItems + separator.length());\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 465,
    "bugId": 182,
    "name": "Patch_34_6",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..f079122 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3295,7 +3295,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder();\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 466,
    "bugId": 182,
    "name": "Patch_68_12",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..a308c6e 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3380,7 +3380,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n+        StringBuilder buf = new StringBuilder();\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 467,
    "bugId": 183,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -1410,7 +1410,7 @@ public static boolean isNumber(String str) {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+                return foundDigit && !hasExp && !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 468,
    "bugId": 183,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 4a1d845..445ce73 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -1409,7 +1409,7 @@ public class NumberUtils {\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n-                // not allowing L with an exponent or decimal point\n+if (hasDecPoint==true){return false;}                // not allowing L with an exponent or decimal point\n                 return foundDigit && !hasExp;\n             }\n             // last character is illegal",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 469,
    "bugId": 183,
    "name": "Patch_247_247",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 4a1d845..75571c2 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -1410,7 +1410,7 @@ public class NumberUtils {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+                return (foundDigit && !hasExp) && !(hasDecPoint || hasExp);\n             }\n             // last character is illegal\n             return false;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 470,
    "bugId": 183,
    "name": "Patch_12_12",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 4a1d845..75571c2 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -1410,7 +1410,7 @@ public class NumberUtils {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+                return (foundDigit && !hasExp) && !(hasDecPoint || hasExp);\n             }\n             // last character is illegal\n             return false;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 471,
    "bugId": 184,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -817,7 +817,7 @@ public String format(long millis) {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 472,
    "bugId": 184,
    "name": "Patch_45_8",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex e30da2a..65de708 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -817,7 +817,7 @@ public class FastDateFormat extends Format {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+        Calendar c = new GregorianCalendar(mTimeZone, this.mLocale);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 473,
    "bugId": 185,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n@@ -71,33 +71,33 @@\n         {\"\\u00C7\", \"&Ccedil;\"}, // \ufffd - uppercase C, cedilla\n         {\"\\u00C8\", \"&Egrave;\"}, // \ufffd - uppercase E, grave accent\n         {\"\\u00C9\", \"&Eacute;\"}, // \ufffd - uppercase E, acute accent\n-        {\"\\u00CB\", \"&Ecirc;\"}, // \ufffd - uppercase E, circumflex accent\n-        {\"\\u00CC\", \"&Euml;\"}, // \ufffd - uppercase E, umlaut\n-        {\"\\u00CD\", \"&Igrave;\"}, // \ufffd - uppercase I, grave accent\n-        {\"\\u00CE\", \"&Iacute;\"}, // \ufffd - uppercase I, acute accent\n-        {\"\\u00CF\", \"&Icirc;\"}, // \ufffd - uppercase I, circumflex accent\n-        {\"\\u00D0\", \"&Iuml;\"}, // \ufffd - uppercase I, umlaut\n-        {\"\\u00D1\", \"&ETH;\"}, // \ufffd - uppercase Eth, Icelandic\n-        {\"\\u00D2\", \"&Ntilde;\"}, // \ufffd - uppercase N, tilde\n-        {\"\\u00D3\", \"&Ograve;\"}, // \ufffd - uppercase O, grave accent\n-        {\"\\u00D4\", \"&Oacute;\"}, // \ufffd - uppercase O, acute accent\n-        {\"\\u00D5\", \"&Ocirc;\"}, // \ufffd - uppercase O, circumflex accent\n-        {\"\\u00D6\", \"&Otilde;\"}, // \ufffd - uppercase O, tilde\n-        {\"\\u00D7\", \"&Ouml;\"}, // \ufffd - uppercase O, umlaut\n-        {\"\\u00D8\", \"&times;\"}, // multiplication sign\n-        {\"\\u00D9\", \"&Oslash;\"}, // \ufffd - uppercase O, slash\n-        {\"\\u00DA\", \"&Ugrave;\"}, // \ufffd - uppercase U, grave accent\n-        {\"\\u00DB\", \"&Uacute;\"}, // \ufffd - uppercase U, acute accent\n-        {\"\\u00DC\", \"&Ucirc;\"}, // \ufffd - uppercase U, circumflex accent\n-        {\"\\u00DD\", \"&Uuml;\"}, // \ufffd - uppercase U, umlaut\n-        {\"\\u00DE\", \"&Yacute;\"}, // \ufffd - uppercase Y, acute accent\n-        {\"\\u00DF\", \"&THORN;\"}, // \ufffd - uppercase THORN, Icelandic\n-        {\"\\u00E0\", \"&szlig;\"}, // \ufffd - lowercase sharps, German\n-        {\"\\u00E1\", \"&agrave;\"}, // \ufffd - lowercase a, grave accent\n-        {\"\\u00E2\", \"&aacute;\"}, // \ufffd - lowercase a, acute accent\n-        {\"\\u00E3\", \"&acirc;\"}, // \ufffd - lowercase a, circumflex accent\n-        {\"\\u00E4\", \"&atilde;\"}, // \ufffd - lowercase a, tilde\n-        {\"\\u00E5\", \"&auml;\"}, // \ufffd - lowercase a, umlaut\n+        {\"\\u00CA\", \"&Ecirc;\"}, // \ufffd - uppercase E, circumflex accent\n+        {\"\\u00CB\", \"&Euml;\"}, // \ufffd - uppercase E, umlaut\n+        {\"\\u00CC\", \"&Igrave;\"}, // \ufffd - uppercase I, grave accent\n+        {\"\\u00CD\", \"&Iacute;\"}, // \ufffd - uppercase I, acute accent\n+        {\"\\u00CE\", \"&Icirc;\"}, // \ufffd - uppercase I, circumflex accent\n+        {\"\\u00CF\", \"&Iuml;\"}, // \ufffd - uppercase I, umlaut\n+        {\"\\u00D0\", \"&ETH;\"}, // \ufffd - uppercase Eth, Icelandic\n+        {\"\\u00D1\", \"&Ntilde;\"}, // \ufffd - uppercase N, tilde\n+        {\"\\u00D2\", \"&Ograve;\"}, // \ufffd - uppercase O, grave accent\n+        {\"\\u00D3\", \"&Oacute;\"}, // \ufffd - uppercase O, acute accent\n+        {\"\\u00D4\", \"&Ocirc;\"}, // \ufffd - uppercase O, circumflex accent\n+        {\"\\u00D5\", \"&Otilde;\"}, // \ufffd - uppercase O, tilde\n+        {\"\\u00D6\", \"&Ouml;\"}, // \ufffd - uppercase O, umlaut\n+        {\"\\u00D7\", \"&times;\"}, // multiplication sign\n+        {\"\\u00D8\", \"&Oslash;\"}, // \ufffd - uppercase O, slash\n+        {\"\\u00D9\", \"&Ugrave;\"}, // \ufffd - uppercase U, grave accent\n+        {\"\\u00DA\", \"&Uacute;\"}, // \ufffd - uppercase U, acute accent\n+        {\"\\u00DB\", \"&Ucirc;\"}, // \ufffd - uppercase U, circumflex accent\n+        {\"\\u00DC\", \"&Uuml;\"}, // \ufffd - uppercase U, umlaut\n+        {\"\\u00DD\", \"&Yacute;\"}, // \ufffd - uppercase Y, acute accent\n+        {\"\\u00DE\", \"&THORN;\"}, // \ufffd - uppercase THORN, Icelandic\n+        {\"\\u00DF\", \"&szlig;\"}, // \ufffd - lowercase sharps, German\n+        {\"\\u00E0\", \"&agrave;\"}, // \ufffd - lowercase a, grave accent\n+        {\"\\u00E1\", \"&aacute;\"}, // \ufffd - lowercase a, acute accent\n+        {\"\\u00E2\", \"&acirc;\"}, // \ufffd - lowercase a, circumflex accent\n+        {\"\\u00E3\", \"&atilde;\"}, // \ufffd - lowercase a, tilde\n+        {\"\\u00E4\", \"&auml;\"}, // \ufffd - lowercase a, umlaut\n         {\"\\u00E5\", \"&aring;\"}, // \ufffd - lowercase a, ring\n         {\"\\u00E6\", \"&aelig;\"}, // \ufffd - lowercase ae\n         {\"\\u00E7\", \"&ccedil;\"}, // \ufffd - lowercase c, cedilla\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 474,
    "bugId": 186,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/SystemUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SystemUtils.java\n@@ -1669,7 +1669,7 @@ static float toJavaVersionFloat(String version) {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n-    static float toJavaVersionInt(String version) {\n+    static int toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 475,
    "bugId": 187,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -1373,13 +1373,21 @@ public static int indexOfAny(CharSequence cs, char[] searchChars) {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n+        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n+        int searchLast = searchLen - 1;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                         // ch is a supplementary character\n+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n+                            return i;\n+                        }\n+                    } else {\n                         return i;\n+                    }\n                 }\n             }\n         }\n@@ -1440,7 +1448,7 @@ public static int indexOfAny(CharSequence cs, String searchChars) {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n+    public static boolean containsAny(String cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }\n@@ -1452,9 +1460,12 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLength; j++) {\n                 if (searchChars[j] == ch) {\n-                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n+                    if (Character.isHighSurrogate(ch)) {\n+                        if (j == searchLast) {\n                             // missing low surrogate, fine, like String.indexOf(String)\n-                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n+                            return true;\n+                        }\n+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n                             return true;\n                         }\n                     } else {\n@@ -1494,7 +1505,7 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {\n      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(CharSequence cs, String searchChars) {\n+    public static boolean containsAny(String cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }\n@@ -1530,13 +1541,21 @@ public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n+        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n+        int searchLast = searchLen - 1;\n         outer:\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n+                            continue outer;\n+                        }\n+                    } else {\n                         continue outer;\n+                    }\n                 }\n             }\n             return i;\n@@ -1573,8 +1592,16 @@ public static int indexOfAnyBut(String str, String searchChars) {\n         int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = str.charAt(i);\n-            if (searchChars.indexOf(ch) < 0) {\n+            boolean chFound = searchChars.indexOf(ch) >= 0;\n+            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n+                char ch2 = str.charAt(i + 1);\n+                if (chFound && searchChars.indexOf(ch2) < 0) {\n                     return i;\n+                }\n+            } else {\n+                if (!chFound) {\n+                    return i;\n+                }\n             }\n         }\n         return INDEX_NOT_FOUND;\n@@ -1675,14 +1702,25 @@ public static boolean containsNone(CharSequence cs, char[] searchChars) {\n             return true;\n         }\n         int csLen = cs.length();\n+        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n+        int searchLast = searchLen - 1;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n+                    if (Character.isHighSurrogate(ch)) {\n+                        if (j == searchLast) {\n                             // missing low surrogate, fine, like String.indexOf(String)\n+                            return false;\n+                        }\n+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n+                            return false;\n+                        }\n+                    } else {\n                         // ch is in the Basic Multilingual Plane\n                         return false;\n+                    }\n                 }\n             }\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 476,
    "bugId": 188,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n@@ -60,7 +60,13 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti\n                 return 0;\n             }\n \n+            if(entityValue > 0xFFFF) {\n+                char[] chrs = Character.toChars(entityValue);\n+                out.write(chrs[0]);\n+                out.write(chrs[1]);\n+            } else {\n                 out.write(entityValue);\n+            }\n             return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n         }\n         return 0;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 477,
    "bugId": 189,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -476,7 +476,7 @@ public static Number createNumber(String str) throws NumberFormatException {\n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+                if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n@@ -486,6 +486,9 @@ public static Number createNumber(String str) throws NumberFormatException {\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n+                if (expPos > str.length()) {\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 478,
    "bugId": 189,
    "name": "Patch_337_337",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex fd03ab8f..3117daac 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -485,11 +485,19 @@ public class NumberUtils {\n             }\n             mant = str.substring(0, decPos);\n         } else {\n+if(expPos>-1&&expPos<str.length()-1){\n+mant=str.substring(0,expPos);\n+}else {\n+mant=str;\n+}\n+// end of generated patch\n+/* start of original code\n             if (expPos > -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n             }\n+ end of original code*/\n             dec = null;\n         }\n         if (!Character.isDigit(lastChar) && lastChar != '.') {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 479,
    "bugId": 189,
    "name": "Patch_158_97",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex fd03ab8..b23bb45 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -486,7 +486,7 @@ public class NumberUtils {\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n-                mant = str.substring(0, expPos);\n+                mant = str.substring(0, INTEGER_ZERO);\n             } else {\n                 mant = str;\n             }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 480,
    "bugId": 190,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -1443,13 +1443,21 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {\n \t\t}\n \t\tint csLength = cs.length();\n \t\tint searchLength = searchChars.length;\n+\t\tint csLastIndex = csLength - 1;\n+\t\tint searchLastIndex = searchLength - 1;\n \t\tfor (int i = 0; i < csLength; i++) {\n \t\t\tchar ch = cs.charAt(i);\n \t\t\tfor (int j = 0; j < searchLength; j++) {\n \t\t\t\tif (searchChars[j] == ch) {\n+\t\t\t\t\tif (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n \t\t\t\t\t\t// ch is a supplementary character\n+\t\t\t\t\t\tif (searchChars[j + 1] == cs.charAt(i + 1)) {\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n \t\t\t\t\t\t// ch is in the Basic Multilingual Plane\n \t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 481,
    "bugId": 191,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n@@ -101,12 +101,7 @@\n      * \n      * @since 2.3\n      */\n-    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {\n-        @Override\n-        protected Set<IDKey> initialValue() {\n-            return new HashSet<IDKey>();\n-        }\n-    };\n+    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\n \n     /*\n      * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n@@ -149,7 +144,8 @@\n      * @since 2.3\n      */\n     static boolean isRegistered(Object value) {\n-        return getRegistry().contains(new IDKey(value));\n+        Set<IDKey> registry = getRegistry();\n+        return registry != null && registry.contains(new IDKey(value));\n     }\n \n     /**\n@@ -519,6 +515,11 @@ public static int reflectionHashCode(Object object, String[] excludeFields) {\n      *            The object to register.\n      */\n     static void register(Object value) {\n+        synchronized (HashCodeBuilder.class) {\n+            if (getRegistry() == null) {\n+                REGISTRY.set(new HashSet<IDKey>());\n+            }\n+        }\n         getRegistry().add(new IDKey(value));\n     }\n \n@@ -535,7 +536,15 @@ static void register(Object value) {\n      * @since 2.3\n      */\n     static void unregister(Object value) {\n-        getRegistry().remove(new IDKey(value));\n+        Set<IDKey> s = getRegistry();\n+        if (s != null) {\n+            s.remove(new IDKey(value));\n+            synchronized (HashCodeBuilder.class) {\n+                if (s.isEmpty()) {\n+                    REGISTRY.remove();\n+                }\n+            }\n+        }\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 482,
    "bugId": 192,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -907,7 +907,7 @@ private static String toCanonicalName(String className) {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+            classes[i] = array[i] == null ? null : array[i].getClass();\n         }\n         return classes;\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 483,
    "bugId": 192,
    "name": "Patch_16_16",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex 615e4a9a..6c297d6e 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -906,9 +906,16 @@ public class ClassUtils {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n+// start of generated patch\n+for(int i=0;i<array.length;i++){\n+classes[i]=array[i]==null?null:array[i].getClass();\n+}\n+// end of generated patch\n+/* start of original code\n         for (int i = 0; i < array.length; i++) {\n             classes[i] = array[i].getClass();\n         }\n+ end of original code*/\n         return classes;\n     }\n ",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 484,
    "bugId": 192,
    "name": "Patch_7_4",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex 615e4a9..baadf72 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -907,7 +907,9 @@ public class ClassUtils {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+            if (classes == null) continue;\n+\tif (array[i] == null) continue;\n+\tclasses[i] = array[i].getClass();\n         }\n         return classes;\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 485,
    "bugId": 193,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n@@ -145,7 +145,7 @@\n      * @return Set the registry of objects being traversed\n      */\n     static Map<Object, Object> getRegistry() {\n-        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n+        return REGISTRY.get();\n     }\n \n     /**\n@@ -161,7 +161,7 @@\n      */\n     static boolean isRegistered(Object value) {\n         Map<Object, Object> m = getRegistry();\n-        return m.containsKey(value);\n+        return m != null && m.containsKey(value);\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 486,
    "bugId": 194,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -2959,8 +2959,16 @@ public static boolean isEmpty(boolean[] array) {\n         final Class<?> type1 = array1.getClass().getComponentType();\n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        try {\n             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        } catch (ArrayStoreException ase) {\n             // Check if problem is incompatible types\n+            final Class<?> type2 = array2.getClass().getComponentType();\n+            if (!type1.isAssignableFrom(type2)){\n+                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n+            }\n+            throw ase; // No, so rethrow original\n+        }\n         return joinedArray;\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 487,
    "bugId": 195,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -3292,7 +3292,7 @@ public static boolean isEmpty(boolean[] array) {\n         } else if (element != null) {\n             type = element.getClass();\n         } else {\n-            type = Object.class;\n+            throw new IllegalArgumentException(\"Arguments cannot both be null\");            \n         }\n         @SuppressWarnings(\"unchecked\") // type must be T\n         T[] newArray = (T[]) copyArrayGrow1(array, type);\n@@ -3571,7 +3571,7 @@ private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n-            return (T[]) new Object[] { null };\n+            throw new IllegalArgumentException(\"Array and element cannot both be null\");            \n         }\n         @SuppressWarnings(\"unchecked\") // the add method creates an array of type clss, which is type T\n         final T[] newArray = (T[]) add(array, index, element, clss);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 488,
    "bugId": 196,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -869,6 +869,7 @@ public StringBuffer format(Date date, StringBuffer buf) {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\n+            calendar.getTime(); /// LANG-538\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 489,
    "bugId": 197,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/Entities.java\n+++ b/src/java/org/apache/commons/lang/Entities.java\n@@ -825,10 +825,15 @@ public String escape(String str) {\n     public void escape(Writer writer, String str) throws IOException {\n         int len = str.length();\n         for (int i = 0; i < len; i++) {\n-            char c = str.charAt(i);\n+            int c = Character.codePointAt(str, i); \n             String entityName = this.entityName(c);\n             if (entityName == null) {\n-                if (c > 0x7F) {\n+                if (c >= 0x010000 && i < len - 1) {\n+                    writer.write(\"&#\");\n+                    writer.write(Integer.toString(c, 10));\n+                    writer.write(';');\n+                    i++;\n+                } else if (c > 0x7F) { \n                     writer.write(\"&#\");\n                     writer.write(Integer.toString(c, 10));\n                     writer.write(';');\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 490,
    "bugId": 198,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n@@ -419,6 +419,7 @@ private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n+            next(pos);\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 491,
    "bugId": 198,
    "name": "Patch_29_29",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\nindex 404be490..e8feb500 100644\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n@@ -418,9 +418,17 @@ public class ExtendedMessageFormat extends MessageFormat {\n             StringBuffer appendTo, boolean escapingOn) {\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n+// start of generated patch\n+if(escapingOn&&c[start]==QUOTE){\n+next(pos);\n+return appendTo==null?null:appendTo.append(QUOTE);\n+}\n+// end of generated patch\n+/* start of original code\n         if (escapingOn && c[start] == QUOTE) {\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n+ end of original code*/\n         int lastHold = start;\n         for (int i = pos.getIndex(); i < pattern.length(); i++) {\n             if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 492,
    "bugId": 198,
    "name": "Patch_5_5",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Lang_43/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\t2019-06-25 23:23:30.323958384 -0400\n+++ /tmp/Arja_Defects4J_Lang_43/patches_dejh/Patch_5/patched/org/apache/commons/lang/text/ExtendedMessageFormat.java\t2019-06-25 23:28:46.443957668 -0400\n@@ -419,7 +419,7 @@\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n-            return appendTo == null ? null : appendTo.append(QUOTE);\n+            pos.setIndex(pos.getIndex() + 1);\n         }\n         int lastHold = start;\n         for (int i = pos.getIndex(); i < pattern.length(); i++) {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 493,
    "bugId": 198,
    "name": "Patch_17_11",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Lang_43/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\t2019-07-04 10:05:01.303252082 -0400\n+++ /tmp/RSRepair_Defects4J_Lang_43/patches_j1ki/Patch_11/patched/org/apache/commons/lang/text/ExtendedMessageFormat.java\t2019-07-04 10:10:30.568024478 -0400\n@@ -419,7 +419,7 @@\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n-            return appendTo == null ? null : appendTo.append(QUOTE);\n+            pos.setIndex(pos.getIndex() + 1);\n         }\n         int lastHold = start;\n         for (int i = pos.getIndex(); i < pattern.length(); i++) {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 494,
    "bugId": 198,
    "name": "Patch_17_13",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Lang_43/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\t2019-07-01 13:36:26.689720435 -0400\n+++ /tmp/GenProg_Defects4J_Lang_43/patches_0g6u/Patch_13/patched/org/apache/commons/lang/text/ExtendedMessageFormat.java\t2019-07-01 13:41:59.540190899 -0400\n@@ -419,7 +419,8 @@\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n-            return appendTo == null ? null : appendTo.append(QUOTE);\n+            next(pos);\n+\t\t\treturn appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;\n         for (int i = pos.getIndex(); i < pattern.length(); i++) {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 495,
    "bugId": 199,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -488,7 +488,7 @@ public static Number createNumber(String str) throws NumberFormatException {\n             }\n             dec = null;\n         }\n-        if (!Character.isDigit(lastChar)) {\n+        if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n@@ -1385,6 +1385,14 @@ public static boolean isNumber(String str) {\n                 // can't have an E at the last byte\n                 return false;\n             }\n+            if (chars[i] == '.') {\n+                if (hasDecPoint || hasExp) {\n+                    // two decimal points or dec in exponent\n+                    return false;\n+                }\n+                // single trailing decimal point after non-exponent is ok\n+                return foundDigit;\n+            }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 496,
    "bugId": 200,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/java/org/apache/commons/lang3/StringUtils.java\n@@ -3673,6 +3673,9 @@ private static String replaceEach(String text, String[] searchList, String[] rep\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n         for (int i = 0; i < searchList.length; i++) {\n+            if (searchList[i] == null || replacementList[i] == null) {\n+                continue;\n+            }\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 497,
    "bugId": 200,
    "name": "Patch_3_3",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Lang_39/src/java/org/apache/commons/lang3/StringUtilsjava\n+++ /tmp/Cardumen_Defects4J_Lang_39/src/java/org/apache/commons/lang3/StringUtilsjava\n@@ -3673,7 +3673,7 @@\n \n \n \t\tfor (int i = 0; i < (searchList.length); i++) {\n-\t\t\tint greater = (replacementList[i].length()) - (searchList[i].length());\n+\t\t\tint greater = (org.apache.commons.lang3.StringUtils.strip(EMPTY, null).length()) - (searchList[i].length());\n \t\t\tif (greater > 0) {\n \t\t\t\tincrease += 3 * greater;\n \t\t\t}",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 498,
    "bugId": 200,
    "name": "Patch_17_17",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang3/StringUtils.java b/src/java/org/apache/commons/lang3/StringUtils.java\nindex 14563aa6..3ffd996b 100644\n--- a/src/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/java/org/apache/commons/lang3/StringUtils.java\n@@ -3672,12 +3672,25 @@ public class StringUtils {\n         int increase = 0;\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n+// start of generated patch\n+for(int i=0;i<searchList.length;i++){\n+if(noMoreMatchesForReplIndex[i]||searchList[i]==null||searchList[i].length()==0||replacementList[i]==null){\n+continue;\n+}\n+int greater=replacementList[i].length()-searchList[i].length();\n+if(greater>0){\n+increase+=3*greater;\n+}\n+}\n+// end of generated patch\n+/* start of original code\n         for (int i = 0; i < searchList.length; i++) {\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n             }\n         }\n+ end of original code*/\n         // have upper-bound at 20% increase, then let Java take over\n         increase = Math.min(increase, text.length() / 5);\n ",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 499,
    "bugId": 200,
    "name": "Patch_13_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang3/StringUtils.java b/src/java/org/apache/commons/lang3/StringUtils.java\nindex 14563aa..54b2a0c 100644\n--- a/src/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/java/org/apache/commons/lang3/StringUtils.java\n@@ -3673,7 +3673,7 @@ public class StringUtils {\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n         for (int i = 0; i < searchList.length; i++) {\n-            int greater = replacementList[i].length() - searchList[i].length();\n+            int greater = searchList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n             }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 500,
    "bugId": 200,
    "name": "Patch_7_4",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang3/StringUtils.java b/src/java/org/apache/commons/lang3/StringUtils.java\nindex 14563aa..e139fda 100644\n--- a/src/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/java/org/apache/commons/lang3/StringUtils.java\n@@ -3673,7 +3673,9 @@ public class StringUtils {\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n         for (int i = 0; i < searchList.length; i++) {\n-            int greater = replacementList[i].length() - searchList[i].length();\n+            if (replacementList[i] == null) continue;\n+\tif (searchList[i] == null) continue;\n+\tint greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n             }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 501,
    "bugId": 201,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n@@ -188,10 +188,23 @@ public static String getShortClassName(String className) {\n             return StringUtils.EMPTY;\n         }\n \n+        StringBuffer arrayPrefix = new StringBuffer();\n \n         // Handle array encoding\n+        if (className.startsWith(\"[\")) {\n+            while (className.charAt(0) == '[') {\n+                className = className.substring(1);\n+                arrayPrefix.append(\"[]\");\n+            }\n             // Strip Object type encoding\n+            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n+                className = className.substring(1, className.length() - 1);\n+            }\n+        }\n \n+        if (reverseAbbreviationMap.containsKey(className)) {\n+            className = reverseAbbreviationMap.get(className);\n+        }\n \n         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n         int innerIdx = className.indexOf(\n@@ -200,7 +213,7 @@ public static String getShortClassName(String className) {\n         if (innerIdx != -1) {\n             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n         }\n-        return out;\n+        return out + arrayPrefix;\n     }\n \n     // Package name\n@@ -242,12 +255,18 @@ public static String getPackageName(Class<?> cls) {\n      * @return the package name or an empty string\n      */\n     public static String getPackageName(String className) {\n-        if (className == null) {\n+        if (className == null || className.length() == 0) {\n             return StringUtils.EMPTY;\n         }\n \n         // Strip array encoding\n+        while (className.charAt(0) == '[') {\n+            className = className.substring(1);\n+        }\n         // Strip Object type encoding\n+        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n+            className = className.substring(1);\n+        }\n \n         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n         if (i == -1) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 502,
    "bugId": 202,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n@@ -1045,7 +1045,14 @@ public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+        int len = searchStr.length();\n+        int max = str.length() - len;\n+        for (int i = 0; i <= max; i++) {\n+            if (str.regionMatches(true, i, searchStr, 0, len)) {\n+                return true;\n+            }\n+        }\n+        return false;\n     }\n \n     // IndexOfAny chars\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 503,
    "bugId": 203,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n@@ -142,6 +142,9 @@ public static Number createNumber(String val) throws NumberFormatException {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n+        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {\n+            throw new NumberFormatException(val + \" is not a valid number.\");\n+        }\n         if (val.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 504,
    "bugId": 204,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/WordUtils.java\n+++ b/src/java/org/apache/commons/lang/WordUtils.java\n@@ -613,6 +613,9 @@ public static String abbreviate(String str, int lower, int upper, String appendT\n \n         // if the lower value is greater than the length of the string,\n         // set to the length of the string\n+        if (lower > str.length()) {\n+            lower = str.length();    \n+        }\n         // if the upper value is -1 (i.e. no limit) or is greater\n         // than the length of the string, set to the length of the string\n         if (upper == -1 || upper > str.length()) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 505,
    "bugId": 205,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1183,6 +1183,9 @@ public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n+            if (str == null) {\n+                str = \"\";\n+            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);\n@@ -1227,6 +1230,9 @@ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n+            if (str == null) {\n+                str = \"\";\n+            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(0, width, buffer, size);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 506,
    "bugId": 205,
    "name": "Patch_66_36",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 13281ce..1f64e59 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1227,7 +1227,8 @@ public class StrBuilder implements Cloneable {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n-            int strLen = str.length();\n+            if (str == null) str = new String();\n+ int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(0, width, buffer, size);\n             } else {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 507,
    "bugId": 205,
    "name": "Patch_33_18",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 13281ce..bf81de2 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1183,7 +1183,8 @@ public class StrBuilder implements Cloneable {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n-            int strLen = str.length();\n+            if (str == null) str = new String();\n+ int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);\n             } else {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 508,
    "bugId": 206,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n@@ -377,8 +377,12 @@ public EqualsBuilder append(Object lhs, Object rhs) {\n         }\n         Class lhsClass = lhs.getClass();\n         if (!lhsClass.isArray()) {\n+            if (lhs instanceof java.math.BigDecimal) {\n+                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);\n+            } else {\n                 // The simple case, not an array, just test the element\n                 isEquals = lhs.equals(rhs);\n+            }\n         } else if (lhs.getClass() != rhs.getClass()) {\n             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n             this.setEquals(false);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 509,
    "bugId": 207,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n@@ -233,6 +233,10 @@ private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n+                    case '/':\n+                        out.write('\\\\');\n+                        out.write('/');\n+                        break;\n                     default :\n                         out.write(ch);\n                         break;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 510,
    "bugId": 208,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n@@ -640,18 +640,18 @@ private static void modify(Calendar val, int field, boolean round) {\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n+        }\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n         }\n \n         // truncate seconds\n         int seconds = val.get(Calendar.SECOND);\n         if (!done && (!round || seconds < 30)) {\n             time = time - (seconds * 1000L);\n+        }\n         if (field == Calendar.MINUTE) {\n             done = true;\n-            }\n         }\n \n         // truncate minutes\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 511,
    "bugId": 209,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n@@ -83,7 +83,7 @@ public StringEscapeUtils() {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJava(String str) {\n-        return escapeJavaStyleString(str, false);\n+        return escapeJavaStyleString(str, false, false);\n     }\n \n     /**\n@@ -99,7 +99,7 @@ public static String escapeJava(String str) {\n      * @throws IOException if error occurs on underlying Writer\n      */\n     public static void escapeJava(Writer out, String str) throws IOException {\n-        escapeJavaStyleString(out, str, false);\n+        escapeJavaStyleString(out, str, false, false);\n     }\n \n     /**\n@@ -124,7 +124,7 @@ public static void escapeJava(Writer out, String str) throws IOException {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJavaScript(String str) {\n-        return escapeJavaStyleString(str, true);\n+        return escapeJavaStyleString(str, true, true);\n     }\n \n     /**\n@@ -140,7 +140,7 @@ public static String escapeJavaScript(String str) {\n      * @throws IOException if error occurs on underlying Writer\n      **/\n     public static void escapeJavaScript(Writer out, String str) throws IOException {\n-        escapeJavaStyleString(out, str, true);\n+        escapeJavaStyleString(out, str, true, true);\n     }\n \n     /**\n@@ -151,13 +151,13 @@ public static void escapeJavaScript(Writer out, String str) throws IOException {\n      * @param escapeForwardSlash TODO\n      * @return the escaped string\n      */\n-    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n+    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {\n         if (str == null) {\n             return null;\n         }\n         try {\n             StringWriter writer = new StringWriter(str.length() * 2);\n-            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n+            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);\n             return writer.toString();\n         } catch (IOException ioe) {\n             // this should never ever happen while writing to a StringWriter\n@@ -175,7 +175,8 @@ private static String escapeJavaStyleString(String str, boolean escapeSingleQuot\n      * @param escapeForwardSlash TODO\n      * @throws IOException if an IOException occurs\n      */\n-    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n+    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,\n+            boolean escapeForwardSlash) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }\n@@ -241,7 +242,9 @@ private static void escapeJavaStyleString(Writer out, String str, boolean escape\n                         out.write('\\\\');\n                         break;\n                     case '/' :\n+                        if (escapeForwardSlash) {\n                             out.write('\\\\');\n+                        }\n                         out.write('/');\n                         break;\n                     default :\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 512,
    "bugId": 209,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n@@ -243,3 +243,5 @@\n                     case '/' :\n-                            out.write('\\\\');\n+                            if (escapeSingleQuote) {\n+                                out.write('\\\\');\n+                            }\n                         out.write('/');\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 513,
    "bugId": 209,
    "name": "Patch_5_5",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Lang_46/src/java/org/apache/commons/lang/StringEscapeUtils.java\t2019-06-25 23:38:53.611956292 -0400\n+++ /tmp/Arja_Defects4J_Lang_46/patches_k3mh/Patch_5/patched/org/apache/commons/lang/StringEscapeUtils.java\t2019-06-25 23:43:05.535955721 -0400\n@@ -241,7 +241,9 @@\n                         out.write('\\\\');\n                         break;\n                     case '/' :\n-                            out.write('\\\\');\n+\t\t\t\t\tif (escapeSingleQuote) {\n+\t\t\t\t\t\tout.write('\\\\');\n+\t\t\t\t\t}\n                         out.write('/');\n                         break;\n                     default :\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 514,
    "bugId": 209,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n@@ -243,3 +243,5 @@\n                     case '/' :\n-                            out.write('\\\\');\n+                            if (escapeSingleQuote) {\n+                                out.write('\\\\');\n+                            }\n                         out.write('/');\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 515,
    "bugId": 209,
    "name": "Patch_1738_1089",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Lang_46/src/java/org/apache/commons/lang/StringEscapeUtils.java\t2019-07-04 10:45:14.757898329 -0400\n+++ /tmp/RSRepair_Defects4J_Lang_46/patches_lza6/Patch_1089/patched/org/apache/commons/lang/StringEscapeUtils.java\t2019-07-04 11:00:00.752659211 -0400\n@@ -241,7 +241,9 @@\n                         out.write('\\\\');\n                         break;\n                     case '/' :\n-                            out.write('\\\\');\n+\t\t\t\t\tif (escapeSingleQuote) {\n+\t\t\t\t\t\tout.write('\\\\');\n+\t\t\t\t\t}\n                         out.write('/');\n                         break;\n                     default :\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 516,
    "bugId": 210,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n@@ -282,16 +282,14 @@ public static synchronized FastDateFormat getDateInstance(int style, TimeZone ti\n             key = new Pair(key, timeZone);\n         }\n \n-        if (locale != null) {\n-            key = new Pair(key, locale);\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n         }\n \n+        key = new Pair(key, locale);\n \n         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n         if (format == null) {\n-            if (locale == null) {\n-                locale = Locale.getDefault();\n-            }\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                 String pattern = formatter.toPattern();\n@@ -462,15 +460,13 @@ public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n-        if (locale != null) {\n-            key = new Pair(key, locale);\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n         }\n+        key = new Pair(key, locale);\n \n         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n         if (format == null) {\n-            if (locale == null) {\n-                locale = Locale.getDefault();\n-            }\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                         locale);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 517,
    "bugId": 210,
    "name": "Patch_340_340",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Lang_50/src/java/org/apache/commons/lang/time/FastDateFormat.java\t2019-06-26 00:14:05.167951507 -0400\n+++ /tmp/Arja_Defects4J_Lang_50/patches_w8jx/Patch_340/patched/org/apache/commons/lang/time/FastDateFormat.java\t2019-06-26 00:22:16.511950393 -0400\n@@ -282,7 +282,10 @@\n             key = new Pair(key, timeZone);\n         }\n \n-        if (locale != null) {\n+        if (locale == null) {\n+\t\t\tlocale = Locale.getDefault();\n+\t\t}\n+\t\tif (locale != null) {\n             key = new Pair(key, locale);\n         }\n \n@@ -290,7 +293,6 @@\n         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n         if (format == null) {\n             if (locale == null) {\n-                locale = Locale.getDefault();\n             }\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n@@ -468,7 +470,8 @@\n \n         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n         if (format == null) {\n-            if (locale == null) {\n+            key = new Pair(key, locale);\n+\t\t\tif (locale == null) {\n                 locale = Locale.getDefault();\n             }\n             try {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 518,
    "bugId": 210,
    "name": "Patch_106_18",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/FastDateFormat.java b/src/java/org/apache/commons/lang/time/FastDateFormat.java\nindex 8a26f28..2bd90b5 100644\n--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n@@ -287,7 +287,7 @@ public class FastDateFormat extends Format {\n         }\n \n \n-        FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n+        FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n         if (format == null) {\n             if (locale == null) {\n                 locale = Locale.getDefault();",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 519,
    "bugId": 210,
    "name": "Patch_237_42",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/FastDateFormat.java b/src/java/org/apache/commons/lang/time/FastDateFormat.java\nindex 8a26f28..52df684 100644\n--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n@@ -466,7 +466,7 @@ public class FastDateFormat extends Format {\n             key = new Pair(key, locale);\n         }\n \n-        FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n+        FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n         if (format == null) {\n             if (locale == null) {\n                 locale = Locale.getDefault();",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 520,
    "bugId": 211,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/BooleanUtils.java\n+++ b/src/java/org/apache/commons/lang/BooleanUtils.java\n@@ -679,6 +679,7 @@ public static boolean toBoolean(String str) {\n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                 }\n+                return false;\n             }\n             case 4: {\n                 char ch = str.charAt(0);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 521,
    "bugId": 211,
    "name": "Patch_4_2",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/BooleanUtils.java b/src/java/org/apache/commons/lang/BooleanUtils.java\nindex 3fda4ec..d9dd2eb 100644\n--- a/src/java/org/apache/commons/lang/BooleanUtils.java\n+++ b/src/java/org/apache/commons/lang/BooleanUtils.java\n@@ -679,6 +679,8 @@ public class BooleanUtils {\n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                 }\n+\t return false;\n+\n             }\n             case 4: {\n                 char ch = str.charAt(0);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 522,
    "bugId": 212,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/math/Fraction.java\n+++ b/src/java/org/apache/commons/lang/math/Fraction.java\n@@ -463,6 +463,9 @@ public double doubleValue() {\n      * @return a new reduced fraction instance, or this if no simplification possible\n      */\n     public Fraction reduce() {\n+        if (numerator == 0) {\n+            return equals(ZERO) ? this : ZERO;\n+        }\n         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n         if (gcd == 1) {\n             return this;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 523,
    "bugId": 213,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -111,6 +111,9 @@ public static Locale toLocale(String str) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n             char ch3 = str.charAt(3);\n+            if (ch3 == '_') {\n+                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n+            }\n             char ch4 = str.charAt(4);\n             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 524,
    "bugId": 214,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,7 @@ public static Set availableLocaleSet() {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return availableLocaleList().contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 525,
    "bugId": 214,
    "name": "Patch_2_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex ceb886e..158b8eb 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return cAvailableLocaleList.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 526,
    "bugId": 214,
    "name": "Patch_11_4",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex ceb886e..139d9a7 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return availableLocaleList().contains(locale);\n     }\n \n     //-----------------------------------------------------------------------",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 527,
    "bugId": 214,
    "name": "Patch_7_6",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex ceb886e..aaa27dc 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,10 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        if (cAvailableLocaleSet == null) {\n+    return false;\n+}\n+return cAvailableLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 528,
    "bugId": 214,
    "name": "Patch_37_17",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex ceb886e..139d9a7 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return availableLocaleList().contains(locale);\n     }\n \n     //-----------------------------------------------------------------------",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 529,
    "bugId": 215,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -451,8 +451,7 @@ public static Number createNumber(String str) throws NumberFormatException {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 530,
    "bugId": 215,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex c0f06a47..1e37c4ac 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -449,6 +449,17 @@ public class NumberUtils {\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n+// start of generated patch\n+if(dec==null&&exp==null&&(numeric.charAt(0)=='-'&&isDigits(numeric.substring(1))||isDigits(numeric))){\n+try{\n+return createLong(numeric);\n+}catch (NumberFormatException nfe) {\n+}\n+\n+return createBigInteger(numeric);\n+}\n+// end of generated patch\n+/* start of original code\n                     if (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n@@ -461,6 +472,7 @@ public class NumberUtils {\n                         return createBigInteger(numeric);\n \n                     }\n+ end of original code*/\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 531,
    "bugId": 215,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -451,6 +451,3 @@\n                 case 'L' :\n-                    if (dec == null\n-                        && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                    if (exp == dec) {\n                         try {\n@@ -461,3 +458,3 @@\n                         return createBigInteger(numeric);\n-\n+                        \n                     }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 532,
    "bugId": 215,
    "name": "Patch_5_5",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex c0f06a4..cd862e8 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -451,7 +451,6 @@ public class NumberUtils {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 533,
    "bugId": 215,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex c0f06a4..8d8bb25 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -451,8 +451,7 @@ public class NumberUtils {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                        && isDigits(numeric.substring(1)) || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 534,
    "bugId": 215,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -451,6 +451,3 @@\n                 case 'L' :\n-                    if (dec == null\n-                        && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                    if (((dec == null) && (exp == null))) {\n                         try {\n@@ -461,3 +458,3 @@\n                         return createBigInteger(numeric);\n-\n+                        \n                     }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 535,
    "bugId": 215,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex c0f06a4..b988e49 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -450,8 +450,7 @@ public class NumberUtils {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n-                        && exp == null\n-                        && isDigits(numeric.substring(1))\n+                        && exp == null || isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 536,
    "bugId": 215,
    "name": "Patch_9_9",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex c0f06a4..ef99ac1 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -449,10 +449,10 @@ public class NumberUtils {\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n-                    if (dec == null\n+                    if (dec != numeric || (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 537,
    "bugId": 215,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 538,
    "bugId": 216,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n@@ -1,152 +1,152 @@\n /*\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n  * contributor license agreements.  See the NOTICE file distributed with\n  * this work for additional information regarding copyright ownership.\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n  * \n  *      http://www.apache.org/licenses/LICENSE-2.0\n  * \n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n package org.apache.commons.lang.time;\n \n import java.io.IOException;\n import java.io.ObjectInputStream;\n \n import java.text.DateFormat;\n import java.text.DateFormatSymbols;\n import java.text.FieldPosition;\n import java.text.Format;\n import java.text.ParsePosition;\n import java.text.SimpleDateFormat;\n import java.util.ArrayList;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.GregorianCalendar;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.TimeZone;\n \n import org.apache.commons.lang.Validate;\n \n /**\n  * <p>FastDateFormat is a fast and thread-safe version of\n  * {@link java.text.SimpleDateFormat}.</p>\n  * \n  * <p>This class can be used as a direct replacement to\n  * <code>SimpleDateFormat</code> in most formatting situations.\n  * This class is especially useful in multi-threaded server environments.\n  * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,\n  * nor will it be as Sun have closed the bug/RFE.\n  * </p>\n  *\n  * <p>Only formatting is supported, but all patterns are compatible with\n  * SimpleDateFormat (except time zones - see below).</p>\n  *\n  * <p>Java 1.4 introduced a new pattern letter, <code>'Z'</code>, to represent\n  * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).\n  * This pattern letter can be used here (on all JDK versions).</p>\n  *\n  * <p>In addition, the pattern <code>'ZZ'</code> has been made to represent\n  * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).\n  * This introduces a minor incompatibility with Java 1.4, but at a gain of\n  * useful functionality.</p>\n  *\n  * @author TeaTrove project\n  * @author Brian S O'Neill\n  * @author Sean Schofield\n  * @author Gary Gregory\n  * @author Stephen Colebourne\n  * @author Nikolay Metchev\n  * @since 2.0\n  * @version $Id$\n  */\n public class FastDateFormat extends Format {\n     // A lot of the speed in this class comes from caching, but some comes\n     // from the special int to StringBuffer conversion.\n     //\n     // The following produces a padded 2 digit number:\n     //   buffer.append((char)(value / 10 + '0'));\n     //   buffer.append((char)(value % 10 + '0'));\n     //\n     // Note that the fastest append to StringBuffer is a single char (used here).\n     // Note that Integer.toString() is not called, the conversion is simply\n     // taking the value and adding (mathematically) the ASCII value for '0'.\n     // So, don't change this code! It works and is very fast.\n     \n     /**\n      * Required for serialization support.\n      * \n      * @see java.io.Serializable\n      */\n     private static final long serialVersionUID = 1L;\n \n     /**\n      * FULL locale dependent date or time style.\n      */\n     public static final int FULL = DateFormat.FULL;\n     /**\n      * LONG locale dependent date or time style.\n      */\n     public static final int LONG = DateFormat.LONG;\n     /**\n      * MEDIUM locale dependent date or time style.\n      */\n     public static final int MEDIUM = DateFormat.MEDIUM;\n     /**\n      * SHORT locale dependent date or time style.\n      */\n     public static final int SHORT = DateFormat.SHORT;\n     \n     private static String cDefaultPattern;\n \n     private static Map cInstanceCache = new HashMap(7);\n     private static Map cDateInstanceCache = new HashMap(7);\n     private static Map cTimeInstanceCache = new HashMap(7);\n     private static Map cDateTimeInstanceCache = new HashMap(7);\n     private static Map cTimeZoneDisplayCache = new HashMap(7);\n \n     /**\n      * The pattern.\n      */\n     private final String mPattern;\n     /**\n      * The time zone.\n      */\n     private final TimeZone mTimeZone;\n     /**\n      * Whether the time zone overrides any on Calendars.\n      */\n     private final boolean mTimeZoneForced;\n     /**\n      * The locale.\n      */\n     private final Locale mLocale;\n     /**\n      * Whether the locale overrides the default.\n      */\n     private final boolean mLocaleForced;\n     /**\n      * The parsed rules.\n      */\n-    private Rule[] mRules;\n+    private transient Rule[] mRules;\n     /**\n      * The estimated maximum length.\n      */\n-    private int mMaxLengthEstimate;\n+    private transient int mMaxLengthEstimate;\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Gets a formatter instance using the default pattern in the\n      * default locale.</p>\n      * \n      * @return a date/time formatter\n      */\n@@ -1016,37 +1016,41 @@ public int hashCode() {\n     public String toString() {\n         return \"FastDateFormat[\" + mPattern + \"]\";\n     }\n \n     // Serializing\n     //-----------------------------------------------------------------------\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        init();\n+    }\n     \n     // Rules\n     //-----------------------------------------------------------------------\n     /**\n      * <p>Inner class defining a rule.</p>\n      */\n     private interface Rule {\n         /**\n          * Returns the estimated lentgh of the result.\n          * \n          * @return the estimated length\n          */\n         int estimateLength();\n         \n         /**\n          * Appends the value of the specified calendar to the output buffer based on the rule implementation.\n          * \n          * @param buffer the output buffer\n          * @param calendar calendar to be appended\n          */\n         void appendTo(StringBuffer buffer, Calendar calendar);\n     }\n \n     /**\n      * <p>Inner class defining a numeric rule.</p>\n      */\n     private interface NumberRule extends Rule {\n         /**\n          * Appends the specified value to the output buffer based on the rule implementation.\n          * \n          * @param buffer the output buffer\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 539,
    "bugId": 216,
    "name": "Patch_5_4",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/FastDateFormat.java b/src/java/org/apache/commons/lang/time/FastDateFormat.java\nindex 89d8073..f1ff58f 100644\n--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n@@ -137,7 +137,7 @@ public class FastDateFormat extends Format {\n     /**\n      * The parsed rules.\n      */\n-    private Rule[] mRules;\n+    private transient  Rule[] mRules;\n     /**\n      * The estimated maximum length.\n      */",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 540,
    "bugId": 217,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/enums/ValuedEnum.java\n+++ b/src/java/org/apache/commons/lang/enums/ValuedEnum.java\n@@ -180,6 +180,16 @@ public final int getValue() {\n      * @throws NullPointerException if other is <code>null</code>\n      */\n     public int compareTo(Object other) {\n+        if (other == this) {\n+            return 0;\n+        }\n+        if (other.getClass() != this.getClass()) {\n+            if (other.getClass().getName().equals(this.getClass().getName())) {\n+                return iValue - getValueInOtherClassLoader(other);\n+            }\n+            throw new ClassCastException(\n+                    \"Different enum class '\" + ClassUtils.getShortClassName(other.getClass()) + \"'\");\n+        }\n         return iValue - ((ValuedEnum) other).iValue;\n     }\n \n@@ -189,9 +199,20 @@ public int compareTo(Object other) {\n      * @param other  the object to determine the value for\n      * @return the value\n      */\n+    private int getValueInOtherClassLoader(Object other) {\n+        try {\n+            Method mth = other.getClass().getMethod(\"getValue\", null);\n+            Integer value = (Integer) mth.invoke(other, null);\n+            return value.intValue();\n+        } catch (NoSuchMethodException e) {\n             // ignore - should never happen\n+        } catch (IllegalAccessException e) {\n             // ignore - should never happen\n+        } catch (InvocationTargetException e) {\n             // ignore - should never happen\n+        }\n+        throw new IllegalStateException(\"This should not happen\");\n+    }\n \n     /**\n      * <p>Human readable description of this <code>Enum</code> item.</p>\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 541,
    "bugId": 218,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n@@ -115,7 +115,9 @@ public void stop() {\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n+        if(this.runningState == STATE_RUNNING) {\n             stopTime = System.currentTimeMillis();\n+        }\n         this.runningState = STATE_STOPPED;\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 542,
    "bugId": 218,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n@@ -117,3 +117,5 @@\n         }\n-            stopTime = System.currentTimeMillis();\n+            if (this.runningState == 1) {\n+                stopTime = System.currentTimeMillis();\n+            }\n         this.runningState = STATE_STOPPED;\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 543,
    "bugId": 218,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n@@ -117,3 +117,5 @@\n         }\n-            stopTime = System.currentTimeMillis();\n+            if (org.apache.commons.lang.time.StopWatch.this.stopTime < 10) {\n+                stopTime = System.currentTimeMillis();\n+            }\n         this.runningState = STATE_STOPPED;\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 544,
    "bugId": 218,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 545,
    "bugId": 219,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -881,7 +881,7 @@ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                str.getChars(0, width, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 546,
    "bugId": 219,
    "name": "Patch_20_20",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Lang_59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2019-06-26 01:33:35.351940696 -0400\n+++ /tmp/Arja_Defects4J_Lang_59/patches_gb3h/Patch_20/patched/org/apache/commons/lang/text/StrBuilder.java\t2019-06-26 01:37:59.995940097 -0400\n@@ -881,7 +881,8 @@\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                buffer = new char[CAPACITY];\n+\t\t\t\tstr.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 547,
    "bugId": 219,
    "name": "Patch_12_3",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 886d424..4c14509 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -881,7 +881,7 @@ public class StrBuilder implements Cloneable {\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                str.getChars(0, width, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 548,
    "bugId": 219,
    "name": "Patch_20_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 886d424..4c14509 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -881,7 +881,7 @@ public class StrBuilder implements Cloneable {\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                str.getChars(0, width, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 549,
    "bugId": 219,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 886d424..4c14509 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -881,7 +881,7 @@ public class StrBuilder implements Cloneable {\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                str.getChars(0, width, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 550,
    "bugId": 219,
    "name": "Patch_4_4",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 886d424..4c14509 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -881,7 +881,7 @@ public class StrBuilder implements Cloneable {\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                str.getChars(0, width, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 551,
    "bugId": 219,
    "name": "Patch_155_107",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Lang_59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2019-07-04 17:16:53.217441559 -0400\n+++ /tmp/RSRepair_Defects4J_Lang_59/patches_8pf9/Patch_107/patched/org/apache/commons/lang/text/StrBuilder.java\t2019-07-04 17:22:58.370820204 -0400\n@@ -881,7 +881,8 @@\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                ensureCapacity(size + 5);\n+\t\t\t\tstr.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 552,
    "bugId": 219,
    "name": "Patch_34_27",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Lang_59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2019-07-01 22:26:47.246192356 -0400\n+++ /tmp/GenProg_Defects4J_Lang_59/patches_pct9/Patch_27/patched/org/apache/commons/lang/text/StrBuilder.java\t2019-07-01 22:31:22.523401822 -0400\n@@ -881,7 +881,8 @@\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                buffer = new char[str.length() + CAPACITY];\n+\t\t\t\tstr.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 553,
    "bugId": 220,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/Entities.java\n+++ b/src/java/org/apache/commons/lang/Entities.java\n@@ -847,6 +847,9 @@ public String unescape(String str) {\n                             } else {\n                                 entityValue = Integer.parseInt(entityName.substring(1));\n                             }\n+                            if (entityValue > 0xFFFF) {\n+                                entityValue = -1;\n+                            }\n                         } catch (NumberFormatException ex) {\n                             entityValue = -1;\n                         }\n@@ -917,12 +920,17 @@ public void unescape(Writer writer, String string) throws IOException {\n                                     case 'X' :\n                                     case 'x' : {\n                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);\n+                                        break;\n                                     }\n                                     default : {\n                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);\n                                     }\n                                 }\n+                                if (entityValue > 0xFFFF) {\n+                                    entityValue = -1;\n+                                }\n                             } catch (NumberFormatException e) {\n+                                entityValue = -1;\n                             }\n                         }\n                     } else { //escaped value content is an entity name\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 554,
    "bugId": 221,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1670,7 +1670,7 @@ public String midString(int index, int length) {\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n-        for (int i = 0; i < thisBuf.length; i++) {\n+        for (int i = 0; i < this.size; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }\n@@ -1727,7 +1727,7 @@ public int indexOf(char ch, int startIndex) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        for (int i = startIndex; i < thisBuf.length; i++) {\n+        for (int i = startIndex; i < size; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n             }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 555,
    "bugId": 221,
    "name": "Patch_318_318",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex c7cbfb3e..35d82fac 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1670,11 +1670,20 @@ public class StrBuilder implements Cloneable {\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n+// start of generated patch\n+for(int i=0;i<size;i++){\n+if(thisBuf[i]==ch){\n+return true;\n+}\n+}\n+// end of generated patch\n+/* start of original code\n         for (int i = 0; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }\n         }\n+ end of original code*/\n         return false;\n     }\n \n@@ -1727,11 +1736,20 @@ public class StrBuilder implements Cloneable {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n+// start of generated patch\n+for(int i=startIndex;i<size;i++){\n+if(thisBuf[i]==ch){\n+return i;\n+}\n+}\n+// end of generated patch\n+/* start of original code\n         for (int i = startIndex; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n             }\n         }\n+ end of original code*/\n         return -1;\n     }\n ",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 556,
    "bugId": 222,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1773,7 +1773,7 @@ public int indexOf(String str, int startIndex) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+        int len = size - strLen + 1;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 557,
    "bugId": 223,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -303,25 +303,20 @@ public static String formatPeriod(long startMillis, long endMillis, String forma\n             days -= 1;\n         }\n         while (days < 0) {\n-            days += 31;\n+            end.add(Calendar.MONTH, -1);\n+            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n // Also it's contextual - if asked for no M in the format then I should probably \n // be doing no calculating here.\n             months -= 1;\n+            end.add(Calendar.MONTH, 1);\n         }\n         while (months < 0) {\n             months += 12;\n             years -= 1;\n         }\n-        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n-        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n-        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n-        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n-        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n-        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n-        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that \n         // aren't requested. This allows the user to ask for the \n@@ -429,18 +424,6 @@ static String format(Token[] tokens, int years, int months, int days, int hours,\n         }\n         return buffer.toString();\n     }\n-    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n-        end.add( field, -1 * difference );\n-        int endValue = end.get(field);\n-        int startValue = start.get(field);\n-        if (endValue < startValue) {\n-            int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n-            return newdiff;\n-        } else {\n-            return 0;\n-        }\n-    }\n \n     static final Object y = \"y\";\n     static final Object M = \"M\";\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 558,
    "bugId": 223,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -437,3 +437,5 @@\n             int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n+            if (false) {\n+                end.add( field, newdiff );\n+            }\n             return newdiff;\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 559,
    "bugId": 223,
    "name": "Patch_6_6",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Lang_63/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\t2019-06-26 02:31:42.539250457 -0400\n+++ /tmp/Arja_Defects4J_Lang_63/patches_xj9a/Patch_6/patched/org/apache/commons/lang/time/DurationFormatUtils.java\t2019-06-26 02:35:57.712083927 -0400\n@@ -435,7 +435,8 @@\n         int startValue = start.get(field);\n         if (endValue < startValue) {\n             int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n+            end = (Calendar) start.clone();\n+\t\t\tend.add( field, newdiff );\n             return newdiff;\n         } else {\n             return 0;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 560,
    "bugId": 223,
    "name": "Patch_294_57",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\nindex 127b927..5261db5 100644\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -319,7 +319,7 @@ public class DurationFormatUtils {\n         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n-        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n+        days -= reduceAndCorrect(end, end, Calendar.DAY_OF_MONTH, days);\n         months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 561,
    "bugId": 223,
    "name": "Patch_302_174",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\nindex 127b927..c2c4af5 100644\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -283,7 +283,8 @@ public class DurationFormatUtils {\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n-        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n+        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n+\tint years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n@@ -320,7 +321,7 @@ public class DurationFormatUtils {\n         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n-        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n+        \n         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 562,
    "bugId": 223,
    "name": "Patch_211_63",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\nindex 127b927..5261db5 100644\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -319,7 +319,7 @@ public class DurationFormatUtils {\n         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n-        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n+        days -= reduceAndCorrect(end, end, Calendar.DAY_OF_MONTH, days);\n         months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 563,
    "bugId": 223,
    "name": "Patch_627_240",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\nindex 127b927..c2c4af5 100644\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -283,7 +283,8 @@ public class DurationFormatUtils {\n         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n-        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n+        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n+\tint years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n \n         // each initial estimate is adjusted in case it is under 0\n         while (milliseconds < 0) {\n@@ -320,7 +321,7 @@ public class DurationFormatUtils {\n         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n-        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n+        \n         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 564,
    "bugId": 223,
    "name": "Patch_13_10",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Lang_63/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\t2019-07-04 18:22:04.869908918 -0400\n+++ /tmp/RSRepair_Defects4J_Lang_63/patches_faoi/Patch_10/patched/org/apache/commons/lang/time/DurationFormatUtils.java\t2019-07-04 18:26:47.789175451 -0400\n@@ -318,7 +318,6 @@\n         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n-        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n         months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n@@ -435,7 +434,6 @@\n         int startValue = start.get(field);\n         if (endValue < startValue) {\n             int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n             return newdiff;\n         } else {\n             return 0;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 565,
    "bugId": 223,
    "name": "Patch_1_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Lang_63/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\t2019-07-02 00:08:16.904882845 -0400\n+++ /tmp/GenProg_Defects4J_Lang_63/patches_tcf6/Patch_1/patched/org/apache/commons/lang/time/DurationFormatUtils.java\t2019-07-02 00:12:25.233237264 -0400\n@@ -320,7 +320,6 @@\n         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n-        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 566,
    "bugId": 223,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 567,
    "bugId": 224,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n@@ -621,6 +621,9 @@ private static void modify(Calendar val, int field, boolean round) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n+        if (field == Calendar.MILLISECOND) {\n+            return;\n+        }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n@@ -628,14 +631,39 @@ private static void modify(Calendar val, int field, boolean round) {\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n+        Date date = val.getTime();\n+        long time = date.getTime();\n+        boolean done = false;\n \n         // truncate milliseconds\n+        int millisecs = val.get(Calendar.MILLISECOND);\n+        if (!round || millisecs < 500) {\n+            time = time - millisecs;\n+            if (field == Calendar.SECOND) {\n+                done = true;\n+            }\n+        }\n \n         // truncate seconds\n+        int seconds = val.get(Calendar.SECOND);\n+        if (!done && (!round || seconds < 30)) {\n+            time = time - (seconds * 1000L);\n+            if (field == Calendar.MINUTE) {\n+                done = true;\n+            }\n+        }\n \n         // truncate minutes\n+        int minutes = val.get(Calendar.MINUTE);\n+        if (!done && (!round || minutes < 30)) {\n+            time = time - (minutes * 60000L);\n+        }\n \n         // reset time\n+        if (date.getTime() != time) {\n+            date.setTime(time);\n+            val.setTime(date);\n+        }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n@@ -706,7 +734,9 @@ private static void modify(Calendar val, int field, boolean round) {\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n+            if (offset != 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+            }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 568,
    "bugId": 225,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n@@ -265,7 +265,7 @@ private double innerCumulativeProbability(int x0, int x1, int dx) {\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 569,
    "bugId": 226,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\n@@ -303,6 +303,9 @@ private BigFraction(final double value, final double epsilon,\n             if ((p2 > overflow) || (q2 > overflow)) {\n                 // in maxDenominator mode, if the last fraction was very close to the actual value\n                 // q2 may overflow in the next iteration; in this case return the last one.\n+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n+                    break;\n+                }\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -212,6 +212,9 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 // in maxDenominator mode, if the last fraction was very close to the actual value\n                 // q2 may overflow in the next iteration; in this case return the last one.\n+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n+                    break;\n+                }\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 570,
    "bugId": 227,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -818,7 +818,10 @@ public static double linearCombination(final double[] a, final double[] b)\n             throw new DimensionMismatchException(len, b.length);\n         }\n \n+        if (len == 1) {\n             // Revert to scalar multiplication.\n+            return a[0] * b[0];\n+        }\n \n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 571,
    "bugId": 227,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\nindex 67b368d..3e4ead8 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.commons.math3.genetics;\n+package org.apache.commons.math3.genetics;import  org.apache.commons.math3.exception.OutOfRangeException;import  org.apache.commons.math3.exception.OutOfRangeException;import  org\n \n import java.util.Collections;\n import java.util.List;\n@@ -48,7 +48,7 @@ public class ElitisticListPopulation extends ListPopulation {\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n-        this.elitismRate = elitismRate;\n+if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);}if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);}         this.elitismRate = elitismRate;\n     }\n \n     /**\n@@ -62,7 +62,7 @@ public class ElitisticListPopulation extends ListPopulation {\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n-        this.elitismRate = elitismRate;\n+if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);}if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);}        this.elitismRate = \n     }\n \n     /**\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 572,
    "bugId": 228,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -302,7 +302,7 @@ public Complex reciprocal() {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return INF;\n         }\n \n         if (isInfinite) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 573,
    "bugId": 228,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/complex/Complex.java b/src/main/java/org/apache/commons/math3/complex/Complex.java\nindex 22b23f24e..cfe532bba 100644\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -301,9 +301,16 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n             return NaN;\n         }\n \n+// start of generated patch\n+if(real==0.0&&imaginary==0.0){\n+return INF;\n+}\n+// end of generated patch\n+/* start of original code\n         if (real == 0.0 && imaginary == 0.0) {\n             return NaN;\n         }\n+ end of original code*/\n \n         if (isInfinite) {\n             return ZERO;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 574,
    "bugId": 228,
    "name": "Patch_2_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math3/complex/Complex.java b/src/main/java/org/apache/commons/math3/complex/Complex.java\nindex 22b23f2..4524eed 100644\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -302,7 +302,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+if (this.equals(new Complex(0,0))){return INF;}            return NaN;\n         }\n \n         if (isInfinite) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 575,
    "bugId": 228,
    "name": "Patch_67_52",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_5/src/main/java/org/apache/commons/math3/complex/Complexjava\n+++ /tmp/jGenProg_Defects4J_Math_5/src/main/java/org/apache/commons/math3/complex/Complexjava\n@@ -302,23 +302,8 @@\n \t\t}\n \n \t\tif (((real) == 0.0) && ((imaginary) == 0.0)) {\n-\t\t\treturn org.apache.commons.math3.complex.Complex.NaN;\n-\t\t}\n \n-\t\tif (isInfinite) {\n-\t\t\treturn org.apache.commons.math3.complex.Complex.ZERO;\n-\t\t}\n \n-\t\tif ((org.apache.commons.math3.util.FastMath.abs(real)) < (org.apache.commons.math3.util.FastMath.abs(imaginary))) {\n-\t\t\tdouble q = (real) / (imaginary);\n-\t\t\tdouble scale = 1.0 / (((real) * q) + (imaginary));\n-\t\t\treturn createComplex((scale * q), (-scale));\n-\t\t}else {\n-\t\t\tdouble q = (imaginary) / (real);\n-\t\t\tdouble scale = 1.0 / (((imaginary) * q) + (real));\n-\t\t\treturn createComplex(scale, ((-scale) * q));\n-\t\t}\n-\t}\n \n \n \n@@ -335,21 +320,6 @@\n \n \n \n-\t@java.lang.Override\n-\tpublic boolean equals(java.lang.Object other) {\n-\t\tif ((this) == other) {\n-\t\t\treturn true;\n-\t\t}\n-\t\tif (other instanceof org.apache.commons.math3.complex.Complex) {\n-\t\t\torg.apache.commons.math3.complex.Complex c = ((org.apache.commons.math3.complex.Complex) (other));\n-\t\t\tif (c.isNaN) {\n-\t\t\t\treturn isNaN;\n-\t\t\t}else {\n-\t\t\t\treturn ((real) == (c.real)) && ((imaginary) == (c.imaginary));\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n \n \n \n@@ -358,32 +328,18 @@\n \n \n \n-\t@java.lang.Override\n-\tpublic int hashCode() {\n-\t\tif (isNaN) {\n-\t\t\treturn 7;\n-\t\t}\n-\t\treturn 37 * ((17 * (org.apache.commons.math3.util.MathUtils.hash(imaginary))) + \n-\t\t(org.apache.commons.math3.util.MathUtils.hash(real)));\n-\t}\n \n \n \n \n \n \n-\tpublic double getImaginary() {\n-\t\treturn imaginary;\n-\t}\n \n \n \n \n \n \n-\tpublic double getReal() {\n-\t\treturn real;\n-\t}\n \n \n \n@@ -392,9 +348,6 @@\n \n \n \n-\tpublic boolean isNaN() {\n-\t\treturn isNaN;\n-\t}\n \n \n \n@@ -405,9 +358,6 @@\n \n \n \n-\tpublic boolean isInfinite() {\n-\t\treturn isInfinite;\n-\t}\n \n \n \n@@ -433,18 +383,68 @@\n \n \n \n-\tpublic org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex factor) throws \n-\torg.apache.commons.math3.exception.NullArgumentException {\n-\t\torg.apache.commons.math3.util.MathUtils.checkNotNull(factor);\n-\t\tif ((isNaN) || (factor.isNaN)) {\n-\t\t\treturn org.apache.commons.math3.complex.Complex.NaN;\n-\t\t}\n-\t\tif ((((java.lang.Double.isInfinite(real)) || \n-\t\t(java.lang.Double.isInfinite(imaginary))) || \n-\t\t(java.lang.Double.isInfinite(factor.real))) || \n-\t\t(java.lang.Double.isInfinite(factor.imaginary))) {\n \n-\t\t\treturn org.apache.commons.math3.complex.Complex.INF;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\t\t\treturn org.apache.commons.math3.complex.Complex.INF;} \t\tif (isInfinite) { \t\t\treturn org.apache.commons.math3.complex.Complex.ZERO;} \t\tif ((org.apache.commons.math3.util.FastMath.abs(real)) < (org.apache.commons.math3.util.FastMath.abs(imaginary))) { \t\t\tdouble q = (real) / (imaginary); \t\t\tdouble scale = 1.0 / (((real) * q) + (imaginary)); \t\t\treturn createComplex((scale * q), (-scale));}else { \t\t\tdouble q = (imaginary) / (real); \t\t\tdouble scale = 1.0 / (((imaginary) * q) + (real)); \t\t\treturn createComplex(scale, ((-scale) * q));}} \t@java.lang.Override \tpublic boolean equals(java.lang.Object other) { \t\tif ((this) == other) { \t\t\treturn true;} \t\tif (other instanceof org.apache.commons.math3.complex.Complex) { \t\t\torg.apache.commons.math3.complex.Complex c = ((org.apache.commons.math3.complex.Complex) (other)); \t\t\tif (c.isNaN) { \t\t\t\treturn isNaN;}else { \t\t\t\treturn ((real) == (c.real)) && ((imaginary) == (c.imaginary));}} \t\treturn false;} \t@java.lang.Override \tpublic int hashCode() { \t\tif (isNaN) { \t\t\treturn 7;} \t\treturn 37 * ((17 * (org.apache.commons.math3.util.MathUtils.hash(imaginary))) + (org.apache.commons.math3.util.MathUtils.hash(real)));} \tpublic double getImaginary() { \t\treturn imaginary;} \tpublic double getReal() { \t\treturn real;} \tpublic boolean isNaN() { \t\treturn isNaN;} \tpublic boolean isInfinite() { \t\treturn isInfinite;} \tpublic org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex factor) throws org.apache.commons.math3.exception.NullArgumentException { \t\torg.apache.commons.math3.util.MathUtils.checkNotNull(factor); \t\tif ((isNaN) || (factor.isNaN)) { \t\t\treturn org.apache.commons.math3.complex.Complex.NaN;} \t\tif ((((java.lang.Double.isInfinite(real)) || (java.lang.Double.isInfinite(imaginary))) || (java.lang.Double.isInfinite(factor.real))) || (java.lang.Double.isInfinite(factor.imaginary))) { \t\t\treturn org.apache.commons.math3.complex.Complex.INF;\n \t\t}\n \t\treturn createComplex((((real) * (factor.real)) - ((imaginary) * (factor.imaginary))), \n \t\t(((real) * (factor.imaginary)) + ((imaginary) * (factor.real))));",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 576,
    "bugId": 228,
    "name": "Patch_2_2",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/complex/Complex.java b/src/main/java/org/apache/commons/math3/complex/Complex.java\nindex 22b23f2..ac8185b 100644\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -302,7 +302,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return INF;\n         }\n \n         if (isInfinite) {",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 577,
    "bugId": 228,
    "name": "Patch_510_172",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2019-06-23 06:54:01.923268947 -0400\n+++ /tmp/RSRepair_Defects4J_Math_5/patches_6lmm/Patch_473/patched/org/apache/commons/math3/complex/Complex.java\t2019-06-23 07:42:13.551534862 -0400\n@@ -302,7 +302,7 @@\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return INF;\n         }\n \n         if (isInfinite) {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 578,
    "bugId": 229,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n@@ -178,13 +178,13 @@ public T sample() {\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n+    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                     sampleSize);\n         }\n \n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+        final Object[] out = new Object[sampleSize];\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 579,
    "bugId": 229,
    "name": "Patch_1_1",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Math_8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistributionjava\n+++ /tmp/Cardumen_Defects4J_Math_8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistributionjava\n@@ -184,7 +184,7 @@\n \t\t\tsampleSize);\n \t\t}\n \n-\t\tfinal T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));\n+\t\tfinal T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(((singletons.size()) - 1)).getClass(), sampleSize)));\n \n \t\tfor (int i = 0; i < sampleSize; i++) {\n \t\t\tout[i] = sample();",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 580,
    "bugId": 229,
    "name": "Patch_78_78",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\nindex 5cb0e4382..d81653512 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n@@ -186,9 +186,16 @@ public class DiscreteDistribution<T> {\n \n         final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n \n+// start of generated patch\n+for(int i=sampleSize;i<sampleSize;i++){\n+out[i]=sample();\n+}\n+// end of generated patch\n+/* start of original code\n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n+ end of original code*/\n \n         return out;\n ",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 581,
    "bugId": 229,
    "name": "Patch_14_3",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\nindex 5cb0e43..55d4ced 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n@@ -184,7 +184,7 @@ public class DiscreteDistribution<T> {\n                     sampleSize);\n         }\n \n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(1).getClass(), sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 582,
    "bugId": 230,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n@@ -180,7 +180,7 @@ public double density(final double[] vals) throws DimensionMismatchException {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 583,
    "bugId": 230,
    "name": "Patch_2_2",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\nindex 1570681..795cd7e 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n@@ -180,7 +180,7 @@ public class MultivariateNormalDistribution\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+        return FastMath.pow(2 * FastMath.PI, -dim / 2d) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 584,
    "bugId": 231,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n@@ -48,7 +48,7 @@ protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n         this.checker = checker;\n \n         evaluations = new Incrementor(0, new MaxEvalCallback());\n-        iterations = new Incrementor(0, new MaxIterCallback());\n+        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n@@ -211,16 +211,15 @@ protected PointValuePair doOptimize() {\n         }\n \n         PointValuePair current = null;\n-        int iter = 0;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n \n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n-                if (checker.converged(iter, previous, current)) {\n+                if (checker.converged(getIterations(), previous, current)) {\n                     // We have found an optimum.\n                     return current;\n                 }\n@@ -274,7 +273,7 @@ protected PointValuePair doOptimize() {\n             steepestDescent = newSteepestDescent;\n \n             // Compute conjugate search direction.\n-            if (iter % n == 0 ||\n+            if (getIterations() % n == 0 ||\n                 beta < 0) {\n                 // Break conjugation: reset search direction.\n                 searchDirection = steepestDescent.clone();\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n@@ -385,6 +385,7 @@ protected PointValuePair doOptimize() {\n \n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n+            incrementIterationCount();\n \n             // Generate and evaluate lambda offspring\n             final RealMatrix arz = randn1(dimension, lambda);\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n@@ -188,9 +188,8 @@ protected PointValuePair doOptimize() {\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n-        int iter = 0;\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n \n             double fX = fVal;\n             double fX2 = 0;\n@@ -224,7 +223,7 @@ protected PointValuePair doOptimize() {\n             final PointValuePair current = new PointValuePair(x, fVal);\n             if (!stop) { // User-defined stopping criteria.\n                 if (checker != null) {\n-                    stop = checker.converged(iter, previous, current);\n+                    stop = checker.converged(getIterations(), previous, current);\n                 }\n             }\n             if (stop) {\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n@@ -155,7 +155,7 @@ public int compare(final PointValuePair o1,\n         int iteration = 0;\n         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            if (iteration > 0) {\n+            if (getIterations() > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.getSize(); i++) {\n                     PointValuePair prev = previous[i];\n@@ -172,7 +172,7 @@ public int compare(final PointValuePair o1,\n             previous = simplex.getPoints();\n             simplex.iterate(evalFunc, comparator);\n \n-\t\t\t++iteration;\n+            incrementIterationCount();\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n@@ -103,9 +103,8 @@ public PointVectorValuePair doOptimize() {\n \n         // iterate until convergence is reached\n         PointVectorValuePair current = null;\n-        int iter = 0;\n         for (boolean converged = false; !converged;) {\n-            ++iter;\n+            incrementIterationCount();\n \n             // evaluate the objective function and its jacobian\n             PointVectorValuePair previous = current;\n@@ -157,7 +156,7 @@ public PointVectorValuePair doOptimize() {\n \n             // Check convergence.\n             if (previous != null) {\n-                converged = checker.converged(iter, previous, current);\n+                converged = checker.converged(getIterations(), previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n@@ -319,10 +319,10 @@ protected PointVectorValuePair doOptimize() {\n         // Outer loop.\n         lmPar = 0;\n         boolean firstIteration = true;\n-        int iter = 0;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n+\n             final PointVectorValuePair previous = current;\n \n             // QR decomposition of the jacobian matrix\n@@ -486,7 +486,7 @@ protected PointVectorValuePair doOptimize() {\n                     // tests for convergence.\n                     if (checker != null) {\n                         // we use the vectorial convergence checker\n-                        if (checker.converged(iter, previous, current)) {\n+                        if (checker.converged(getIterations(), previous, current)) {\n                             setCost(currentCost);\n                             return current;\n                         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 585,
    "bugId": 232,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n@@ -1416,6 +1416,7 @@ public void atan2(final double[] y, final int yOffset,\n         }\n \n         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n+        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n \n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 586,
    "bugId": 233,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -343,8 +343,10 @@ public int compare(EventState es0, EventState es1) {\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+                for (final EventState state : eventsStates) {\n+                    state.stepAccepted(eventT, eventY);\n+                    isLastStep = isLastStep || state.stop();\n+                }\n \n                 // handle the first part of the step, up to the event\n                 for (final StepHandler handler : stepHandlers) {\n@@ -354,22 +356,19 @@ public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n-                boolean needReset = currentEvent.reset(eventT, eventY);\n+                boolean needReset = false;\n+                for (final EventState state : eventsStates) {\n+                    needReset =  needReset || state.reset(eventT, eventY);\n+                }\n                 if (needReset) {\n                     // some event handler has triggered changes that\n                     // invalidate the derivatives, we need to recompute them\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 587,
    "bugId": 234,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.commons.math3.random;\n \n+import java.io.Serializable;\n \n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.util.FastMath;\n@@ -26,8 +27,10 @@\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+    implements RandomGenerator,\n+               Serializable {\n     /** Serializable version identifier */\n+    private static final long serialVersionUID = 20130104L;\n     /** Next gaussian. */\n     private double nextGaussian;\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 588,
    "bugId": 235,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n@@ -84,7 +84,8 @@ public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+        final Line reverted = new Line(this);\n+        reverted.direction = reverted.direction.negate();\n         return reverted;\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 589,
    "bugId": 236,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n@@ -111,6 +111,9 @@ public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin\n \n         // compute the intersection on infinite line\n         Vector3D v1D = line.intersection(subLine.line);\n+        if (v1D == null) {\n+            return null;\n+        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n@@ -115,6 +115,9 @@ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin\n \n         // compute the intersection on infinite line\n         Vector2D v2D = line1.intersection(line2);\n+        if (v2D == null) {\n+            return null;\n+        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 590,
    "bugId": 236,
    "name": "Patch_2_2",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\nindex a146cb6..ee8f12b 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n@@ -112,7 +112,7 @@ public class SubLine {\n         // compute the intersection on infinite line\n         Vector3D v1D = line.intersection(subLine.line);\n \n-        // check location of point with respect to first sub-line\n+if (v1D == null){return null;}        // check location of point with respect to first sub-line\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n \n         // check location of point with respect to second sub-line\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\nindex a9d621a..0b1b07e 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n@@ -116,7 +116,7 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {\n         // compute the intersection on infinite line\n         Vector2D v2D = line1.intersection(line2);\n \n-        // check location of point with respect to first sub-line\n+if (v2D == null){return null;}        // check location of point with respect to first sub-line\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n \n         // check location of point with respect to second sub-line",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 591,
    "bugId": 236,
    "name": "Patch_24_6",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\nindex a146cb6..ea79097 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n@@ -113,7 +113,10 @@ public class SubLine {\n         Vector3D v1D = line.intersection(subLine.line);\n \n         // check location of point with respect to first sub-line\n-        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n+        if (v1D == null) {\n+    return null;\n+}\n+Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n \n         // check location of point with respect to second sub-line\n         Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 592,
    "bugId": 236,
    "name": "Patch_40_11",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\nindex a9d621a..c7ebae9 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n@@ -117,7 +117,10 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {\n         Vector2D v2D = line1.intersection(line2);\n \n         // check location of point with respect to first sub-line\n-        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n+        if (v2D == null) {\n+    return null;\n+}\n+Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n \n         // check location of point with respect to second sub-line\n         Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 593,
    "bugId": 236,
    "name": "Patch_24_6",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\nindex a146cb6..ea79097 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n@@ -113,7 +113,10 @@ public class SubLine {\n         Vector3D v1D = line.intersection(subLine.line);\n \n         // check location of point with respect to first sub-line\n-        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n+        if (v1D == null) {\n+    return null;\n+}\n+Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n \n         // check location of point with respect to second sub-line\n         Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 594,
    "bugId": 236,
    "name": "Patch_41_9",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\nindex a9d621a..c7ebae9 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n@@ -117,7 +117,10 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {\n         Vector2D v2D = line1.intersection(line2);\n \n         // check location of point with respect to first sub-line\n-        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n+        if (v2D == null) {\n+    return null;\n+}\n+Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n \n         // check location of point with respect to second sub-line\n         Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 595,
    "bugId": 236,
    "name": "Patch_2_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\nindex a146cb6..097f07f 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n@@ -113,7 +113,10 @@ public class SubLine {\n         Vector3D v1D = line.intersection(subLine.line);\n \n         // check location of point with respect to first sub-line\n-        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n+        if (remainingRegion == null) {\n+    throw new IllegalArgumentException(\"Null 'remainingRegion' argument.\");\n+}\n+Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n \n         // check location of point with respect to second sub-line\n         Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 596,
    "bugId": 236,
    "name": "Patch_4_2",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\nindex a9d621a..ca71016 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n@@ -117,7 +117,10 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {\n         Vector2D v2D = line1.intersection(line2);\n \n         // check location of point with respect to first sub-line\n-        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n+        if (line1 == null) {\n+    throw new IllegalArgumentException(\"Null 'line1' argument.\");\n+}\n+Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n \n         // check location of point with respect to second sub-line\n         Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 597,
    "bugId": 236,
    "name": "Patch_28_12",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\nindex a9d621a..80638c6 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n@@ -117,7 +117,10 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {\n         Vector2D v2D = line1.intersection(line2);\n \n         // check location of point with respect to first sub-line\n-        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n+        if (v2D == null) {\n+\t    return null;\n+\t}\n+Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n \n         // check location of point with respect to second sub-line\n         Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 598,
    "bugId": 236,
    "name": "Patch_16_6",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\nindex a146cb6..89c9822 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n@@ -113,7 +113,10 @@ public class SubLine {\n         Vector3D v1D = line.intersection(subLine.line);\n \n         // check location of point with respect to first sub-line\n-        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n+        if (v1D == null) {\n+\t    return null;\n+\t}\n+Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n \n         // check location of point with respect to second sub-line\n         Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 599,
    "bugId": 237,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -559,7 +559,16 @@ protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n+        if (m instanceof DiagonalMatrix) {\n+            final int dim = m.getRowDimension();\n+            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n+            for (int i = 0; i < dim; i++) {\n+               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n+            }\n+            return sqrtM;\n+        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n+        }\n     }\n }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 600,
    "bugId": 238,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n@@ -40,10 +40,7 @@\n      */\n     public Weight(double[] weight) {\n         final int dim = weight.length;\n-        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n-        for (int i = 0; i < dim; i++) {\n-            weightMatrix.setEntry(i, i, weight[i]);\n-        }\n+        weightMatrix = new DiagonalMatrix(weight);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n@@ -264,7 +264,16 @@ private void parseOptimizationData(OptimizationData... optData) {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n+        if (m instanceof DiagonalMatrix) {\n+            final int dim = m.getRowDimension();\n+            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n+            for (int i = 0; i < dim; i++) {\n+                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n+            }\n+            return sqrtM;\n+        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n+        }\n     }\n }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 601,
    "bugId": 239,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -310,6 +310,7 @@\n     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n     private static final double TWO_POWER_52 = 4503599627370496.0;\n     /** 2^53 - double numbers this large must be even. */\n+    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;\n \n     /** Constant: {@value}. */\n     private static final double F_1_3 = 1d / 3d;\n@@ -1538,7 +1539,7 @@ public static double pow(double x, double y) {\n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n+            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n                 return pow(-x, y);\n             }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 602,
    "bugId": 239,
    "name": "Patch_159_111",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/util/FastMath.java b/src/main/java/org/apache/commons/math3/util/FastMath.java\nindex d571325..ae461ce 100644\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -1538,7 +1538,7 @@ public class FastMath {\n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n+            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y < 8e298 && y > -8e298)) {\n                 return pow(-x, y);\n             }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 603,
    "bugId": 239,
    "name": "Patch_14_14",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/util/FastMath.java b/src/main/java/org/apache/commons/math3/util/FastMath.java\nindex d571325..ae461ce 100644\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -1538,7 +1538,7 @@ public class FastMath {\n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n+            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y < 8e298 && y > -8e298)) {\n                 return pow(-x, y);\n             }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 604,
    "bugId": 240,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1600,7 +1600,11 @@ public Dfp multiply(final Dfp x) {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n+        if (x >= 0 && x < RADIX) {\n             return multiplyFast(x);\n+        } else {\n+            return multiply(newInstance(x));\n+        }\n     }\n \n     /** Multiply this by a single digit 0&lt;=x&lt;radix.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 605,
    "bugId": 241,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n@@ -272,7 +272,7 @@ public double getSupportUpperBound() {\n \n     /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n-        return true;\n+        return false;\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n@@ -181,7 +181,7 @@ public boolean isSupportLowerBoundInclusive() {\n \n     /** {@inheritDoc} */\n     public boolean isSupportUpperBoundInclusive() {\n-        return false;\n+        return true;\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 606,
    "bugId": 241,
    "name": "Patch_27_22",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_22/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\t2019-08-03 19:45:19.554803416 -0400\n+++ /tmp/Arja_Defects4J_Math_22/patches_fvu1/Patch_22/patched/org/apache/commons/math3/distribution/FDistribution.java\t2019-08-03 21:11:33.382696340 -0400\n@@ -272,7 +272,7 @@\n \n     /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n-        return true;\n+        return false;\n     }\n \n     /** {@inheritDoc} */\n\n\n--- /tmp/Arja_Defects4J_Math_22/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\t2019-08-03 19:45:19.554803416 -0400\n+++ /tmp/Arja_Defects4J_Math_22/patches_fvu1/Patch_22/patched/org/apache/commons/math3/distribution/UniformRealDistribution.java\t2019-08-03 21:11:33.418696358 -0400\n@@ -181,7 +181,7 @@\n \n     /** {@inheritDoc} */\n     public boolean isSupportUpperBoundInclusive() {\n-        return false;\n+        return true;\n     }\n \n     /**\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 607,
    "bugId": 241,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\nindex 8b0993c..e301e2e 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n@@ -272,7 +272,7 @@ public class FDistribution extends AbstractRealDistribution {\n \n     /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n-        return true;\n+        return false;\n     }\n \n     /** {@inheritDoc} */",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 608,
    "bugId": 241,
    "name": "Patch_2_2",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\nindex 5d32f6e..0d279de 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n@@ -181,7 +181,7 @@ public class UniformRealDistribution extends AbstractRealDistribution {\n \n     /** {@inheritDoc} */\n     public boolean isSupportUpperBoundInclusive() {\n-        return false;\n+        return true;\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 609,
    "bugId": 242,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -79,6 +79,7 @@\n  */\n public class FastMath {\n     /** StrictMath.log(Double.MAX_VALUE): {@value} */\n+    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);\n \n     /** Archimede's constant PI, ratio of circle circumference to diameter. */\n     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;\n@@ -391,12 +392,21 @@ public static double cosh(double x) {\n       // exp(-z) can be ignored in comparison with exp(z)\n \n       if (x > 20) {\n+          if (x >= LOG_MAX_VALUE) {\n               // Avoid overflow (MATH-905).\n+              final double t = exp(0.5 * x);\n+              return (0.5 * t) * t;\n+          } else {\n               return 0.5 * exp(x);\n           }\n-      if (x < -20) {\n+      } else if (x < -20) {\n+          if (x <= -LOG_MAX_VALUE) {\n               // Avoid overflow (MATH-905).\n+              final double t = exp(-0.5 * x);\n+              return (0.5 * t) * t;\n+          } else {\n               return 0.5 * exp(-x);\n+          }\n       }\n \n       final double hiPrec[] = new double[2];\n@@ -452,12 +462,21 @@ public static double sinh(double x) {\n       // exp(-z) can be ignored in comparison with exp(z)\n \n       if (x > 20) {\n+          if (x >= LOG_MAX_VALUE) {\n               // Avoid overflow (MATH-905).\n+              final double t = exp(0.5 * x);\n+              return (0.5 * t) * t;\n+          } else {\n               return 0.5 * exp(x);\n           }\n-      if (x < -20) {\n+      } else if (x < -20) {\n+          if (x <= -LOG_MAX_VALUE) {\n               // Avoid overflow (MATH-905).\n+              final double t = exp(-0.5 * x);\n+              return (-0.5 * t) * t;\n+          } else {\n               return -0.5 * exp(-x);\n+          }\n       }\n \n       if (x == 0) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 610,
    "bugId": 243,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -929,7 +929,7 @@ public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = (x[i] - boundaries[0][i]) / diff;\n+                res[i] = x[i] / diff;\n             }\n             return res;\n         }\n@@ -955,7 +955,7 @@ public FitnessFunction() {\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = diff * x[i] + boundaries[0][i];\n+                res[i] = diff * x[i];\n             }\n             return res;\n         }\n@@ -987,12 +987,14 @@ public boolean isFeasible(final double[] x) {\n                 return true;\n             }\n \n+            final double[] bLoEnc = encode(boundaries[0]);\n+            final double[] bHiEnc = encode(boundaries[1]);\n \n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < 0) {\n+                if (x[i] < bLoEnc[i]) {\n                     return false;\n                 }\n-                if (x[i] > 1.0) {\n+                if (x[i] > bHiEnc[i]) {\n                     return false;\n                 }\n             }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 611,
    "bugId": 244,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -918,7 +918,8 @@ public FitnessFunction() {\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+            return boundaries != null && isRepairMode ?\n+                decode(repair(x)) :\n                 decode(x);\n         }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 612,
    "bugId": 245,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -537,6 +537,19 @@ private void checkParameters() {\n                 boundaries[1] = uB;\n \n                 // Abort early if the normalization will overflow (cf. \"encode\" method).\n+                for (int i = 0; i < lB.length; i++) {\n+                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n+                        final double max = Double.MAX_VALUE + boundaries[0][i];\n+                        final NumberIsTooLargeException e\n+                            = new NumberIsTooLargeException(boundaries[1][i],\n+                                                            max,\n+                                                            true);\n+                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n+                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n+\n+                        throw e;\n+                    }\n+                }\n             }\n         } else {\n             // Convert API to internal handling of boundaries.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 613,
    "bugId": 246,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -148,6 +148,7 @@ protected UnivariatePointValuePair doOptimize() {\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n         // Best point encountered so far (which is the initial guess).\n+        UnivariatePointValuePair best = current;\n \n         int iter = 0;\n         while (true) {\n@@ -231,10 +232,15 @@ protected UnivariatePointValuePair doOptimize() {\n                 // User-defined convergence checker.\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+                best = best(best,\n+                            best(current,\n+                                 previous,\n+                                 isMinim),\n+                            isMinim);\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return best(current, previous, isMinim);\n+                        return best;\n                     }\n                 }\n \n@@ -271,9 +277,10 @@ protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return\n+                return best(best,\n                             best(current,\n                                  previous,\n+                                 isMinim),\n                             isMinim);\n             }\n             ++iter;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 614,
    "bugId": 247,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -66,7 +66,6 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n-        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -76,21 +75,24 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            swap[r] = r;\n+            int swapR = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isi = index[swap[i]];\n-                if (c[ii][ii] > c[isi][isi]) {\n-                    swap[r] = i;\n+                int isr = index[swapR];\n+                if (c[ii][ii] > c[isr][isr]) {\n+                    swapR = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swap[r] != r) {\n-                int tmp = index[r];\n-                index[r] = index[swap[r]];\n-                index[swap[r]] = tmp;\n+            if (swapR != r) {\n+                final int tmpIndex    = index[r];\n+                index[r]              = index[swapR];\n+                index[swapR]          = tmpIndex;\n+                final double[] tmpRow = b[r];\n+                b[r]                  = b[swapR];\n+                b[swapR]              = tmpRow;\n             }\n \n             // check diagonal element\n@@ -121,11 +123,12 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n+                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= e * e;\n+                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 615,
    "bugId": 248,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -227,7 +227,7 @@ protected UnivariatePointValuePair doOptimize() {\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return current;\n+                        return best(current, previous, isMinim);\n                     }\n                 }\n \n@@ -264,7 +264,7 @@ protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return current;\n+                return best(current, previous, isMinim);\n             }\n             ++iter;\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 616,
    "bugId": 249,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n@@ -170,7 +170,7 @@ private double calculateAsymptoticPValue(final double Umin,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+        final double n1n2prod = n1 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 617,
    "bugId": 249,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\nindex ce694ce..a161737 100644\n--- a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n@@ -170,7 +170,7 @@ public class MannWhitneyUTest {\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+        final double n1n2prod = n1 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 618,
    "bugId": 250,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n@@ -320,8 +320,11 @@ private void guessAOmega() {\n                 }\n                 a = 0.5 * (yMax - yMin);\n             } else {\n+                if (c2 == 0) {\n                     // In some ill-conditioned cases (cf. MATH-844), the guesser\n                     // procedure cannot produce sensible results.\n+                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n+                }\n \n                 a = FastMath.sqrt(c1 / c2);\n                 omega = FastMath.sqrt(c2 / c3);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 619,
    "bugId": 250,
    "name": "Patch_2_2",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\nindex 1da2c45..afcb19b 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n@@ -322,7 +322,7 @@ public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> {\n             } else {\n                     // In some ill-conditioned cases (cf. MATH-844), the guesser\n                     // procedure cannot produce sensible results.\n-\n+if (c2==0.0){throw new MathIllegalStateException();}\n                 a = FastMath.sqrt(c1 / c2);\n                 omega = FastMath.sqrt(c2 / c3);\n             }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 620,
    "bugId": 251,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -178,7 +178,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n-        if (a0 > overflow) {\n+        if (FastMath.abs(a0) > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }\n \n@@ -206,7 +206,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n-            if ((p2 > overflow) || (q2 > overflow)) {\n+            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 621,
    "bugId": 252,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -594,7 +594,7 @@ public Fraction divide(final int i) {\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+        return 100 * doubleValue();\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 622,
    "bugId": 253,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n@@ -346,10 +346,9 @@ public OpenMapRealVector ebeDivide(RealVector v) {\n          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n          * this[i] / v[i] = NaN, and not 0d.\n          */\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n+        final int n = getDimension();\n+        for (int i = 0; i < n; i++) {\n+            res.setEntry(i, this.getEntry(i) / v.getEntry(i));\n         }\n         return res;\n     }\n@@ -371,6 +370,18 @@ public OpenMapRealVector ebeMultiply(RealVector v) {\n          *\n          * These special cases are handled below.\n          */\n+        if (v.isNaN() || v.isInfinite()) {\n+            final int n = getDimension();\n+            for (int i = 0; i < n; i++) {\n+                final double y = v.getEntry(i);\n+                if (Double.isNaN(y)) {\n+                    res.setEntry(i, Double.NaN);\n+                } else if (Double.isInfinite(y)) {\n+                    final double x = this.getEntry(i);\n+                    res.setEntry(i, x * y);\n+                }\n+            }\n+        }\n         return res;\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 623,
    "bugId": 254,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -116,6 +116,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n+            if (tableau.getNumArtificialVariables() > 0) {\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n@@ -125,6 +126,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                         }\n                     }\n                 }\n+            }\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n@@ -135,6 +137,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n             // Additional heuristic: if we did not get a solution after half of maxIterations\n             //                       revert to the simple case of just returning the top-most row\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n+            if (getIterations() < getMaxIterations() / 2) {\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {\n@@ -149,6 +152,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                     }\n                 }\n                 return minRow;\n+            }\n         }\n         return minRatioPositions.get(0);\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 624,
    "bugId": 254,
    "name": "Patch_7_5",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n+++ /tmp/Cardumen_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n@@ -117,7 +117,7 @@\n \n \n \t\t\t\tfor (java.lang.Integer row : minRatioPositions) {\n-\t\t\t\t\tfor (int i = 0; i < (tableau.getNumArtificialVariables()); i++) {\n+\t\t\t\t\tfor (int i = 0; i < (org.apache.commons.math3.util.Precision.compareTo(epsilon, 0.0, maxUlps)); i++) {\n \t\t\t\t\t\tint column = i + (tableau.getArtificialVariableOffset());\n \t\t\t\t\t\tfinal double entry = tableau.getEntry(row, column);\n \t\t\t\t\t\tif ((org.apache.commons.math3.util.Precision.equals(entry, 1.0, maxUlps)) && (row.equals(tableau.getBasicRow(column)))) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 625,
    "bugId": 254,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -150,3 +150,5 @@\n                 }\n-                return minRow;\n+                if (false) {\n+                    return minRow;\n+                }\n         }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 626,
    "bugId": 254,
    "name": "Patch_2_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-08-03 21:11:42.146700824 -0400\n+++ /tmp/Arja_Defects4J_Math_28/patches_4x0w/Patch_1/patched/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-08-03 22:36:22.989297069 -0400\n@@ -121,7 +121,6 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n                         }\n                     }\n                 }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 627,
    "bugId": 254,
    "name": "Patch_29",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\nindex a84438d..c6980ef 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -135,20 +135,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n             // Additional heuristic: if we did not get a solution after half of maxIterations\n             //                       revert to the simple case of just returning the top-most row\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n-                Integer minRow = null;\n-                int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n-                    int i = tableau.getNumObjectiveFunctions();\n-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n-                    }\n-                }\n-                return minRow;\n+                \n         }\n         return minRatioPositions.get(0);\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 628,
    "bugId": 254,
    "name": "Patch_1_1",
    "tool": "jMutRepair",
    "diff": "--- /tmp/jMutRepair_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n+++ /tmp/jMutRepair_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n@@ -120,7 +120,7 @@\n \t\t\t\t\tfor (int i = 0; i < (tableau.getNumArtificialVariables()); i++) {\n \t\t\t\t\t\tint column = i + (tableau.getArtificialVariableOffset());\n \t\t\t\t\t\tfinal double entry = tableau.getEntry(row, column);\n-\t\t\t\t\t\tif ((org.apache.commons.math3.util.Precision.equals(entry, 1.0, maxUlps)) && (row.equals(tableau.getBasicRow(column)))) {\n+\t\t\t\t\t\tif ((!(org.apache.commons.math3.util.Precision.equals(entry, 1.0, this.maxUlps))) && (row.equals(tableau.getBasicRow(column)))) {\n \t\t\t\t\t\t\treturn row;\n \t\t\t\t\t\t}\n \t\t\t\t\t}",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 629,
    "bugId": 254,
    "name": "Patch_1_1",
    "tool": "jKali",
    "diff": "--- /tmp/jKali_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n+++ /tmp/jKali_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n@@ -116,15 +116,15 @@\n \n \n \n-\t\t\t\tfor (java.lang.Integer row : minRatioPositions) {\n-\t\t\t\t\tfor (int i = 0; i < (tableau.getNumArtificialVariables()); i++) {\n-\t\t\t\t\t\tint column = i + (tableau.getArtificialVariableOffset());\n-\t\t\t\t\t\tfinal double entry = tableau.getEntry(row, column);\n-\t\t\t\t\t\tif ((org.apache.commons.math3.util.Precision.equals(entry, 1.0, maxUlps)) && (row.equals(tableau.getBasicRow(column)))) {\n-\t\t\t\t\t\t\treturn row;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\n+\n+\n+\n+\n+\n+\n+\n+",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 630,
    "bugId": 254,
    "name": "Patch_3_2",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n+++ /tmp/jGenProg_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n@@ -116,15 +116,15 @@\n \n \n \n-\t\t\t\tfor (java.lang.Integer row : minRatioPositions) {\n-\t\t\t\t\tfor (int i = 0; i < (tableau.getNumArtificialVariables()); i++) {\n-\t\t\t\t\t\tint column = i + (tableau.getArtificialVariableOffset());\n-\t\t\t\t\t\tfinal double entry = tableau.getEntry(row, column);\n-\t\t\t\t\t\tif ((org.apache.commons.math3.util.Precision.equals(entry, 1.0, maxUlps)) && (row.equals(tableau.getBasicRow(column)))) {\n-\t\t\t\t\t\t\treturn row;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\n+\n+\n+\n+\n+\n+\n+\n+\n ",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 631,
    "bugId": 254,
    "name": "Patch_8_6",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\nindex a84438d..6153db1 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -116,15 +116,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n+                \n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 632,
    "bugId": 254,
    "name": "Patch_4_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-08-04 06:41:02.940154724 -0400\n+++ /tmp/RSRepair_Defects4J_Math_28/patches_uebs/Patch_1/patched/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-08-04 08:09:44.130873449 -0400\n@@ -117,13 +117,6 @@\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n                 }\n \n             // 2. apply Bland's rule to prevent cycling:\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 633,
    "bugId": 254,
    "name": "Patch_5_2",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-08-03 20:40:40.765737975 -0400\n+++ /tmp/GenProg_Defects4J_Math_28/patches_0ef5/Patch_2/patched/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-08-03 22:03:55.724302163 -0400\n@@ -137,18 +137,7 @@\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n-                    int i = tableau.getNumObjectiveFunctions();\n-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n-                    }\n-                }\n-                return minRow;\n+                Integer minPos = null;\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 634,
    "bugId": 254,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 635,
    "bugId": 255,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n+++ b/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n@@ -131,8 +131,6 @@ public double evaluate(double x, double epsilon, int maxIterations) {\n \n         int n = 1;\n         double dPrev = 0.0;\n-        double p0 = 1.0;\n-        double q1 = 1.0;\n         double cPrev = hPrev;\n         double hN = hPrev;\n \n@@ -140,34 +138,18 @@ public double evaluate(double x, double epsilon, int maxIterations) {\n             final double a = getA(n, x);\n             final double b = getB(n, x);\n \n-            double cN = a * hPrev + b * p0;\n-            double q2 = a * q1 + b * dPrev;\n-            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n-                double scaleFactor = 1d;\n-                double lastScaleFactor = 1d;\n-                final int maxPower = 5;\n-                final double scale = FastMath.max(a,b);\n-                if (scale <= 0) {  // Can't scale\n-                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n-                }\n-                for (int i = 0; i < maxPower; i++) {\n-                    lastScaleFactor = scaleFactor;\n-                    scaleFactor *= scale;\n-                    if (a != 0.0 && a > b) {\n-                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n-                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n-                    } else if (b != 0) {\n-                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n-                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n-                    }\n-                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n-                        break;\n-                    }\n-                }\n+            double dN = a + b * dPrev;\n+            if (Precision.equals(dN, 0.0, small)) {\n+                dN = small;\n+            }\n+            double cN = a + b / cPrev;\n+            if (Precision.equals(cN, 0.0, small)) {\n+                cN = small;\n             }\n \n-            final double deltaN = cN / q2 / cPrev;\n-            hN = cPrev * deltaN;\n+            dN = 1 / dN;\n+            final double deltaN = cN * dN;\n+            hN = hPrev * deltaN;\n \n             if (Double.isInfinite(hN)) {\n                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n@@ -182,11 +164,9 @@ public double evaluate(double x, double epsilon, int maxIterations) {\n                 break;\n             }\n \n-            dPrev = q1;\n-            cPrev = cN / q2;\n-            p0 = hPrev;\n-            hPrev = cN;\n-            q1 = q2;\n+            dPrev = dN;\n+            cPrev = cN;\n+            hPrev = hN;\n             n++;\n         }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 636,
    "bugId": 256,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -133,7 +133,7 @@ protected void computeGeometricalProperties() {\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 637,
    "bugId": 256,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -135,3 +135,3 @@\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (false) {\n                 // the instance covers the whole space\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 638,
    "bugId": 256,
    "name": "Patch_2_2",
    "tool": "jKali",
    "diff": "--- /tmp/jKali_Defects4J_Math_32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSetjava\n+++ /tmp/jKali_Defects4J_Math_32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSetjava\n@@ -133,7 +133,7 @@\n \n \t\tif ((v.length) == 0) {\n \t\t\tfinal org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D> tree = getTree(false);\n-\t\t\tif (((java.lang.Boolean) (tree.getAttribute()))) {\n+\t\t\tif (false) {\n \n \t\t\t\tsetSize(java.lang.Double.POSITIVE_INFINITY);\n \t\t\t\tsetBarycenter(org.apache.commons.math3.geometry.euclidean.twod.Vector2D.NaN);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 639,
    "bugId": 256,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 640,
    "bugId": 257,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n@@ -48,7 +48,7 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n-        this.elitismRate = elitismRate;\n+        setElitismRate(elitismRate);\n     }\n \n     /**\n@@ -62,7 +62,7 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n-        this.elitismRate = elitismRate;\n+        setElitismRate(elitismRate);\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 641,
    "bugId": 257,
    "name": "Patch_19_19",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\nindex 67b368deb..0ec5f37c2 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n@@ -47,8 +47,17 @@ public class ElitisticListPopulation extends ListPopulation {\n     public ElitisticListPopulation(final List<Chromosome> chromosomes,\n                                    final int populationLimit,\n                                    final double elitismRate) {\n+// start of generated patch\n+super(chromosomes,populationLimit);\n+if(elitismRate<0||elitismRate>1){\n+throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE,elitismRate,0,1);\n+}\n+this.elitismRate=elitismRate;\n+// end of generated patch\n+/* start of original code\n         super(chromosomes, populationLimit);\n         this.elitismRate = elitismRate;\n+ end of original code*/\n     }\n \n     /**\n@@ -61,8 +70,17 @@ public class ElitisticListPopulation extends ListPopulation {\n      * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n+// start of generated patch\n+super(populationLimit);\n+if(elitismRate<0||elitismRate>1){\n+throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE,elitismRate,0,1);\n+}\n+this.elitismRate=elitismRate;\n+// end of generated patch\n+/* start of original code\n         super(populationLimit);\n         this.elitismRate = elitismRate;\n+ end of original code*/\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 642,
    "bugId": 257,
    "name": "Patch_8_8",
    "tool": "ACS",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\nindex 67b368deb..ece2fe730 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n@@ -49,6 +49,8 @@ public class ElitisticListPopulation extends ListPopulation {\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n         this.elitismRate = elitismRate;\n+      if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);}\n+      if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);}\n     }\n \n     /**\n@@ -63,6 +65,8 @@ public class ElitisticListPopulation extends ListPopulation {\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n         this.elitismRate = elitismRate;\n+      if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);}\n+      if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);}\n     }\n \n     /**\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 643,
    "bugId": 257,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\nindex 67b368d..6a840e4 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n@@ -48,7 +48,7 @@ public class ElitisticListPopulation extends ListPopulation {\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n-        this.elitismRate = elitismRate;\n+        setElitismRate(elitismRate);\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 644,
    "bugId": 257,
    "name": "Patch_2_2",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\nindex 67b368d..830579e 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n@@ -62,7 +62,7 @@ public class ElitisticListPopulation extends ListPopulation {\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n-        this.elitismRate = elitismRate;\n+        setElitismRate(elitismRate);\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 645,
    "bugId": 258,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ protected void dropPhase1Objective() {\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 646,
    "bugId": 258,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\nindex 9a6993a55..fa0cfc825 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n@@ -335,9 +335,16 @@ class SimplexTableau implements Serializable {\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n+// start of generated patch\n+if(Precision.compareTo(entry,0.0,epsilon)>0){\n+columnsToDrop.add(i);\n+}\n+// end of generated patch\n+/* start of original code\n             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n+ end of original code*/\n         }\n \n         // non-basic artificial variables",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 647,
    "bugId": 258,
    "name": "Patch_40",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\nindex 9a6993a..42321ac 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+            if (Precision.compareTo(entry, 0d, this.epsilon) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 648,
    "bugId": 258,
    "name": "Patch_64_17",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\nindex 9a6993a..42321ac 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+            if (Precision.compareTo(entry, 0d, this.epsilon) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 649,
    "bugId": 258,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n@@ -337,4 +337,6 @@\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n-                columnsToDrop.add(i);\n+            if (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numSlackVariables < org.apache.commons.math3.optimization.linear.SimplexTableau.this.constraints.size()) {\n+                if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+                    columnsToDrop.add(i);\n+                }\n             }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 650,
    "bugId": 259,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -1015,9 +1015,15 @@ public Complex sqrt1z() {\n      * @since 1.2\n      */\n     public Complex tan() {\n-        if (isNaN) {\n+        if (isNaN || Double.isInfinite(real)) {\n             return NaN;\n         }\n+        if (imaginary > 20.0) {\n+            return createComplex(0.0, 1.0);\n+        }\n+        if (imaginary < -20.0) {\n+            return createComplex(0.0, -1.0);\n+        }\n \n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n@@ -1060,9 +1066,15 @@ public Complex tan() {\n      * @since 1.2\n      */\n     public Complex tanh() {\n-        if (isNaN) {\n+        if (isNaN || Double.isInfinite(imaginary)) {\n             return NaN;\n         }\n+        if (real > 20.0) {\n+            return createComplex(1.0, 0.0);\n+        }\n+        if (real < -20.0) {\n+            return createComplex(-1.0, 0.0);\n+        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 651,
    "bugId": 260,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n@@ -206,6 +206,6 @@ public String toString() {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+        return getChromosomes().iterator();\n     }\n }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 652,
    "bugId": 260,
    "name": "Patch_2_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\nindex 1eb0053..3f3919c 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n@@ -206,6 +206,6 @@ public abstract class ListPopulation implements Population {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+        return getChromosomes().iterator();\n     }\n }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 653,
    "bugId": 261,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -232,10 +232,16 @@ protected double doSolve() {\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n+                final int p = agingA - MAXIMAL_AGING;\n+                final double weightA = (1 << p) - 1;\n+                final double weightB = p + 1;\n+                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n             } else if (agingB >= MAXIMAL_AGING) {\n                 // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+                final int p = agingB - MAXIMAL_AGING;\n+                final double weightA = p + 1;\n+                final double weightB = (1 << p) - 1;\n+                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 654,
    "bugId": 261,
    "name": "Patch_193_56",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolverjava\n+++ /tmp/jGenProg_Defects4J_Math_40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolverjava\n@@ -232,7 +232,7 @@\n \t\t\tdouble targetY;\n \t\t\tif (agingA >= (org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.MAXIMAL_AGING)) {\n \n-\t\t\t\ttargetY = (-(org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.REDUCTION_FACTOR)) * yB;\n+\t\t\t\ttargetY = (-(org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.REDUCTION_FACTOR)) * yB; \t\t\t\tsignChangeIndex = 2;\n \t\t\t}else \t\t\t\tif (agingB >= (org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.MAXIMAL_AGING)) {\n \n \t\t\t\t\ttargetY = (-(org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.REDUCTION_FACTOR)) * yA;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 655,
    "bugId": 262,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n@@ -1657,10 +1657,10 @@ private void prelim(double[] lowerBound,\n                     final int tmp2 = jpt;\n                     jpt = ipt - n;\n                     ipt = tmp2;\n-                    throw new PathIsExploredException(); // XXX\n+//                     throw new PathIsExploredException(); // XXX\n                 }\n-                final int iptMinus1 = ipt;\n-                final int jptMinus1 = jpt;\n+                final int iptMinus1 = ipt - 1;\n+                final int jptMinus1 = jpt - 1;\n                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n             }\n@@ -1749,7 +1749,7 @@ private void prelim(double[] lowerBound,\n                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n-                throw new PathIsExploredException(); // XXX\n+//                 throw new PathIsExploredException(); // XXX\n             }\n         } while (getEvaluations() < npt);\n     } // prelim\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 656,
    "bugId": 263,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,15 @@ public void integrate(final ExpandableStatefulODE equations, final double t)\n         }\n \n         stepSize = hNew;\n+        if (forward) {\n+            if (stepStart + stepSize >= t) {\n+                stepSize = t - stepStart;\n+            }\n+        } else {\n+            if (stepStart + stepSize <= t) {\n+                stepSize = t - stepStart;\n+            }\n+        }\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 657,
    "bugId": 264,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n@@ -683,8 +683,14 @@ public BigFraction divide(final BigFraction fraction) {\n     @Override\n     public double doubleValue() {\n         double result = numerator.doubleValue() / denominator.doubleValue();\n+        if (Double.isNaN(result)) {\n             // Numerator and/or denominator must be out of range:\n             // Calculate how far to shift them to put them in range.\n+            int shift = Math.max(numerator.bitLength(),\n+                                 denominator.bitLength()) - Double.MAX_EXPONENT;\n+            result = numerator.shiftRight(shift).doubleValue() /\n+                denominator.shiftRight(shift).doubleValue();\n+        }\n         return result;\n     }\n \n@@ -730,8 +736,14 @@ public boolean equals(final Object other) {\n     @Override\n     public float floatValue() {\n         float result = numerator.floatValue() / denominator.floatValue();\n+        if (Double.isNaN(result)) {\n             // Numerator and/or denominator must be out of range:\n             // Calculate how far to shift them to put them in range.\n+            int shift = Math.max(numerator.bitLength(),\n+                                 denominator.bitLength()) - Float.MAX_EXPONENT;\n+            result = numerator.shiftRight(shift).floatValue() /\n+                denominator.shiftRight(shift).floatValue();\n+        }\n         return result;\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 658,
    "bugId": 265,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -407,10 +407,12 @@ protected RealPointValuePair getSolution() {\n             continue;\n           }\n           Integer basicRow = getBasicRow(colIndex);\n+          if (basicRow != null && basicRow == 0) {\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+              coefficients[i] = 0;\n+          } else if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 659,
    "bugId": 265,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -412,11 +412,13 @@\n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n-              // if multiple variables can take a given value\n-              // then we choose the first and set the rest equal to 0\n-              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n-          } else {\n-              basicRows.add(basicRow);\n-              coefficients[i] =\n+          if ((org.apache.commons.math.optimization.linear.SimplexTableau.this.numArtificialVariables) != (org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables)) {\n+              if (basicRows.contains(basicRow)) {\n+                  // if multiple variables can take a given value\n+                  // then we choose the first and set the rest equal to 0\n+                  coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n+              } else {\n+                  basicRows.add(basicRow);\n+                  coefficients[i] =\n                   (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                   (restrictToNonNegative ? 0 : mostNegative);\n+              }\n           }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 660,
    "bugId": 266,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n@@ -517,7 +517,7 @@ public double evaluate(final double[] values, final double[] weights,\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+                for (int i = begin; i < begin + length; i++) {\n                     sumWts += weights[i];\n                 }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 661,
    "bugId": 266,
    "name": "Patch_15_15",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\nindex e5518e31a..fe49cd7f4 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n@@ -517,9 +517,16 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se\n                 }\n \n                 double sumWts = 0;\n+// start of generated patch\n+for(int i=begin;i<begin+length;i++){\n+sumWts+=weights[i];\n+}\n+// end of generated patch\n+/* start of original code\n                 for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n+ end of original code*/\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 662,
    "bugId": 267,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n@@ -277,7 +277,6 @@ protected double acceptStep(final AbstractStepInterpolator interpolator,\n \n             double previousT = interpolator.getGlobalPreviousTime();\n             final double currentT = interpolator.getGlobalCurrentTime();\n-            resetOccurred = false;\n \n             // initialize the events states if needed\n             if (! statesInitialized) {\n@@ -331,6 +330,9 @@ public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n@@ -340,6 +342,9 @@ public int compare(EventState es0, EventState es1) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 663,
    "bugId": 268,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n@@ -155,13 +155,13 @@ public void addValue(double value) {\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n+        if (meanImpl != mean) {\n             meanImpl.increment(value);\n         }\n-        if (!(varianceImpl instanceof Variance)) {\n+        if (varianceImpl != variance) {\n             varianceImpl.increment(value);\n         }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+        if (geoMeanImpl != geoMean) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 664,
    "bugId": 268,
    "name": "Patch_5_5",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\nindex 1203d51..a167454 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n@@ -155,7 +155,7 @@ public class SummaryStatistics implements StatisticalSummary, Serializable {\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n+        if ((!(meanImpl instanceof Mean)) || !(!(varianceImpl instanceof Variance))) {\n             meanImpl.increment(value);\n         }\n         if (!(varianceImpl instanceof Variance)) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 665,
    "bugId": 268,
    "name": "Patch_19_19",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\nindex 1203d51..6f8ae74 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n@@ -161,7 +161,7 @@ public class SummaryStatistics implements StatisticalSummary, Serializable {\n         if (!(varianceImpl instanceof Variance)) {\n             varianceImpl.increment(value);\n         }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+        if ((!(geoMeanImpl instanceof GeometricMean)) || !(!(meanImpl instanceof Mean))) {\n             geoMeanImpl.increment(value);\n         }\n         n++;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 666,
    "bugId": 268,
    "name": "Patch_10_10",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\nindex 1203d51..356808f 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n@@ -158,7 +158,7 @@ public class SummaryStatistics implements StatisticalSummary, Serializable {\n         if (!(meanImpl instanceof Mean)) {\n             meanImpl.increment(value);\n         }\n-        if (!(varianceImpl instanceof Variance)) {\n+        if ((!(varianceImpl instanceof Variance)) || !(!(meanImpl instanceof Mean))) {\n             varianceImpl.increment(value);\n         }\n         if (!(geoMeanImpl instanceof GeometricMean)) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 667,
    "bugId": 269,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -1,87 +1,88 @@\n /*\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n  * contributor license agreements.  See the NOTICE file distributed with\n  * this work for additional information regarding copyright ownership.\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n  *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n \n package org.apache.commons.math.complex;\n \n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.List;\n \n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n  * Representation of a Complex number, i.e. a number which has both a\n  * real and imaginary part.\n  * <br/>\n  * Implementations of arithmetic operations handle {@code NaN} and\n  * infinite values according to the rules for {@link java.lang.Double}, i.e.\n  * {@link #equals} is an equivalence relation for all instances that have\n  * a {@code NaN} in either real or imaginary part, e.g. the following are\n  * considered equal:\n  * <ul>\n  *  <li>{@code 1 + NaNi}</li>\n  *  <li>{@code NaN + i}</li>\n  *  <li>{@code NaN + NaNi}</li>\n  * </ul>\n  * Note that this is in contradiction with the IEEE-754 standard for floating\n  * point numbers (according to which the test {@code x == x} must fail if\n  * {@code x} is {@code NaN}). The method\n  * {@link MathUtils#equals(double,double,int) equals for primitive double} in\n  * {@link MathUtils} conforms with IEEE-754 while this class conforms with\n  * the standard behavior for Java object types.\n  * <br/>\n  * Implements Serializable since 2.0\n  *\n  * @version $Id$\n  */\n public class Complex implements FieldElement<Complex>, Serializable  {\n     /** The square root of -1. A number representing \"0.0 + 1.0i\" */\n     public static final Complex I = new Complex(0.0, 1.0);\n     // CHECKSTYLE: stop ConstantName\n     /** A complex number representing \"NaN + NaNi\" */\n     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n     // CHECKSTYLE: resume ConstantName\n     /** A complex number representing \"+INF + INFi\" */\n     public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n     /** A complex number representing \"1.0 + 0.0i\" */\n     public static final Complex ONE = new Complex(1.0, 0.0);\n     /** A complex number representing \"0.0 + 0.0i\" */\n     public static final Complex ZERO = new Complex(0.0, 0.0);\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6195664516687396620L;\n \n     /** The imaginary part. */\n     private final double imaginary;\n     /** The real part. */\n     private final double real;\n     /** Record whether this complex number is equal to NaN. */\n     private final transient boolean isNaN;\n     /** Record whether this complex number is infinite. */\n     private final transient boolean isInfinite;\n     /** Record whether this complex number is zero. */\n+    private final transient boolean isZero;\n \n     /**\n      * Create a complex number given only the real part.\n      *\n      * @param real Real part.\n      */\n@@ -98,17 +99,18 @@ public Complex(double real) {\n     public Complex(double real, double imaginary) {\n         this.real = real;\n         this.imaginary = imaginary;\n \n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n+        isZero = real == 0 && imaginary == 0;\n     }\n \n     /**\n      * Return the absolute value of this complex number.\n      * Returns {@code NaN} if either real or imaginary part is {@code NaN}\n      * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},\n      * but at least one part is infinite.\n      *\n      * @return the absolute value.\n      */\n@@ -249,60 +251,60 @@ public Complex conjugate() {\n     public Complex divide(Complex divisor)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(divisor);\n         if (isNaN || divisor.isNaN) {\n             return NaN;\n         }\n \n-        if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {\n-            return NaN;\n+        if (divisor.isZero) {\n+            return isZero ? NaN : INF;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n             return ZERO;\n         }\n \n         final double c = divisor.getReal();\n         final double d = divisor.getImaginary();\n \n         if (FastMath.abs(c) < FastMath.abs(d)) {\n             double q = c / d;\n             double denominator = c * q + d;\n             return createComplex((real * q + imaginary) / denominator,\n                 (imaginary * q - real) / denominator);\n         } else {\n             double q = d / c;\n             double denominator = d * q + c;\n             return createComplex((imaginary * q + real) / denominator,\n                 (imaginary - real * q) / denominator);\n         }\n     }\n \n     /**\n      * Returns a {@code Complex} whose value is {@code (this / divisor)},\n      * with {@code divisor} interpreted as a real number.\n      *\n      * @param  divisor Value by which this {@code Complex} is to be divided.\n      * @return {@code this / divisor}.\n      * @see #divide(Complex)\n      */\n     public Complex divide(double divisor) {\n         if (isNaN || Double.isNaN(divisor)) {\n             return NaN;\n         }\n         if (divisor == 0d) {\n-            return NaN;\n+            return isZero ? NaN : INF;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n         }\n         return createComplex(real / divisor,\n                              imaginary  / divisor);\n     }\n \n     /**\n      * Test for the equality of two Complex objects.\n      * If both the real and imaginary parts of two complex numbers\n      * are exactly the same, and neither is {@code Double.NaN}, the two\n      * Complex objects are considered to be equal.\n      * All {@code NaN} values are considered to be equal - i.e, if either\n      * (or both) real and imaginary parts of the complex number are equal\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 668,
    "bugId": 270,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -186,6 +186,9 @@ protected final double doSolve() {\n                 case REGULA_FALSI:\n                     // Detect early that algorithm is stuck, instead of waiting\n                     // for the maximum number of iterations to be exceeded.\n+                    if (x == x1) {\n+                        throw new ConvergenceException();\n+                    }\n                     break;\n                 default:\n                     // Should never happen.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 669,
    "bugId": 271,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -184,10 +184,6 @@ protected final double doSolve() {\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n                     break;\n                 default:\n                     // Should never happen.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 670,
    "bugId": 271,
    "name": "Patch_3_3",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n+++ /tmp/Cardumen_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n@@ -185,7 +185,7 @@\n \t\t\t\t\tcase REGULA_FALSI :\n \n \t\t\t\t\t\tif (x == x1) {\n-\t\t\t\t\t\t\tx0 = 0.5 * ((x0 + x1) - (org.apache.commons.math.util.FastMath.max((rtol * (org.apache.commons.math.util.FastMath.abs(x1))), atol)));\n+\t\t\t\t\t\t\tx0 = getMax();\n \t\t\t\t\t\t\tf0 = computeObjectiveValue(x0);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 671,
    "bugId": 271,
    "name": "Patch_18_18",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d98204..fa4d85e34 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -184,10 +184,18 @@ public abstract class BaseSecantSolver\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n+// start of generated patch\n+if(x==x0){\n+x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol));\n+f0=computeObjectiveValue(x0);\n+}\n+// end of generated patch\n+/* start of original code\n                     if (x == x1) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n+ end of original code*/\n                     break;\n                 default:\n                     // Should never happen.",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 672,
    "bugId": 271,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -187,3 +187,5 @@\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        if (false) {\n+                            x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        }\n                         f0 = computeObjectiveValue(x0);\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 673,
    "bugId": 271,
    "name": "Patch_3_3",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2019-08-03 23:22:21.314706365 -0400\n+++ /tmp/Arja_Defects4J_Math_50/patches_qmki/Patch_3/patched/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2019-08-04 00:19:03.060444399 -0400\n@@ -185,7 +185,6 @@\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 674,
    "bugId": 271,
    "name": "Patch_2_2",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d982..82898f0 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -184,7 +184,7 @@ public abstract class BaseSecantSolver\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n+                    if (fx == x1) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 675,
    "bugId": 271,
    "name": "Patch_3_3",
    "tool": "jMutRepair",
    "diff": "--- /tmp/jMutRepair_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n+++ /tmp/jMutRepair_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n@@ -184,7 +184,7 @@\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REGULA_FALSI :\n \n-\t\t\t\t\t\tif (x == x1) {\n+\t\t\t\t\t\tif (x > x1) {\n \t\t\t\t\t\t\tx0 = 0.5 * ((x0 + x1) - (org.apache.commons.math.util.FastMath.max((rtol * (org.apache.commons.math.util.FastMath.abs(x1))), atol)));\n \t\t\t\t\t\t\tf0 = computeObjectiveValue(x0);\n \t\t\t\t\t\t}",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 676,
    "bugId": 271,
    "name": "Patch_10_7",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n+++ /tmp/jGenProg_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n@@ -184,10 +184,10 @@\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REGULA_FALSI :\n \n-\t\t\t\t\t\tif (x == x1) {\n-\t\t\t\t\t\t\tx0 = 0.5 * ((x0 + x1) - (org.apache.commons.math.util.FastMath.max((rtol * (org.apache.commons.math.util.FastMath.abs(x1))), atol)));\n+\t\t\t\t\t\tif (x == x1)\n+\n \t\t\t\t\t\t\tf0 = computeObjectiveValue(x0);\n-\t\t\t\t\t\t}\n+\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault :",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 677,
    "bugId": 271,
    "name": "Patch_2_2",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d98204..82898f00c 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -184,7 +184,7 @@ public abstract class BaseSecantSolver\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n+                    if (fx == x1) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 678,
    "bugId": 271,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -186,5 +186,7 @@\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n+                    if (-1 == 0) {\n+                        if (x == x1) {\n+                            x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                            f0 = computeObjectiveValue(x0);\n+                        }\n                     }\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 679,
    "bugId": 271,
    "name": "Patch_2_2",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d982..b6dba35 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -184,7 +184,7 @@ public abstract class BaseSecantSolver\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n+                    if ((f1 == 0.0)) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 680,
    "bugId": 271,
    "name": "Patch_4_4",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d982..79484a7 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -184,7 +184,7 @@ public abstract class BaseSecantSolver\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n+                    if (x>x1) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 681,
    "bugId": 271,
    "name": "Patch_2_2",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2019-08-04 13:12:55.404167814 -0400\n+++ /tmp/RSRepair_Defects4J_Math_50/patches_y0o8/Patch_2/patched/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2019-08-04 13:42:44.825082073 -0400\n@@ -183,11 +183,7 @@\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n-                    // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+                    ;\n                     break;\n                 default:\n                     // Should never happen.\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 682,
    "bugId": 271,
    "name": "Patch_2_2",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2019-08-04 02:07:05.419756394 -0400\n+++ /tmp/GenProg_Defects4J_Math_50/patches_tths/Patch_2/patched/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2019-08-04 02:50:28.045086138 -0400\n@@ -185,7 +185,6 @@\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 683,
    "bugId": 271,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 684,
    "bugId": 272,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -342,7 +342,7 @@ public double dotProduct(RealVector v) {\n     public OpenMapRealVector ebeDivide(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = res.entries.iterator();\n+        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n@@ -355,7 +355,7 @@ public OpenMapRealVector ebeDivide(RealVector v) {\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = res.entries.iterator();\n+        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n@@ -367,7 +367,7 @@ public OpenMapRealVector ebeDivide(double[] v) {\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = res.entries.iterator();\n+        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n@@ -380,7 +380,7 @@ public OpenMapRealVector ebeMultiply(RealVector v) {\n     public OpenMapRealVector ebeMultiply(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = res.entries.iterator();\n+        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 685,
    "bugId": 272,
    "name": "Patch_130_99",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_49/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\t2019-08-03 22:36:30.545300930 -0400\n+++ /tmp/Arja_Defects4J_Math_49/patches_24my/Patch_99/patched/org/apache/commons/math/linear/OpenMapRealVector.java\t2019-08-03 23:22:13.070702152 -0400\n@@ -355,7 +355,8 @@\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = res.entries.iterator();\n+        checkVectorDimensions(v.length);\n+\t\tIterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n@@ -367,7 +368,7 @@\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = res.entries.iterator();\n+        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n@@ -380,7 +381,7 @@\n     public OpenMapRealVector ebeMultiply(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = res.entries.iterator();\n+        Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 686,
    "bugId": 273,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -257,7 +257,7 @@ public Complex divide(Complex divisor)\n \n         if (divisor.isZero) {\n             // return isZero ? NaN : INF; // See MATH-657\n-            return isZero ? NaN : INF;\n+            return NaN;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n@@ -294,7 +294,7 @@ public Complex divide(double divisor) {\n         }\n         if (divisor == 0d) {\n             // return isZero ? NaN : INF; // See MATH-657\n-            return isZero ? NaN : INF;\n+            return NaN;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 687,
    "bugId": 274,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n@@ -47,6 +47,11 @@\n      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n+        long lRow = (long) rowDimension;\n+        long lCol = (long) columnDimension;\n+        if (lRow * lCol >= (long) Integer.MAX_VALUE) {\n+            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);\n+        }\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 688,
    "bugId": 275,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -182,10 +182,19 @@ protected final double doSolve() {\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n+                case REGULA_FALSI:\n+                    if (x == x1) {\n+                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n+                                                          atol);\n                         // Update formula cannot make any progress: Update the\n                         // search interval.\n+                        x0 = 0.5 * (x0 + x1 - delta);\n+                        f0 = computeObjectiveValue(x0);\n+                    }\n+                    break;\n                 default:\n                     // Should never happen.\n+                    throw new MathInternalError();\n                 }\n             }\n             // Update from [x0, x1] to [x0, x].\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 689,
    "bugId": 276,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n@@ -118,7 +118,7 @@ public double value(double x, double[] p) {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+        return fit(guess);\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 690,
    "bugId": 276,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2019-08-04 00:56:41.649598368 -0400\n+++ /tmp/Arja_Defects4J_Math_58/patches_4nsq/Patch_1/patched/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2019-08-04 01:35:43.410794830 -0400\n@@ -118,7 +118,7 @@\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+        return fit((new ParameterGuesser(getObservations())).guess());\n     }\n \n     /**\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 691,
    "bugId": 276,
    "name": "Patch_3_3",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\nindex ae7ac39..e1b54f4 100644\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n@@ -118,7 +118,7 @@ public class GaussianFitter extends CurveFitter {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+        return fit(guess);\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 692,
    "bugId": 276,
    "name": "Patch_2_1",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\nindex ae7ac39..e1b54f4 100644\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n@@ -118,7 +118,7 @@ public class GaussianFitter extends CurveFitter {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+        return fit(guess);\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 693,
    "bugId": 276,
    "name": "Patch_25_7",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2019-08-04 14:05:48.469789009 -0400\n+++ /tmp/RSRepair_Defects4J_Math_58/patches_ugri/Patch_7/patched/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2019-08-04 14:27:20.978449385 -0400\n@@ -118,7 +118,7 @@\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+        return fit((new ParameterGuesser(getObservations())).guess());\n     }\n \n     /**\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 694,
    "bugId": 277,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -3479,7 +3479,7 @@ public static long max(final long a, final long b) {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n     }\n \n     /** Compute the maximum of two values\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 695,
    "bugId": 277,
    "name": "Patch_3_3",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/FastMath.java b/src/main/java/org/apache/commons/math/util/FastMath.java\nindex 8cba4d484..ead4e946a 100644\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -904,7 +904,7 @@ public class FastMath {\n      *  For x between 0 and 1, returns exp(x), uses extended precision\n      *  @param x argument of exponential\n      *  @param result placeholder where to place exp(x) split in two terms\n-     *  for extra precision (i.e. exp(x) = result[0] \u00b0 result[1]\n+     *  for extra precision (i.e. exp(x) = result[0] ?? result[1]\n      *  @return exp(x)\n      */\n     private static double slowexp(final double x, final double result[]) {\n@@ -3479,7 +3479,12 @@ public class FastMath {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n+// start of generated patch\n+return (a<=b)?b:(Float.isNaN(a+b)?Float.NaN:a);\n+// end of generated patch\n+/* start of original code\n         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+ end of original code*/\n     }\n \n     /** Compute the maximum of two values",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 696,
    "bugId": 277,
    "name": "Patch_15_13",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/FastMath.java b/src/main/java/org/apache/commons/math/util/FastMath.java\nindex 8cba4d4..eca1fff 100644\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -904,7 +904,7 @@ public class FastMath {\n      *  For x between 0 and 1, returns exp(x), uses extended precision\n      *  @param x argument of exponential\n      *  @param result placeholder where to place exp(x) split in two terms\n-     *  for extra precision (i.e. exp(x) = result[0] ?? result[1]\n+     *  for extra precision (i.e. exp(x) = result[0] ?? result[1]\n      *  @return exp(x)\n      */\n     private static double slowexp(final double x, final double result[]) {\n@@ -3479,7 +3479,7 @@ public class FastMath {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n     }\n \n     /** Compute the maximum of two values\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 697,
    "bugId": 278,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,7 +172,7 @@ public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 698,
    "bugId": 278,
    "name": "Patch_16_16",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d3e..0522f6f44 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,6 +172,17 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n+// start of generated patch\n+double sum=0;\n+for(int i=0;i<pointSet.size();i++){\n+ final T p=pointSet.get(i);\n+ final Cluster<T> nearest=getNearestCluster(resultSet,p);\n+ final double d=p.distanceFrom(nearest.getCenter());\n+sum+=d*d;\n+dx2[i]=sum;\n+}\n+// end of generated patch\n+/* start of original code\n             int sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n@@ -180,6 +191,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n                 sum += d * d;\n                 dx2[i] = sum;\n             }\n+ end of original code*/\n \n             // Add one new data point as a center. Each point x is chosen with\n             // probability proportional to D(x)2",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 699,
    "bugId": 278,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d..e09bbc3 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,7 +172,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 700,
    "bugId": 278,
    "name": "Patch_1_1",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d..e09bbc3 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,7 +172,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 701,
    "bugId": 279,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -150,6 +150,9 @@ public double abs() {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n+        if (isNaN || rhs.isNaN) {\n+            return NaN;\n+        }\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 702,
    "bugId": 279,
    "name": "Patch_2_2",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex e0a8e97e9..831dd3dda 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -149,9 +149,18 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n      */\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n+// start of generated patch\n+MathUtils.checkNotNull(rhs);\n+if(isNaN||rhs.isNaN){\n+return NaN;\n+}\n+return createComplex(real+rhs.getReal(),imaginary+rhs.getImaginary());\n+// end of generated patch\n+/* start of original code\n         MathUtils.checkNotNull(rhs);\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n+ end of original code*/\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 703,
    "bugId": 279,
    "name": "Patch_61_50",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_53/src/main/java/org/apache/commons/math/complex/Complex.java\t2019-08-04 00:19:09.560447720 -0400\n+++ /tmp/Arja_Defects4J_Math_53/patches_3q2v/Patch_50/patched/org/apache/commons/math/complex/Complex.java\t2019-08-04 00:56:35.685595320 -0400\n@@ -149,7 +149,9 @@\n      */\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n-        MathUtils.checkNotNull(rhs);\n+        if (isNaN || rhs.isNaN) {\n+\t\t\treturn NaN;\n+\t\t}\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 704,
    "bugId": 279,
    "name": "Patch_17_9",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_53/src/main/java/org/apache/commons/math/complex/Complexjava\n+++ /tmp/jGenProg_Defects4J_Math_53/src/main/java/org/apache/commons/math/complex/Complexjava\n@@ -150,9 +150,6 @@\n \tpublic org.apache.commons.math.complex.Complex add(org.apache.commons.math.complex.Complex rhs) throws \n \torg.apache.commons.math.exception.NullArgumentException {\n \t\torg.apache.commons.math.util.MathUtils.checkNotNull(rhs);\n-\t\treturn createComplex(((real) + (rhs.getReal())), \n-\t\t((imaginary) + (rhs.getImaginary())));\n-\t}\n \n \n \n@@ -168,12 +165,6 @@\n \n \n \n-\tpublic org.apache.commons.math.complex.Complex conjugate() {\n-\t\tif (isNaN) {\n-\t\t\treturn org.apache.commons.math.complex.Complex.NaN;\n-\t\t}\n-\t\treturn createComplex(real, (-(imaginary)));\n-\t}\n \n \n \n@@ -210,12 +201,21 @@\n \n \n \n-\tpublic org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex rhs) throws \n-\torg.apache.commons.math.exception.NullArgumentException {\n-\t\torg.apache.commons.math.util.MathUtils.checkNotNull(rhs);\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n \t\tif ((isNaN) || (rhs.isNaN)) {\n \t\t\treturn org.apache.commons.math.complex.Complex.NaN;\n-\t\t}\n+\t\t} \t\treturn createComplex(((real) + (rhs.getReal())), ((imaginary) + (rhs.getImaginary())));} \tpublic org.apache.commons.math.complex.Complex conjugate() { \t\tif (isNaN) { \t\t\treturn org.apache.commons.math.complex.Complex.NaN;} \t\treturn createComplex(real, (-(imaginary)));} \tpublic org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex rhs) throws org.apache.commons.math.exception.NullArgumentException { \t\torg.apache.commons.math.util.MathUtils.checkNotNull(rhs); \t\tif ((isNaN) || (rhs.isNaN)) { \t\t\treturn org.apache.commons.math.complex.Complex.NaN;}\n \n \t\tdouble c = rhs.getReal();\n \t\tdouble d = rhs.getImaginary();",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 705,
    "bugId": 279,
    "name": "Patch_4_3",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_53/src/main/java/org/apache/commons/math/complex/Complex.java\t2019-08-04 13:42:48.709084057 -0400\n+++ /tmp/RSRepair_Defects4J_Math_53/patches_7vyd/Patch_3/patched/org/apache/commons/math/complex/Complex.java\t2019-08-04 14:05:44.301786881 -0400\n@@ -149,7 +149,9 @@\n      */\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n-        MathUtils.checkNotNull(rhs);\n+        if (isNaN || rhs.isNaN) {\n+\t\t\treturn NaN;\n+\t\t}\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 706,
    "bugId": 280,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n@@ -19,7 +19,7 @@\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.util.MathUtils;\n@@ -91,7 +91,7 @@ public PoissonDistributionImpl(double p) {\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 707,
    "bugId": 280,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\nindex 148daad..c225e86 100644\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.commons.math.distribution;\n+package org.apache.commons.math.distribution;import  org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n import java.io.Serializable;\n \n@@ -91,7 +91,7 @@ public class PoissonDistributionImpl extends AbstractIntegerDistribution\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n+if (p <= 0){throw new NotStrictlyPositiveException(null);}            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 708,
    "bugId": 281,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n@@ -456,9 +456,21 @@ public static double dotProduct(Vector3D v1, Vector3D v2) {\n    */\n   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n \n+      final double n1 = v1.getNormSq();\n+      final double n2 = v2.getNormSq();\n+      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n+          return ZERO;\n+      }\n \n       // rescale both vectors without losing precision,\n       // to ensure their norm are the same order of magnitude\n+      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n+      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n+      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n+      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n+      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n+      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n+      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n \n       // we reduce cancellation errors by preconditioning,\n       // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n@@ -467,10 +479,15 @@ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n+      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n+      final double rho   = FastMath.rint(256 * ratio) / 256;\n \n+      final double x3 = x1 - rho * x2;\n+      final double y3 = y1 - rho * y2;\n+      final double z3 = z1 - rho * z2;\n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n \n   }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 709,
    "bugId": 282,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n@@ -123,18 +123,11 @@ public double density(double x) {\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n+        if (FastMath.abs(dev) > 40 * standardDeviation) { \n+            return dev < 0 ? 0.0d : 1.0d;\n+        }\n         return 0.5 * (1.0 + Erf.erf((dev) /\n                     (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 710,
    "bugId": 283,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math/dfp/Dfp.java\n@@ -270,6 +270,9 @@ protected Dfp(final DfpField field, double x) {\n             // Zero or sub-normal\n             if (x == 0) {\n                 // make sure 0 has the right sign\n+                if ((bits & 0x8000000000000000L) != 0) {\n+                    sign = -1;\n+                }\n                 return;\n             }\n \n@@ -2316,7 +2319,10 @@ public double toDouble() {\n \n         Dfp y = this;\n         boolean negate = false;\n-        if (lessThan(getZero())) {\n+        int cmp0 = compare(this, getZero());\n+        if (cmp0 == 0) {\n+            return sign < 0 ? -0.0 : +0.0;\n+        } else if (cmp0 < 0) {\n             y = negate();\n             negate = true;\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 711,
    "bugId": 284,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n@@ -234,13 +234,7 @@ public int getDimension() {\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+        indices[last] = index - count;\n \n         return indices;\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 712,
    "bugId": 284,
    "name": "Patch_127_75",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_56/src/main/java/org/apache/commons/math/util/MultidimensionalCounterjava\n+++ /tmp/jGenProg_Defects4J_Math_56/src/main/java/org/apache/commons/math/util/MultidimensionalCounterjava\n@@ -236,9 +236,9 @@\n \n \t\tint idx = 1;\n \t\twhile (count < index) {\n-\t\t\tcount += idx;\n+\t\t\tcount += idx; \t\t\twhile (count < index) { \t\t\t\tcount += idx;\n \t\t\t++idx;\n-\t\t} \n+\t\t\t} \t\t\t++idx;} \n \t\t--idx;\n \t\tindices[last] = idx;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 713,
    "bugId": 285,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n@@ -341,7 +341,8 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n+  final double inPlaneThreshold = 0.001;\n+  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n     // the (q1, q2, q3) vector is close to the (u1, u2) plane\n     // we try other vectors\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);\n@@ -350,13 +351,13 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n     Vector3D u2Prime = u1.crossProduct(u3);\n     c = k.dotProduct(u2Prime);\n \n-    if (c == 0) {\n+    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n       // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n       // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n       k = v2Su2.crossProduct(v3Su3);;\n       c = k.dotProduct(u2.crossProduct(u3));;\n \n-      if (c == 0) {\n+      if (c <= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 714,
    "bugId": 285,
    "name": "Patch_3_3",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\nindex 20f5b34..0187223 100644\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n@@ -341,7 +341,7 @@ public class Rotation implements Serializable {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n+  if (c<=0) {\n     // the (q1, q2, q3) vector is close to the (u1, u2) plane\n     // we try other vectors\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 715,
    "bugId": 286,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -414,7 +414,7 @@ public static double cosh(double x) {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return equals(x, y, 1);\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 716,
    "bugId": 286,
    "name": "Patch_3_3",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Math_63/src/main/java/org/apache/commons/math/util/MathUtilsjava\n+++ /tmp/Cardumen_Defects4J_Math_63/src/main/java/org/apache/commons/math/util/MathUtilsjava\n@@ -414,8 +414,7 @@\n \n \n \tpublic static boolean equals(double x, double y) {\n-\t\treturn ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (x == y);\n-\t}\n+\t\treturn (\n \n \n \n@@ -425,9 +424,6 @@\n \n \n \n-\tpublic static boolean equalsIncludingNaN(double x, double y) {\n-\t\treturn ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, 1));\n-\t}\n \n \n \n@@ -438,9 +434,6 @@\n \n \n \n-\tpublic static boolean equals(double x, double y, double eps) {\n-\t\treturn (org.apache.commons.math.util.MathUtils.equals(x, y, 1)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);\n-\t}\n \n \n \n@@ -452,9 +445,6 @@\n \n \n \n-\tpublic static boolean equalsIncludingNaN(double x, double y, double eps) {\n-\t\treturn (org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x, y)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);\n-\t}\n \n \n \n@@ -473,26 +463,13 @@\n \n \n \n-\tpublic static boolean equals(double x, double y, int maxUlps) {\n \n \n-\t\tassert (maxUlps > 0) && (maxUlps < (org.apache.commons.math.util.MathUtils.NAN_GAP));\n \n-\t\tlong xInt = java.lang.Double.doubleToLongBits(x);\n-\t\tlong yInt = java.lang.Double.doubleToLongBits(y);\n \n \n-\t\tif (xInt < 0) {\n-\t\t\txInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - xInt;\n-\t\t}\n-\t\tif (yInt < 0) {\n-\t\t\tyInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - yInt;\n-\t\t}\n \n-\t\tfinal boolean isEqual = (org.apache.commons.math.util.FastMath.abs((xInt - yInt))) <= maxUlps;\n \n-\t\treturn (isEqual && (!(java.lang.Double.isNaN(x)))) && (!(java.lang.Double.isNaN(y)));\n-\t}\n \n \n \n@@ -505,9 +482,6 @@\n \n \n \n-\tpublic static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n-\t\treturn ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, maxUlps));\n-\t}\n \n \n \n@@ -519,20 +493,6 @@\n \n \n \n-\tpublic static boolean equals(double[] x, double[] y) {\n-\t\tif ((x == null) || (y == null)) {\n-\t\t\treturn !((x == null) ^ (y == null));\n-\t\t}\n-\t\tif ((x.length) != (y.length)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tfor (int i = 0; i < (x.length); ++i) {\n-\t\t\tif (!(org.apache.commons.math.util.MathUtils.equals(x[i], y[i]))) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n \n \n \n@@ -544,20 +504,6 @@\n \n \n \n-\tpublic static boolean equalsIncludingNaN(double[] x, double[] y) {\n-\t\tif ((x == null) || (y == null)) {\n-\t\t\treturn !((x == null) ^ (y == null));\n-\t\t}\n-\t\tif ((x.length) != (y.length)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tfor (int i = 0; i < (x.length); ++i) {\n-\t\t\tif (!(org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x[i], y[i]))) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n \n \n \n@@ -581,18 +527,6 @@\n \n \n \n-\tpublic static long factorial(final int n) {\n-\t\tif (n < 0) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, \n-\t\t\tn);\n-\t\t}\n-\t\tif (n > 20) {\n-\t\t\tthrow new java.lang.ArithmeticException(\n-\t\t\t\"factorial value is too large to fit in a long\");\n-\t\t}\n-\t\treturn org.apache.commons.math.util.MathUtils.FACTORIALS[n];\n-\t}\n \n \n \n@@ -614,17 +548,6 @@\n \n \n \n-\tpublic static double factorialDouble(final int n) {\n-\t\tif (n < 0) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, \n-\t\t\tn);\n-\t\t}\n-\t\tif (n < 21) {\n-\t\t\treturn org.apache.commons.math.util.MathUtils.factorial(n);\n-\t\t}\n-\t\treturn org.apache.commons.math.util.FastMath.floor(((org.apache.commons.math.util.FastMath.exp(org.apache.commons.math.util.MathUtils.factorialLog(n))) + 0.5));\n-\t}\n \n \n \n@@ -639,21 +562,6 @@\n \n \n \n-\tpublic static double factorialLog(final int n) {\n-\t\tif (n < 0) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, \n-\t\t\tn);\n-\t\t}\n-\t\tif (n < 21) {\n-\t\t\treturn org.apache.commons.math.util.FastMath.log(org.apache.commons.math.util.MathUtils.factorial(n));\n-\t\t}\n-\t\tdouble logSum = 0;\n-\t\tfor (int i = 2; i <= n; i++) {\n-\t\t\tlogSum += org.apache.commons.math.util.FastMath.log(i);\n-\t\t}\n-\t\treturn logSum;\n-\t}\n \n \n \n@@ -684,65 +592,23 @@\n \n \n \n-\tpublic static int gcd(final int p, final int q) {\n-\t\tint u = p;\n-\t\tint v = q;\n-\t\tif ((u == 0) || (v == 0)) {\n-\t\t\tif ((u == (java.lang.Integer.MIN_VALUE)) || (v == (java.lang.Integer.MIN_VALUE))) {\n-\t\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(\n-\t\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_32_BITS, \n-\t\t\t\tp, q);\n-\t\t\t}\n-\t\t\treturn (org.apache.commons.math.util.FastMath.abs(u)) + (org.apache.commons.math.util.FastMath.abs(v));\n-\t\t}\n \n \n \n \n \n-\t\tif (u > 0) {\n-\t\t\tu = -u;\n-\t\t}\n-\t\tif (v > 0) {\n-\t\t\tv = -v;\n-\t\t}\n \n-\t\tint k = 0;\n-\t\twhile ((((u & 1) == 0) && ((v & 1) == 0)) && (k < 31)) {\n \n-\t\t\tu /= 2;\n-\t\t\tv /= 2;\n-\t\t\tk++;\n-\t\t} \n-\t\tif (k == 31) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_32_BITS, \n-\t\t\tp, q);\n-\t\t}\n \n \n-\t\tint t = ((u & 1) == 1) ? v : -(u / 2);\n \n \n-\t\tdo {\n \n \n-\t\t\twhile ((t & 1) == 0) {\n-\t\t\t\tt /= 2;\n-\t\t\t} \n \n-\t\t\tif (t > 0) {\n-\t\t\t\tu = -t;\n-\t\t\t}else {\n-\t\t\t\tv = t;\n-\t\t\t}\n \n-\t\t\tt = (v - u) / 2;\n \n \n-\t\t} while (t != 0 );\n-\t\treturn (-u) * (1 << k);\n-\t}\n \n \n \n@@ -773,65 +639,23 @@\n \n \n \n-\tpublic static long gcd(final long p, final long q) {\n-\t\tlong u = p;\n-\t\tlong v = q;\n-\t\tif ((u == 0) || (v == 0)) {\n-\t\t\tif ((u == (java.lang.Long.MIN_VALUE)) || (v == (java.lang.Long.MIN_VALUE))) {\n-\t\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(\n-\t\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_64_BITS, \n-\t\t\t\tp, q);\n-\t\t\t}\n-\t\t\treturn (org.apache.commons.math.util.FastMath.abs(u)) + (org.apache.commons.math.util.FastMath.abs(v));\n-\t\t}\n \n \n \n \n \n-\t\tif (u > 0) {\n-\t\t\tu = -u;\n-\t\t}\n-\t\tif (v > 0) {\n-\t\t\tv = -v;\n-\t\t}\n \n-\t\tint k = 0;\n-\t\twhile ((((u & 1) == 0) && ((v & 1) == 0)) && (k < 63)) {\n \n-\t\t\tu /= 2;\n-\t\t\tv /= 2;\n-\t\t\tk++;\n-\t\t} \n-\t\tif (k == 63) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_64_BITS, \n-\t\t\tp, q);\n-\t\t}\n \n \n-\t\tlong t = ((u & 1) == 1) ? v : -(u / 2);\n \n \n-\t\tdo {\n \n \n-\t\t\twhile ((t & 1) == 0) {\n-\t\t\t\tt /= 2;\n-\t\t\t} \n \n-\t\t\tif (t > 0) {\n-\t\t\t\tu = -t;\n-\t\t\t}else {\n-\t\t\t\tv = t;\n-\t\t\t}\n \n-\t\t\tt = (v - u) / 2;\n \n \n-\t\t} while (t != 0 );\n-\t\treturn (-u) * (1L << k);\n-\t}\n \n \n \n@@ -839,9 +663,6 @@\n \n \n \n-\tpublic static int hash(double value) {\n-\t\treturn new java.lang.Double(value).hashCode();\n-\t}\n \n \n \n@@ -850,9 +671,6 @@\n \n \n \n-\tpublic static int hash(double[] value) {\n-\t\treturn java.util.Arrays.hashCode(value);\n-\t}\n \n \n \n@@ -861,9 +679,6 @@\n \n \n \n-\tpublic static byte indicator(final byte x) {\n-\t\treturn x >= (org.apache.commons.math.util.MathUtils.ZB) ? org.apache.commons.math.util.MathUtils.PB : org.apache.commons.math.util.MathUtils.NB;\n-\t}\n \n \n \n@@ -873,12 +688,6 @@\n \n \n \n-\tpublic static double indicator(final double x) {\n-\t\tif (java.lang.Double.isNaN(x)) {\n-\t\t\treturn java.lang.Double.NaN;\n-\t\t}\n-\t\treturn x >= 0.0 ? 1.0 : -1.0;\n-\t}\n \n \n \n@@ -887,12 +696,6 @@\n \n \n \n-\tpublic static float indicator(final float x) {\n-\t\tif (java.lang.Float.isNaN(x)) {\n-\t\t\treturn java.lang.Float.NaN;\n-\t\t}\n-\t\treturn x >= 0.0F ? 1.0F : -1.0F;\n-\t}\n \n \n \n@@ -900,9 +703,6 @@\n \n \n \n-\tpublic static int indicator(final int x) {\n-\t\treturn x >= 0 ? 1 : -1;\n-\t}\n \n \n \n@@ -910,9 +710,6 @@\n \n \n \n-\tpublic static long indicator(final long x) {\n-\t\treturn x >= 0L ? 1L : -1L;\n-\t}\n \n \n \n@@ -921,9 +718,6 @@\n \n \n \n-\tpublic static short indicator(final short x) {\n-\t\treturn x >= (org.apache.commons.math.util.MathUtils.ZS) ? org.apache.commons.math.util.MathUtils.PS : org.apache.commons.math.util.MathUtils.NS;\n-\t}\n \n \n \n@@ -948,18 +742,6 @@\n \n \n \n-\tpublic static int lcm(int a, int b) {\n-\t\tif ((a == 0) || (b == 0)) {\n-\t\t\treturn 0;\n-\t\t}\n-\t\tint lcm = org.apache.commons.math.util.FastMath.abs(org.apache.commons.math.util.MathUtils.mulAndCheck((a / (org.apache.commons.math.util.MathUtils.gcd(a, b))), b));\n-\t\tif (lcm == (java.lang.Integer.MIN_VALUE)) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.LCM_OVERFLOW_32_BITS, \n-\t\t\ta, b);\n-\t\t}\n-\t\treturn lcm;\n-\t}\n \n \n \n@@ -983,18 +765,6 @@\n \n \n \n-\tpublic static long lcm(long a, long b) {\n-\t\tif ((a == 0) || (b == 0)) {\n-\t\t\treturn 0;\n-\t\t}\n-\t\tlong lcm = org.apache.commons.math.util.FastMath.abs(org.apache.commons.math.util.MathUtils.mulAndCheck((a / (org.apache.commons.math.util.MathUtils.gcd(a, b))), b));\n-\t\tif (lcm == (java.lang.Long.MIN_VALUE)) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.LCM_OVERFLOW_64_BITS, \n-\t\t\ta, b);\n-\t\t}\n-\t\treturn lcm;\n-\t}\n \n \n \n@@ -1012,9 +782,6 @@\n \n \n \n-\tpublic static double log(double base, double x) {\n-\t\treturn (org.apache.commons.math.util.FastMath.log(x)) / (org.apache.commons.math.util.FastMath.log(base));\n-\t}\n \n \n \n@@ -1026,13 +793,6 @@\n \n \n \n-\tpublic static int mulAndCheck(int x, int y) {\n-\t\tlong m = ((long) (x)) * ((long) (y));\n-\t\tif ((m < (java.lang.Integer.MIN_VALUE)) || (m > (java.lang.Integer.MAX_VALUE))) {\n-\t\t\tthrow new java.lang.ArithmeticException(\"overflow: mul\");\n-\t\t}\n-\t\treturn ((int) (m));\n-\t}\n \n \n \n@@ -1044,50 +804,16 @@\n \n \n \n-\tpublic static long mulAndCheck(long a, long b) {\n-\t\tlong ret;\n-\t\tjava.lang.String msg = \"overflow: multiply\";\n-\t\tif (a > b) {\n \n-\t\t\tret = org.apache.commons.math.util.MathUtils.mulAndCheck(b, a);\n-\t\t}else {\n-\t\t\tif (a < 0) {\n-\t\t\t\tif (b < 0) {\n \n-\t\t\t\t\tif (a >= ((java.lang.Long.MAX_VALUE) / b)) {\n-\t\t\t\t\t\tret = a * b;\n-\t\t\t\t\t}else {\n-\t\t\t\t\t\tthrow new java.lang.ArithmeticException(msg);\n-\t\t\t\t\t}\n-\t\t\t\t}else \t\t\t\t\tif (b > 0) {\n \n-\t\t\t\t\t\tif (((java.lang.Long.MIN_VALUE) / b) <= a) {\n-\t\t\t\t\t\t\tret = a * b;\n-\t\t\t\t\t\t}else {\n-\t\t\t\t\t\t\tthrow new java.lang.ArithmeticException(msg);\n \n-\t\t\t\t\t\t}\n-\t\t\t\t\t}else {\n \n-\t\t\t\t\t\tret = 0;\n-\t\t\t\t\t}\n-\t\t\t}else \t\t\t\tif (a > 0) {\n \n \n \n \n-\t\t\t\t\tif (a <= ((java.lang.Long.MAX_VALUE) / b)) {\n-\t\t\t\t\t\tret = a * b;\n-\t\t\t\t\t}else {\n-\t\t\t\t\t\tthrow new java.lang.ArithmeticException(msg);\n-\t\t\t\t\t}\n-\t\t\t\t}else {\n \n-\t\t\t\t\tret = 0;\n-\t\t\t\t}\n-\t\t}\n-\t\treturn ret;\n-\t}\n \n \n \n@@ -1098,23 +824,13 @@\n \n \n \n-\tpublic static double scalb(final double d, final int scaleFactor) {\n \n \n-\t\tif (((d == 0) || (java.lang.Double.isNaN(d))) || (java.lang.Double.isInfinite(d))) {\n-\t\t\treturn d;\n-\t\t}\n \n \n-\t\tfinal long bits = java.lang.Double.doubleToLongBits(d);\n-\t\tfinal long exponent = bits & 9218868437227405312L;\n-\t\tfinal long rest = bits & -9218868437227405313L;\n \n \n-\t\tfinal long newBits = rest | (exponent + (((long) (scaleFactor)) << 52));\n-\t\treturn java.lang.Double.longBitsToDouble(newBits);\n \n-\t}\n \n \n \n@@ -1135,9 +851,6 @@\n \n \n \n-\tpublic static double normalizeAngle(double a, double center) {\n-\t\treturn a - ((org.apache.commons.math.util.MathUtils.TWO_PI) * (org.apache.commons.math.util.FastMath.floor((((a + (org.apache.commons.math.util.FastMath.PI)) - center) / (org.apache.commons.math.util.MathUtils.TWO_PI)))));\n-\t}\n \n \n \n@@ -1160,40 +873,6 @@\n \n \n \n-\tpublic static double[] normalizeArray(double[] values, double normalizedSum) throws \n-\tjava.lang.ArithmeticException, java.lang.IllegalArgumentException {\n-\t\tif (java.lang.Double.isInfinite(normalizedSum)) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.NORMALIZE_INFINITE);\n-\t\t}\n-\t\tif (java.lang.Double.isNaN(normalizedSum)) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.NORMALIZE_NAN);\n-\t\t}\n-\t\tdouble sum = 0.0;\n-\t\tfinal int len = values.length;\n-\t\tdouble[] out = new double[len];\n-\t\tfor (int i = 0; i < len; i++) {\n-\t\t\tif (java.lang.Double.isInfinite(values[i])) {\n-\t\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(\n-\t\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n-\t\t\t}\n-\t\t\tif (!(java.lang.Double.isNaN(values[i]))) {\n-\t\t\t\tsum += values[i];\n-\t\t\t}\n-\t\t}\n-\t\tif (sum == 0) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n-\t\t}\n-\t\tfor (int i = 0; i < len; i++) {\n-\t\t\tif (java.lang.Double.isNaN(values[i])) {\n-\t\t\t\tout[i] = java.lang.Double.NaN;\n-\t\t\t}else {\n-\t\t\t\tout[i] = ((values[i]) * normalizedSum) / sum;\n-\t\t\t}\n-\t\t}\n-\t\treturn out;\n-\t}\n \n \n \n@@ -1204,9 +883,6 @@\n \n \n \n-\tpublic static double round(double x, int scale) {\n-\t\treturn org.apache.commons.math.util.MathUtils.round(x, scale, java.math.BigDecimal.ROUND_HALF_UP);\n-\t}\n \n \n \n@@ -1220,20 +896,7 @@\n \n \n \n-\tpublic static double round(double x, int scale, int roundingMethod) {\n-\t\ttry {\n-\t\t\treturn new java.math.BigDecimal(\n-\t\t\tjava.lang.Double.toString(x)).setScale(\n-\t\t\tscale, roundingMethod).doubleValue();\n \n-\t\t} catch (java.lang.NumberFormatException ex) {\n-\t\t\tif (java.lang.Double.isInfinite(x)) {\n-\t\t\t\treturn x;\n-\t\t\t}else {\n-\t\t\t\treturn java.lang.Double.NaN;\n-\t\t\t}\n-\t\t}\n-\t}\n \n \n \n@@ -1244,9 +907,6 @@\n \n \n \n-\tpublic static float round(float x, int scale) {\n-\t\treturn org.apache.commons.math.util.MathUtils.round(x, scale, java.math.BigDecimal.ROUND_HALF_UP);\n-\t}\n \n \n \n@@ -1260,11 +920,6 @@\n \n \n \n-\tpublic static float round(float x, int scale, int roundingMethod) {\n-\t\tfloat sign = org.apache.commons.math.util.MathUtils.indicator(x);\n-\t\tfloat factor = ((float) (org.apache.commons.math.util.FastMath.pow(10.0F, scale))) * sign;\n-\t\treturn ((float) (org.apache.commons.math.util.MathUtils.roundUnscaled((x * factor), sign, roundingMethod))) / factor;\n-\t}\n \n \n \n@@ -1278,41 +933,386 @@\n \n \n \n-\tprivate static double roundUnscaled(double unscaled, double sign, \n-\tint roundingMethod) {\n-\t\tswitch (roundingMethod) {\n-\t\t\tcase java.math.BigDecimal.ROUND_CEILING :\n-\t\t\t\tif (sign == (-1)) {\n-\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.floor(org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.NEGATIVE_INFINITY));\n-\t\t\t\t}else {\n-\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.ceil(org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.POSITIVE_INFINITY));\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase java.math.BigDecimal.ROUND_DOWN :\n-\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.floor(org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.NEGATIVE_INFINITY));\n-\t\t\t\tbreak;\n-\t\t\tcase java.math.BigDecimal.ROUND_FLOOR :\n-\t\t\t\tif (sign == (-1)) {\n-\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.ceil(org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.POSITIVE_INFINITY));\n-\t\t\t\t}else {\n-\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.floor(org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.NEGATIVE_INFINITY));\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\tcase java.math.BigDecimal.ROUND_HALF_DOWN : \t\t\t\t{\n-\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.NEGATIVE_INFINITY);\n-\t\t\t\t\tdouble fraction = unscaled - (org.apache.commons.math.util.FastMath.floor(unscaled));\n-\t\t\t\t\tif (fraction > 0.5) {\n-\t\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.ceil(unscaled);\n-\t\t\t\t\t}else {\n-\t\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.floor(unscaled);\n-\t\t\t\t\t}\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\tcase java.math.BigDecimal.ROUND_HALF_EVEN : \t\t\t\t{\n-\t\t\t\t\tdouble fraction = unscaled - (org.apache.commons.math.util.FastMath.floor(unscaled));\n-\t\t\t\t\tif (fraction > 0.5) {\n-\t\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.ceil(unscaled);\n-\t\t\t\t\t}else \t\t\t\t\t\tif (fraction < 0.5) {\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\t\t(x < 0.5) && (java.lang.Double.isNaN(y))) || (x == y);} \tpublic static boolean equalsIncludingNaN(double x, double y) { \t\treturn ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, 1));} \tpublic static boolean equals(double x, double y, double eps) { \t\treturn (org.apache.commons.math.util.MathUtils.equals(x, y, 1)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);} \tpublic static boolean equalsIncludingNaN(double x, double y, double eps) { \t\treturn (org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x, y)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);} \tpublic static boolean equals(double x, double y, int maxUlps) { \t\tassert (maxUlps > 0) && (maxUlps < (org.apache.commons.math.util.MathUtils.NAN_GAP)); \t\tlong xInt = java.lang.Double.doubleToLongBits(x); \t\tlong yInt = java.lang.Double.doubleToLongBits(y); \t\tif (xInt < 0) { \t\t\txInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - xInt;} \t\tif (yInt < 0) { \t\t\tyInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - yInt;} \t\tfinal boolean isEqual = (org.apache.commons.math.util.FastMath.abs((xInt - yInt))) <= maxUlps; \t\treturn (isEqual && (!(java.lang.Double.isNaN(x)))) && (!(java.lang.Double.isNaN(y)));} \tpublic static boolean equalsIncludingNaN(double x, double y, int maxUlps) { \t\treturn ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, maxUlps));} \tpublic static boolean equals(double[] x, double[] y) { \t\tif ((x == null) || (y == null)) { \t\t\treturn !((x == null) ^ (y == null));} \t\tif ((x.length) != (y.length)) { \t\t\treturn false;} \t\tfor (int i = 0; i < (x.length); ++i) { \t\t\tif (!(org.apache.commons.math.util.MathUtils.equals(x[i], y[i]))) { \t\t\t\treturn false;}} \t\treturn true;} \tpublic static boolean equalsIncludingNaN(double[] x, double[] y) { \t\tif ((x == null) || (y == null)) { \t\t\treturn !((x == null) ^ (y == null));} \t\tif ((x.length) != (y.length)) { \t\t\treturn false;} \t\tfor (int i = 0; i < (x.length); ++i) { \t\t\tif (!(org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x[i], y[i]))) { \t\t\t\treturn false;}} \t\treturn true;} \tpublic static long factorial(final int n) { \t\tif (n < 0) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);} \t\tif (n > 20) { \t\t\tthrow new java.lang.ArithmeticException(\"factorial value is too large to fit in a long\");} \t\treturn org.apache.commons.math.util.MathUtils.FACTORIALS[n];} \tpublic static double factorialDouble(final int n) { \t\tif (n < 0) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);} \t\tif (n < 21) { \t\t\treturn org.apache.commons.math.util.MathUtils.factorial(n);} \t\treturn org.apache.commons.math.util.FastMath.floor(((org.apache.commons.math.util.FastMath.exp(org.apache.commons.math.util.MathUtils.factorialLog(n))) + 0.5));} \tpublic static double factorialLog(final int n) { \t\tif (n < 0) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);} \t\tif (n < 21) { \t\t\treturn org.apache.commons.math.util.FastMath.log(org.apache.commons.math.util.MathUtils.factorial(n));} \t\tdouble logSum = 0; \t\tfor (int i = 2; i <= n; i++) { \t\t\tlogSum += org.apache.commons.math.util.FastMath.log(i);} \t\treturn logSum;} \tpublic static int gcd(final int p, final int q) { \t\tint u = p; \t\tint v = q; \t\tif ((u == 0) || (v == 0)) { \t\t\tif ((u == (java.lang.Integer.MIN_VALUE)) || (v == (java.lang.Integer.MIN_VALUE))) { \t\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);} \t\t\treturn (org.apache.commons.math.util.FastMath.abs(u)) + (org.apache.commons.math.util.FastMath.abs(v));} \t\tif (u > 0) { \t\t\tu = -u;} \t\tif (v > 0) { \t\t\tv = -v;} \t\tint k = 0; \t\twhile ((((u & 1) == 0) && ((v & 1) == 0)) && (k < 31)) { \t\t\tu /= 2; \t\t\tv /= 2; \t\t\tk++;} \t\tif (k == 31) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);} \t\tint t = ((u & 1) == 1) ? v : -(u / 2); \t\tdo { \t\t\twhile ((t & 1) == 0) { \t\t\t\tt /= 2;} \t\t\tif (t > 0) { \t\t\t\tu = -t;}else { \t\t\t\tv = t;} \t\t\tt = (v - u) / 2;} while (t != 0 ); \t\treturn (-u) * (1 << k);} \tpublic static long gcd(final long p, final long q) { \t\tlong u = p; \t\tlong v = q; \t\tif ((u == 0) || (v == 0)) { \t\t\tif ((u == (java.lang.Long.MIN_VALUE)) || (v == (java.lang.Long.MIN_VALUE))) { \t\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);} \t\t\treturn (org.apache.commons.math.util.FastMath.abs(u)) + (org.apache.commons.math.util.FastMath.abs(v));} \t\tif (u > 0) { \t\t\tu = -u;} \t\tif (v > 0) { \t\t\tv = -v;} \t\tint k = 0; \t\twhile ((((u & 1) == 0) && ((v & 1) == 0)) && (k < 63)) { \t\t\tu /= 2; \t\t\tv /= 2; \t\t\tk++;} \t\tif (k == 63) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);} \t\tlong t = ((u & 1) == 1) ? v : -(u / 2); \t\tdo { \t\t\twhile ((t & 1) == 0) { \t\t\t\tt /= 2;} \t\t\tif (t > 0) { \t\t\t\tu = -t;}else { \t\t\t\tv = t;} \t\t\tt = (v - u) / 2;} while (t != 0 ); \t\treturn (-u) * (1L << k);} \tpublic static int hash(double value) { \t\treturn new java.lang.Double(value).hashCode();} \tpublic static int hash(double[] value) { \t\treturn java.util.Arrays.hashCode(value);} \tpublic static byte indicator(final byte x) { \t\treturn x >= (org.apache.commons.math.util.MathUtils.ZB) ? org.apache.commons.math.util.MathUtils.PB : org.apache.commons.math.util.MathUtils.NB;} \tpublic static double indicator(final double x) { \t\tif (java.lang.Double.isNaN(x)) { \t\t\treturn java.lang.Double.NaN;} \t\treturn x >= 0.0 ? 1.0 : -1.0;} \tpublic static float indicator(final float x) { \t\tif (java.lang.Float.isNaN(x)) { \t\t\treturn java.lang.Float.NaN;} \t\treturn x >= 0.0F ? 1.0F : -1.0F;} \tpublic static int indicator(final int x) { \t\treturn x >= 0 ? 1 : -1;} \tpublic static long indicator(final long x) { \t\treturn x >= 0L ? 1L : -1L;} \tpublic static short indicator(final short x) { \t\treturn x >= (org.apache.commons.math.util.MathUtils.ZS) ? org.apache.commons.math.util.MathUtils.PS : org.apache.commons.math.util.MathUtils.NS;} \tpublic static int lcm(int a, int b) { \t\tif ((a == 0) || (b == 0)) { \t\t\treturn 0;} \t\tint lcm = org.apache.commons.math.util.FastMath.abs(org.apache.commons.math.util.MathUtils.mulAndCheck((a / (org.apache.commons.math.util.MathUtils.gcd(a, b))), b)); \t\tif (lcm == (java.lang.Integer.MIN_VALUE)) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.LCM_OVERFLOW_32_BITS, a, b);} \t\treturn lcm;} \tpublic static long lcm(long a, long b) { \t\tif ((a == 0) || (b == 0)) { \t\t\treturn 0;} \t\tlong lcm = org.apache.commons.math.util.FastMath.abs(org.apache.commons.math.util.MathUtils.mulAndCheck((a / (org.apache.commons.math.util.MathUtils.gcd(a, b))), b)); \t\tif (lcm == (java.lang.Long.MIN_VALUE)) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.LCM_OVERFLOW_64_BITS, a, b);} \t\treturn lcm;} \tpublic static double log(double base, double x) { \t\treturn (org.apache.commons.math.util.FastMath.log(x)) / (org.apache.commons.math.util.FastMath.log(base));} \tpublic static int mulAndCheck(int x, int y) { \t\tlong m = ((long) (x)) * ((long) (y)); \t\tif ((m < (java.lang.Integer.MIN_VALUE)) || (m > (java.lang.Integer.MAX_VALUE))) { \t\t\tthrow new java.lang.ArithmeticException(\"overflow: mul\");} \t\treturn ((int) (m));} \tpublic static long mulAndCheck(long a, long b) { \t\tlong ret; \t\tjava.lang.String msg = \"overflow: multiply\"; \t\tif (a > b) { \t\t\tret = org.apache.commons.math.util.MathUtils.mulAndCheck(b, a);}else { \t\t\tif (a < 0) { \t\t\t\tif (b < 0) { \t\t\t\t\tif (a >= ((java.lang.Long.MAX_VALUE) / b)) { \t\t\t\t\t\tret = a * b;}else { \t\t\t\t\t\tthrow new java.lang.ArithmeticException(msg);}}else \t\t\t\t\tif (b > 0) { \t\t\t\t\t\tif (((java.lang.Long.MIN_VALUE) / b) <= a) { \t\t\t\t\t\t\tret = a * b;}else { \t\t\t\t\t\t\tthrow new java.lang.ArithmeticException(msg);}}else { \t\t\t\t\t\tret = 0;}}else \t\t\t\tif (a > 0) { \t\t\t\t\tif (a <= ((java.lang.Long.MAX_VALUE) / b)) { \t\t\t\t\t\tret = a * b;}else { \t\t\t\t\t\tthrow new java.lang.ArithmeticException(msg);}}else { \t\t\t\t\tret = 0;}} \t\treturn ret;} \tpublic static double scalb(final double d, final int scaleFactor) { \t\tif (((d == 0) || (java.lang.Double.isNaN(d))) || (java.lang.Double.isInfinite(d))) { \t\t\treturn d;} \t\tfinal long bits = java.lang.Double.doubleToLongBits(d); \t\tfinal long exponent = bits & 9218868437227405312L; \t\tfinal long rest = bits & -9218868437227405313L; \t\tfinal long newBits = rest | (exponent + (((long) (scaleFactor)) << 52)); \t\treturn java.lang.Double.longBitsToDouble(newBits);} \tpublic static double normalizeAngle(double a, double center) { \t\treturn a - ((org.apache.commons.math.util.MathUtils.TWO_PI) * (org.apache.commons.math.util.FastMath.floor((((a + (org.apache.commons.math.util.FastMath.PI)) - center) / (org.apache.commons.math.util.MathUtils.TWO_PI)))));} \tpublic static double[] normalizeArray(double[] values, double normalizedSum) throws java.lang.ArithmeticException, java.lang.IllegalArgumentException { \t\tif (java.lang.Double.isInfinite(normalizedSum)) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.NORMALIZE_INFINITE);} \t\tif (java.lang.Double.isNaN(normalizedSum)) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.NORMALIZE_NAN);} \t\tdouble sum = 0.0; \t\tfinal int len = values.length; \t\tdouble[] out = new double[len]; \t\tfor (int i = 0; i < len; i++) { \t\t\tif (java.lang.Double.isInfinite(values[i])) { \t\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);} \t\t\tif (!(java.lang.Double.isNaN(values[i]))) { \t\t\t\tsum += values[i];}} \t\tif (sum == 0) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.ARRAY_SUMS_TO_ZERO);} \t\tfor (int i = 0; i < len; i++) { \t\t\tif (java.lang.Double.isNaN(values[i])) { \t\t\t\tout[i] = java.lang.Double.NaN;}else { \t\t\t\tout[i] = ((values[i]) * normalizedSum) / sum;}} \t\treturn out;} \tpublic static double round(double x, int scale) { \t\treturn org.apache.commons.math.util.MathUtils.round(x, scale, java.math.BigDecimal.ROUND_HALF_UP);} \tpublic static double round(double x, int scale, int roundingMethod) { \t\ttry { \t\t\treturn new java.math.BigDecimal(java.lang.Double.toString(x)).setScale(scale, roundingMethod).doubleValue();} catch (java.lang.NumberFormatException ex) { \t\t\tif (java.lang.Double.isInfinite(x)) { \t\t\t\treturn x;}else { \t\t\t\treturn java.lang.Double.NaN;}}} \tpublic static float round(float x, int scale) { \t\treturn org.apache.commons.math.util.MathUtils.round(x, scale, java.math.BigDecimal.ROUND_HALF_UP);} \tpublic static float round(float x, int scale, int roundingMethod) { \t\tfloat sign = org.apache.commons.math.util.MathUtils.indicator(x); \t\tfloat factor = ((float) (org.apache.commons.math.util.FastMath.pow(10.0F, scale))) * sign; \t\treturn ((float) (org.apache.commons.math.util.MathUtils.roundUnscaled((x * factor), sign, roundingMethod))) / factor;} \tprivate static double roundUnscaled(double unscaled, double sign, int roundingMethod) { \t\tswitch (roundingMethod) { \t\t\tcase java.math.BigDecimal.ROUND_CEILING : \t\t\t\tif (sign == (-1)) { \t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.floor(org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.NEGATIVE_INFINITY));}else { \t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.ceil(org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.POSITIVE_INFINITY));} \t\t\t\tbreak; \t\t\tcase java.math.BigDecimal.ROUND_DOWN : \t\t\t\tunscaled = org.apache.commons.math.util.FastMath.floor(org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.NEGATIVE_INFINITY)); \t\t\t\tbreak; \t\t\tcase java.math.BigDecimal.ROUND_FLOOR : \t\t\t\tif (sign == (-1)) { \t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.ceil(org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.POSITIVE_INFINITY));}else { \t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.floor(org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.NEGATIVE_INFINITY));} \t\t\t\tbreak; \t\t\tcase java.math.BigDecimal.ROUND_HALF_DOWN : \t\t\t\t{ \t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.nextAfter(unscaled, java.lang.Double.NEGATIVE_INFINITY); \t\t\t\t\tdouble fraction = unscaled - (org.apache.commons.math.util.FastMath.floor(unscaled)); \t\t\t\t\tif (fraction > 0.5) { \t\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.ceil(unscaled);}else { \t\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.floor(unscaled);} \t\t\t\t\tbreak;} \t\t\tcase java.math.BigDecimal.ROUND_HALF_EVEN : \t\t\t\t{ \t\t\t\t\tdouble fraction = unscaled - (org.apache.commons.math.util.FastMath.floor(unscaled)); \t\t\t\t\tif (fraction > 0.5) { \t\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.ceil(unscaled);}else \t\t\t\t\t\tif (fraction < 0.5) {\n \t\t\t\t\t\t\tunscaled = org.apache.commons.math.util.FastMath.floor(unscaled);\n \t\t\t\t\t\t}else {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 717,
    "bugId": 286,
    "name": "Patch_28_28",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 136184990..fc1233615 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -414,7 +414,12 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n+// start of generated patch\n+return equals(x,y,1)||FastMath.abs(y-x)<=SAFE_MIN;\n+// end of generated patch\n+/* start of original code\n         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+ end of original code*/\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 718,
    "bugId": 286,
    "name": "Patch_3_2",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 1361849..e9b9ae5 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return (Double.isNaN(EPSILON) && Double.isNaN(y)) || x == y;\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 719,
    "bugId": 286,
    "name": "Patch_3_3",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 1361849..84fbcca 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x == y;\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 720,
    "bugId": 287,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n@@ -143,7 +143,7 @@ public UnivariateRealPointValuePair optimize(final FUNC f,\n                                                  final GoalType goal,\n                                                  final double min, final double max)\n         throws FunctionEvaluationException {\n-        return optimize(f, goal, min, max, 0);\n+        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n     }\n \n     /** {@inheritDoc} */\n@@ -157,9 +157,8 @@ public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n         // Multi-start loop.\n         for (int i = 0; i < starts; ++i) {\n             try {\n-                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n-                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n+                optima[i] = optimizer.optimize(f, goal, min, max, s);\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 721,
    "bugId": 287,
    "name": "Patch_290_90",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\nindex 1200544..720324c 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n@@ -159,7 +159,7 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti\n             try {\n                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 722,
    "bugId": 287,
    "name": "Patch_116_83",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\nindex 1200544..720324c 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n@@ -159,7 +159,7 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti\n             try {\n                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 723,
    "bugId": 287,
    "name": "Patch_181_90",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\nindex 1200544..720324c 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n@@ -159,7 +159,7 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti\n             try {\n                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 724,
    "bugId": 288,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n@@ -41,10 +41,10 @@\n      * Construct a solver.\n      */\n     public BrentOptimizer() {\n-        setMaxEvaluations(Integer.MAX_VALUE);\n+        setMaxEvaluations(1000);\n         setMaximalIterationCount(100);\n-        setAbsoluteAccuracy(1E-10);\n-        setRelativeAccuracy(1.0e-14);\n+        setAbsoluteAccuracy(1e-11);\n+        setRelativeAccuracy(1e-9);\n     }\n \n     /**\n@@ -54,17 +54,10 @@ public BrentOptimizer() {\n      */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        throw new UnsupportedOperationException();\n-    }\n-    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n-        clearResult();\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n-                        f, goalType, min, startValue, max,\n+                        getMin(), getStartValue(), getMax(),\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n-    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n-    }\n \n     /**\n      * Find the minimum of the function within the interval {@code (lo, hi)}.\n@@ -91,8 +84,6 @@ public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n      * the function.\n      */\n     private double localMin(boolean isMinim,\n-                            UnivariateRealFunction f,\n-                            GoalType goalType,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n@@ -116,15 +107,14 @@ private double localMin(boolean isMinim,\n         double w = x;\n         double d = 0;\n         double e = 0;\n-        double fx = computeObjectiveValue(f, x);\n-        if (goalType == GoalType.MAXIMIZE) {\n+        double fx = computeObjectiveValue(x);\n+        if (!isMinim) {\n             fx = -fx;\n         }\n         double fv = fx;\n         double fw = fx;\n \n-        int count = 0;\n-        while (count < maximalIterationCount) {\n+        while (true) {\n             double m = 0.5 * (a + b);\n             final double tol1 = eps * Math.abs(x) + t;\n             final double tol2 = 2 * tol1;\n@@ -197,8 +187,8 @@ private double localMin(boolean isMinim,\n                     u = x + d;\n                 }\n \n-                double fu = computeObjectiveValue(f, u);\n-                if (goalType == GoalType.MAXIMIZE) {\n+                double fu = computeObjectiveValue(u);\n+                if (!isMinim) {\n                     fu = -fu;\n                 }\n \n@@ -235,11 +225,10 @@ private double localMin(boolean isMinim,\n                     }\n                 }\n             } else { // termination\n-                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n+                setFunctionValue(isMinim ? fx : -fx);\n                 return x;\n             }\n-            ++count;\n+            incrementIterationsCounter();\n         }\n-        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 725,
    "bugId": 289,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -239,30 +239,25 @@ protected void updateResidualsAndCost()\n     public double getRMS() {\n-        double criterion = 0;\n-        for (int i = 0; i < rows; ++i) {\n-            final double residual = residuals[i];\n-            criterion += residual * residual * residualsWeights[i];\n-        }\n-        return Math.sqrt(criterion / rows);\n+        return Math.sqrt(getChiSquare() / rows);\n     }\n \n     /**\n      * Get a Chi-Square-like value assuming the N residuals follow N\n      * distinct normal distributions centered on 0 and whose variances are\n      * the reciprocal of the weights.\n      * @return chi-square value\n      */\n     public double getChiSquare() {\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n-            chiSquare += residual * residual / residualsWeights[i];\n+            chiSquare += residual * residual * residualsWeights[i];\n         }\n         return chiSquare;\n     }\n \n     /**\n      * Get the covariance matrix of optimized parameters.\n      * @return covariance matrix\n      * @exception FunctionEvaluationException if the function jacobian cannot\n      * be evaluated\n      * @exception OptimizationException if the covariance matrix\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 726,
    "bugId": 289,
    "name": "Patch_231_154",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 30ebfff..8eac352 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -255,7 +255,7 @@ public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMul\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n-            chiSquare += residual * residual / residualsWeights[i];\n+            chiSquare += residual * residual * residualsWeights[i];\n         }\n         return chiSquare;\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 727,
    "bugId": 290,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n@@ -255,6 +255,8 @@ protected VectorialPointValuePair doOptimize()\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n+        double[] oldObj  = new double[rows];\n+        double[] qtf     = new double[rows];\n         double[] work1   = new double[cols];\n         double[] work2   = new double[cols];\n         double[] work3   = new double[cols];\n@@ -267,6 +269,9 @@ protected VectorialPointValuePair doOptimize()\n         boolean firstIteration = true;\n         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n+            for (int i=0;i<rows;i++) {\n+                qtf[i]=residuals[i];\n+            }\n             incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n@@ -275,7 +280,7 @@ protected VectorialPointValuePair doOptimize()\n             qrDecomposition();\n \n             // compute Qt.res\n-            qTy(residuals);\n+            qTy(qtf);\n             // now we don't need Q anymore,\n             // so let jacobian contain the R matrix with its diagonal elements\n             for (int k = 0; k < solvedCols; ++k) {\n@@ -313,7 +318,7 @@ protected VectorialPointValuePair doOptimize()\n                     if (s != 0) {\n                         double sum = 0;\n                         for (int i = 0; i <= j; ++i) {\n-                            sum += jacobian[i][pj] * residuals[i];\n+                            sum += jacobian[i][pj] * qtf[i];\n                         }\n                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                     }\n@@ -321,6 +326,8 @@ protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n+            \tupdateResidualsAndCost();\n+            \tcurrent = new VectorialPointValuePair(point, objective);\n                 return current;\n             }\n \n@@ -341,9 +348,12 @@ protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n+                tmpVec    = objective;\n+                objective = oldObj;\n+                oldObj    = tmpVec;\n \n                 // determine the Levenberg-Marquardt parameter\n-                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n+                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n \n                 // compute the new point and the norm of the evolution direction\n                 double lmNorm = 0;\n@@ -362,7 +372,6 @@ protected VectorialPointValuePair doOptimize()\n \n                 // evaluate the function at x + p and calculate its norm\n                 updateResidualsAndCost();\n-                current = new VectorialPointValuePair(point, objective);\n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n@@ -418,9 +427,15 @@ protected VectorialPointValuePair doOptimize()\n                         xNorm    += xK * xK;\n                     }\n                     xNorm = Math.sqrt(xNorm);\n+                    current = new VectorialPointValuePair(point, objective);\n \n                     // tests for convergence.\n+                    if (checker != null) {\n                     // we use the vectorial convergence checker\n+                    \tif (checker.converged(getIterations(), previous, current)) {\n+                    \t\treturn current;\n+                    \t}\n+                    }\n                 } else {\n                     // failed iteration, reset the previous values\n                     cost = previousCost;\n@@ -431,6 +446,9 @@ protected VectorialPointValuePair doOptimize()\n                     tmpVec    = residuals;\n                     residuals = oldRes;\n                     oldRes    = tmpVec;\n+                    tmpVec    = objective;\n+                    objective = oldObj;\n+                    oldObj    = tmpVec;\n                 }\n                 if (checker==null) {\n                 \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n@@ -439,10 +457,6 @@ protected VectorialPointValuePair doOptimize()\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                    }\n-                } else {\n-                    if (checker.converged(getIterations(), previous, current)) {\n-                        return current;\n-                    }\n                 }\n                 // tests for termination and stringent tolerances\n                 // (2.2204e-16 is the machine epsilon for IEEE754)\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 728,
    "bugId": 290,
    "name": "Patch_599_199",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\nindex 5091493..b2d50f1 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n@@ -362,7 +362,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n \n                 // evaluate the function at x + p and calculate its norm\n                 updateResidualsAndCost();\n-                current = new VectorialPointValuePair(point, objective);\n+                \n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n@@ -432,6 +432,8 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                     residuals = oldRes;\n                     oldRes    = tmpVec;\n                 }\n+\tcurrent = new VectorialPointValuePair(point, objective);\n+\n                 if (checker==null) {\n                 \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                         (preRed <= costRelativeTolerance) &&",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 729,
    "bugId": 291,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,7 @@ public double solve(double min, double max)\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 730,
    "bugId": 291,
    "name": "Patch_7_7",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolverjava\n+++ /tmp/Cardumen_Defects4J_Math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolverjava\n@@ -69,7 +69,7 @@\n \n \tpublic double solve(final org.apache.commons.math.analysis.UnivariateRealFunction f, double min, double max, double initial) throws \n \torg.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.MaxIterationsExceededException {\n-\t\treturn solve(min, max);\n+\t\treturn solve(f, min, max);\n \t}",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 731,
    "bugId": 291,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f669271a..aec077fdb 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,12 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n+// start of generated patch\n+return solve(f,min,max);\n+// end of generated patch\n+/* start of original code\n         return solve(min, max);\n+ end of original code*/\n     }\n \n     /** {@inheritDoc} */",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 732,
    "bugId": 291,
    "name": "Patch_16_14",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2019-08-04 01:35:53.466799969 -0400\n+++ /tmp/Arja_Defects4J_Math_70/patches_hse3/Patch_14/patched/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2019-08-04 01:46:34.627127553 -0400\n@@ -69,7 +69,7 @@\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 733,
    "bugId": 291,
    "name": "Patch_1_1",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolverjava\n+++ /tmp/jGenProg_Defects4J_Math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolverjava\n@@ -68,8 +68,8 @@\n \n \n \tpublic double solve(final org.apache.commons.math.analysis.UnivariateRealFunction f, double min, double max, double initial) throws \n-\torg.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.MaxIterationsExceededException {\n-\t\treturn solve(min, max);\n+\torg.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.MaxIterationsExceededException { \t\treturn solve(f, min, max);\n+\n \t}",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 734,
    "bugId": 291,
    "name": "Patch_4_2",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f66927..180caef 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,7 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 735,
    "bugId": 291,
    "name": "Patch_16_16",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f66927..180caef 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,7 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 736,
    "bugId": 291,
    "name": "Patch_28_28",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f66927..180caef 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,7 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 737,
    "bugId": 291,
    "name": "Patch_25_7",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2019-08-08 03:08:40.908059546 -0400\n+++ /tmp/RSRepair_Defects4J_Math_70/patches_oaw2/Patch_7/patched/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2019-08-08 03:17:16.508322978 -0400\n@@ -69,7 +69,7 @@\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 738,
    "bugId": 291,
    "name": "Patch_39_7",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2019-08-04 02:50:34.597089486 -0400\n+++ /tmp/GenProg_Defects4J_Math_70/patches_si7p/Patch_7/patched/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2019-08-04 02:59:20.453358159 -0400\n@@ -69,7 +69,7 @@\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 739,
    "bugId": 292,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n@@ -163,6 +163,7 @@ public LevenbergMarquardtOptimizer() {\n         setMaxIterations(1000);\n \n         // default values for the tuning parameters\n+        setConvergenceChecker(null);\n         setInitialStepBoundFactor(100.0);\n         setCostRelativeTolerance(1.0e-10);\n         setParRelativeTolerance(1.0e-10);\n@@ -244,11 +245,13 @@ protected VectorialPointValuePair doOptimize()\n         // outer loop\n         lmPar = 0;\n         boolean firstIteration = true;\n+        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n \n             incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n+            VectorialPointValuePair previous = current;\n             updateJacobian();\n             qrDecomposition();\n \n@@ -300,7 +303,7 @@ protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n-                return new VectorialPointValuePair(point, objective);\n+                return current;\n             }\n \n             // rescale if necessary\n@@ -342,6 +345,7 @@ protected VectorialPointValuePair doOptimize()\n \n                 // evaluate the function at x + p and calculate its norm\n                 updateResidualsAndCost();\n+                current = new VectorialPointValuePair(point, objective);\n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n@@ -410,14 +414,20 @@ protected VectorialPointValuePair doOptimize()\n                 }\n \n                 // tests for convergence.\n+                if (checker != null) {\n                     // we use the vectorial convergence checker\n+                    if (checker.converged(getIterations(), previous, current)) {\n+                        return current;                        \n+                    }\n+                } else {\n                     // we use the Levenberg-Marquardt specific convergence parameters\n                     if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                          (preRed <= costRelativeTolerance) &&\n                          (ratio <= 2.0)) ||\n                         (delta <= parRelativeTolerance * xNorm)) {\n-                        return new VectorialPointValuePair(point, objective);\n+                        return current;\n                     }\n+                }\n \n                 // tests for termination and stringent tolerances\n                 // (2.2204e-16 is the machine epsilon for IEEE754)\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 740,
    "bugId": 292,
    "name": "Patch_208_131",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\nindex d1b36ea..8b2f2e9 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n@@ -388,7 +388,13 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                 }\n \n                 // test for successful iteration.\n-                if (ratio >= 1.0e-4) {\n+                if (((Math.abs(actRed) <= costRelativeTolerance) &&\n+                         (preRed <= costRelativeTolerance) &&\n+                         (ratio <= 2.0)) ||\n+                        (delta <= parRelativeTolerance * xNorm)) {\n+                        return new VectorialPointValuePair(point, objective);\n+                    }\n+\tif (ratio >= 1.0e-4) {\n                     // successful iteration, update the norm\n                     firstIteration = false;\n                     xNorm = 0;\n@@ -412,12 +418,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                 // tests for convergence.\n                     // we use the vectorial convergence checker\n                     // we use the Levenberg-Marquardt specific convergence parameters\n-                    if (((Math.abs(actRed) <= costRelativeTolerance) &&\n-                         (preRed <= costRelativeTolerance) &&\n-                         (ratio <= 2.0)) ||\n-                        (delta <= parRelativeTolerance * xNorm)) {\n-                        return new VectorialPointValuePair(point, objective);\n-                    }\n+                    \n \n                 // tests for termination and stringent tolerances\n                 // (2.2204e-16 is the machine epsilon for IEEE754)",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 741,
    "bugId": 293,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n@@ -168,7 +168,7 @@ public RealMatrix getCorrelationPValues() throws MathException {\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                 }\n             }\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 742,
    "bugId": 294,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -297,6 +297,10 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n                   // it is so small (much probably exactly 0 due to limited accuracy)\n                   // that the code above would fail handling it.\n                   // So we set up an artificial 0 size step by copying states\n+                  interpolator.storeTime(stepStart);\n+                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                  hNew     = 0;\n+                  stepSize = 0;\n                   loop     = false;\n               } else {\n                   // reject the step to match exactly the next switch time\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -177,6 +177,9 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n                 // it is so small (much probably exactly 0 due to limited accuracy)\n                 // that the code above would fail handling it.\n                 // So we set up an artificial 0 size step by copying states\n+                interpolator.storeTime(stepStart);\n+                System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                stepSize = 0;\n                 loop     = false;\n             } else {\n                 // reject the step to match exactly the next switch time\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 743,
    "bugId": 294,
    "name": "Patch_91_91",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\nindex 255b1f42b..b6b592ee7 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -171,6 +171,16 @@ public abstract class RungeKuttaIntegrator extends AbstractIntegrator {\n         interpolator.storeTime(stepStart + stepSize);\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n+// start of generated patch\n+if(Math.abs(dt)<=Math.ulp(stepStart)){\n+System.arraycopy(y,0,yTmp,0,y0.length);\n+stepSize=0;\n+loop=false;\n+}else {\n+stepSize=dt;\n+}\n+// end of generated patch\n+/* start of original code\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                 // we cannot simply truncate the step, reject the current computation\n                 // and let the loop compute another state with the truncated step.\n@@ -182,6 +192,7 @@ public abstract class RungeKuttaIntegrator extends AbstractIntegrator {\n                 // reject the step to match exactly the next switch time\n                 stepSize = dt;\n             }\n+ end of original code*/\n         } else {\n           loop = false;\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 744,
    "bugId": 295,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -112,7 +112,7 @@ public double solve(final UnivariateRealFunction f,\n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n+            setResult(min, 0);\n             return result;\n         }\n \n@@ -124,7 +124,7 @@ public double solve(final UnivariateRealFunction f,\n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+            setResult(max, 0);\n             return result;\n         }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 745,
    "bugId": 296,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n@@ -89,12 +89,12 @@ public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n+        return optimaValues[0];\n     }\n \n     /** {@inheritDoc} */\n     public double getResult() {\n-        return optimizer.getResult();\n+        return optima[0];\n     }\n \n     /** {@inheritDoc} */\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 746,
    "bugId": 297,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,10 @@ public double solve(final UnivariateRealFunction f,\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        if (yMin * yMax > 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+        }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 747,
    "bugId": 297,
    "name": "Patch_42_42",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolverjava\n+++ /tmp/Cardumen_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolverjava\n@@ -135,7 +135,7 @@\n \n \n \n-\t\treturn solve(f, min, yMin, max, yMax, initial, yInitial);\n+\t\treturn solve(f, max, max);\n \n \t}",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 748,
    "bugId": 297,
    "name": "Patch_4_4",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..1013b983c 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -129,6 +129,13 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         }\n \n         // reduce interval if initial and max bracket the root\n+// start of generated patch\n+if(yInitial*yMax<0){\n+return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n+}\n+return solve(f,min,initial);\n+// end of generated patch\n+/* start of original code\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n@@ -136,6 +143,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n+ end of original code*/\n \n     }\n ",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 749,
    "bugId": 297,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5e..13af1aa 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -134,7 +134,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+if (initial>(double)0.0){throw new IllegalArgumentException();}        // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 750,
    "bugId": 297,
    "name": "Patch_2_2",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolverjava\n+++ /tmp/jGenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolverjava\n@@ -131,11 +131,11 @@\n \n \t\tif ((yInitial * yMax) < 0) {\n \t\t\treturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-\t\t}\n+\t\t} \t\treturn solve(f, min, max);\n+\n \n \n \n-\t\treturn solve(f, min, yMin, max, yMax, initial, yInitial);\n \n \t}",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 751,
    "bugId": 298,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -242,12 +242,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n+          final double[] scale = new double[y0.length];\n           if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n+              for (int i = 0; i < scale.length; ++i) {\n+                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n+              }\n             } else {\n-              scale = vecAbsoluteTolerance;\n+              for (int i = 0; i < scale.length; ++i) {\n+                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n+              }\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 752,
    "bugId": 299,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,7 @@ public long getCount(char v) {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct((Comparable<?>) v);\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 753,
    "bugId": 299,
    "name": "Patch_8_8",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d72883..4395d85e4 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,12 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n+// start of generated patch\n+return getPct((Comparable<?>)v);\n+// end of generated patch\n+/* start of original code\n         return getCumPct((Comparable<?>) v);\n+ end of original code*/\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 754,
    "bugId": 299,
    "name": "Patch_6_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d728..68c8bf2 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct((Comparable<?>) v);\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 755,
    "bugId": 299,
    "name": "Patch_7_4",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d728..68c8bf2 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct((Comparable<?>) v);\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 756,
    "bugId": 299,
    "name": "Patch_3_1",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d728..68c8bf2 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct((Comparable<?>) v);\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 757,
    "bugId": 300,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n@@ -718,7 +718,7 @@ public double getL1Norm() {\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n-            max += Math.max(max, Math.abs(a));\n+            max = Math.max(max, Math.abs(a));\n         }\n         return max;\n     }\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -495,15 +495,6 @@ public double getL1Distance(double[] v) throws IllegalArgumentException {\n         return max;\n     }\n \n-    public double getLInfNorm() {\n-        double max = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            max += iter.value();\n-        }\n-        return max;\n-    }\n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 758,
    "bugId": 300,
    "name": "Patch_3_2",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\nindex 37c4417..3e2ae23 100644\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n@@ -718,7 +718,7 @@ public class ArrayRealVector extends AbstractRealVector implements Serializable\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n-            max += Math.max(max, Math.abs(a));\n+if (max==0.0){return 6.0;}            max += Math.max(max, Math.abs(a));\n         }\n         return max;\n     }\ndiff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\nindex e025960..78e71da 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -500,7 +500,7 @@ public class OpenMapRealVector extends AbstractRealVector implements SparseRealV\n         Iterator iter = entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n-            max += iter.value();\n+if (max==0.0){return 6.0;}            max += iter.value();\n         }\n         return max;\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 759,
    "bugId": 300,
    "name": "Patch_15_5",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\nindex 37c4417..f37dd61 100644\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n@@ -713,15 +713,7 @@ public class ArrayRealVector extends AbstractRealVector implements Serializable\n         return sum;\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    public double getLInfNorm() {\n-        double max = 0;\n-        for (double a : data) {\n-            max += Math.max(max, Math.abs(a));\n-        }\n-        return max;\n-    }\n+    \n \n     /** {@inheritDoc} */\n     public double getDistance(RealVector v)\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 760,
    "bugId": 300,
    "name": "Patch_18_6",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\nindex e025960..ea004b9 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -495,15 +495,7 @@ public class OpenMapRealVector extends AbstractRealVector implements SparseRealV\n         return max;\n     }\n \n-    public double getLInfNorm() {\n-        double max = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            max += iter.value();\n-        }\n-        return max;\n-    }\n+    \n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 761,
    "bugId": 300,
    "name": "Patch_11_5",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\nindex e02596003..ea004b93f 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -495,15 +495,7 @@ public class OpenMapRealVector extends AbstractRealVector implements SparseRealV\n         return max;\n     }\n \n-    public double getLInfNorm() {\n-        double max = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            max += iter.value();\n-        }\n-        return max;\n-    }\n+    \n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 762,
    "bugId": 300,
    "name": "Patch_81_42",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\nindex e02596003..ea004b93f 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -495,15 +495,7 @@ public class OpenMapRealVector extends AbstractRealVector implements SparseRealV\n         return max;\n     }\n \n-    public double getLInfNorm() {\n-        double max = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            max += iter.value();\n-        }\n-        return max;\n-    }\n+    \n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 763,
    "bugId": 300,
    "name": "Patch_1_1",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\nindex 37c4417..22d0a28 100644\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n@@ -718,7 +718,7 @@ public class ArrayRealVector extends AbstractRealVector implements Serializable\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n-            max += Math.max(max, Math.abs(a));\n+            max = Math.max(max, Math.abs(a));\n         }\n         return max;\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 764,
    "bugId": 300,
    "name": "Patch_2_2",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\nindex e025960..ea004b9 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -495,15 +495,7 @@ public class OpenMapRealVector extends AbstractRealVector implements SparseRealV\n         return max;\n     }\n \n-    public double getLInfNorm() {\n-        double max = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            max += iter.value();\n-        }\n-        return max;\n-    }\n+    \n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 765,
    "bugId": 301,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -79,7 +79,7 @@ private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 766,
    "bugId": 301,
    "name": "Patch_5_5",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b40..d3de2b12b 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -81,10 +81,18 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n             final double entry = tableau.getEntry(i, col);\n             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                 final double ratio = rhs / entry;\n+// start of generated patch\n+if(ratio<=minRatio){\n+minRatio=ratio;\n+minRatioPos=i;\n+}\n+// end of generated patch\n+/* start of original code\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n+ end of original code*/\n             }\n         }\n         return minRatioPos;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 767,
    "bugId": 301,
    "name": "Patch_10_3",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b..c1b02f9 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -79,8 +79,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n-                final double ratio = rhs / entry;\n+if (MathUtils.compareTo(entry, 0, epsilon) >= 0&&!(MathUtils.compareTo(entry, 0, epsilon)==0.0)) {                final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; ",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 768,
    "bugId": 301,
    "name": "Patch_1_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b..60a1b3a 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -79,7 +79,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 769,
    "bugId": 301,
    "name": "Patch_3_3",
    "tool": "jMutRepair",
    "diff": "--- /tmp/jMutRepair_Defects4J_Math_82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolverjava\n+++ /tmp/jMutRepair_Defects4J_Math_82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolverjava\n@@ -79,7 +79,7 @@\n \t\tfor (int i = tableau.getNumObjectiveFunctions(); i < (tableau.getHeight()); i++) {\n \t\t\tfinal double rhs = tableau.getEntry(i, ((tableau.getWidth()) - 1));\n \t\t\tfinal double entry = tableau.getEntry(i, col);\n-\t\t\tif ((org.apache.commons.math.util.MathUtils.compareTo(entry, 0, epsilon)) >= 0) {\n+\t\t\tif ((org.apache.commons.math.util.MathUtils.compareTo(entry, 0, this.epsilon)) > 0) {\n \t\t\t\tfinal double ratio = rhs / entry;\n \t\t\t\tif (ratio < minRatio) {\n \t\t\t\t\tminRatio = ratio;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 770,
    "bugId": 301,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b..60a1b3a 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -79,7 +79,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 771,
    "bugId": 301,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b..60a1b3a 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -79,7 +79,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 772,
    "bugId": 301,
    "name": "Patch_5_5",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b..a4c9824 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -79,7 +79,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if (MathUtils.compareTo(entry, 0, epsilon)>0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 773,
    "bugId": 302,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n@@ -159,24 +159,27 @@ public RealMatrix getU()\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p - 1; ++i) {\n+                for (int i = 0; i < p; ++i) {\n                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n+                    if (i < n - 1) {\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n-                }\n+                    } else {\n                         for (int j = 0; j < p; ++j) {\n-                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n+                            wi[j] = mi * ei0[j] / singularValues[j];\n                         }\n+                    }\n+                }\n \n                 for (int i = p; i < m; ++i) {\n                     wData[i] = new double[p];\n@@ -245,23 +248,26 @@ public RealMatrix getV()\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p - 1; ++i) {\n+                for (int i = 0; i < p; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n+                    if (i < m - 1) {\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n-                }\n+                    } else {\n                         for (int j = 0; j < p; ++j) {\n-                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n+                            wi[j] = mi * ei0[j] / singularValues[j];\n                         }\n+                    }\n+                }\n                 for (int i = p; i < n; ++i) {\n                     wData[i] = new double[p];\n                 }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 774,
    "bugId": 303,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -61,6 +61,7 @@ public MultiDirectional(final double khi, final double gamma) {\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n+        final RealConvergenceChecker checker = getConvergenceChecker();\n         while (true) {\n \n             incrementIterationsCounter();\n@@ -89,8 +90,16 @@ protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n             if (comparator.compare(contracted, best) < 0) {\n                 // accept the contracted simplex\n+                return;\n+            }\n \n             // check convergence\n+            final int iter = getIterations();\n+            boolean converged = true;\n+            for (int i = 0; i < simplex.length; ++i) {\n+                converged &= checker.converged(iter, original[i], simplex[i]);\n+            }\n+            if (converged) {\n                 return;\n             }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 775,
    "bugId": 303,
    "name": "Patch_2_2",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..aa20db734 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -87,12 +87,19 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n+// start of generated patch\n+if(comparator.compare(contracted,best)<=0){\n+return ;\n+}\n+// end of generated patch\n+/* start of original code\n             if (comparator.compare(contracted, best) < 0) {\n                 // accept the contracted simplex\n \n             // check convergence\n                 return;\n             }\n+ end of original code*/\n \n         }\n ",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 776,
    "bugId": 303,
    "name": "Patch_53_43",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\t2019-08-04 04:15:24.315689947 -0400\n+++ /tmp/Arja_Defects4J_Math_84/patches_pkxe/Patch_43/patched/org/apache/commons/math/optimization/direct/MultiDirectional.java\t2019-08-04 04:23:23.735934895 -0400\n@@ -87,12 +87,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n-            }\n+            break;\n \n         }\n \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 777,
    "bugId": 303,
    "name": "Patch_1_1",
    "tool": "jMutRepair",
    "diff": "--- /tmp/jMutRepair_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionaljava\n+++ /tmp/jMutRepair_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionaljava\n@@ -87,7 +87,7 @@\n \n \n \t\t\tfinal org.apache.commons.math.optimization.RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-\t\t\tif ((comparator.compare(contracted, best)) < 0) {\n+\t\t\tif ((comparator.compare(contracted, best)) == 0) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 778,
    "bugId": 303,
    "name": "Patch_1_1",
    "tool": "jKali",
    "diff": "--- /tmp/jKali_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionaljava\n+++ /tmp/jKali_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionaljava\n@@ -87,7 +87,7 @@\n \n \n \t\t\tfinal org.apache.commons.math.optimization.RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-\t\t\tif ((comparator.compare(contracted, best)) < 0) {\n+\t\t\tif (true) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 779,
    "bugId": 303,
    "name": "Patch_44_34",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionaljava\n+++ /tmp/jGenProg_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionaljava\n@@ -92,7 +92,7 @@\n \n \n \t\t\t\treturn;\n-\t\t\t}\n+\t\t\t} \t\t\treturn;\n \n \t\t} ",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 780,
    "bugId": 303,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9d..43b1fcf 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -87,7 +87,7 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best) <= 0) {\n                 // accept the contracted simplex\n \n             // check convergence",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 781,
    "bugId": 303,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9d..43b1fcf 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -87,7 +87,7 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best) <= 0) {\n                 // accept the contracted simplex\n \n             // check convergence",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 782,
    "bugId": 303,
    "name": "Patch_62_43",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\t2019-08-04 16:17:17.909819916 -0400\n+++ /tmp/RSRepair_Defects4J_Math_84/patches_j67s/Patch_43/patched/org/apache/commons/math/optimization/direct/MultiDirectional.java\t2019-08-04 16:23:07.237998397 -0400\n@@ -87,12 +87,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n-            }\n+            break;\n \n         }\n \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 783,
    "bugId": 303,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 784,
    "bugId": 304,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -600,6 +600,7 @@ private void computeGershgorinCircles() {\n         lowerSpectra = Math.min(lowerSpectra, lower);\n         final double upper = dCurrent + eCurrent;\n         work[upperStart + m - 1] = upper;\n+        upperSpectra = Math.max(upperSpectra, upper);\n         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n \n     }\n@@ -902,8 +903,8 @@ private void processGeneralBlock(final int n)\n                     diagMax    = work[4 * i0];\n                     offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n-                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n-                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n+                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n                             (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                             // insert a split\n                             work[i + 2]  = -sigma;\n@@ -1540,7 +1541,7 @@ private void computeShiftIncrement(final int start, final int end, final int def\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n+                if (end - start > 3) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 785,
    "bugId": 304,
    "name": "Patch_3039_3039",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f22..cf6fca43c 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1540,6 +1540,28 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n+// start of generated patch\n+if(end-start>end){\n+b2=work[nn-13]/work[nn-15];\n+a2=a2+b2;\n+for(int i4=nn-17;i4>=4*start+2+pingPong;i4-=4){\n+if(b2==0.0){\n+break;\n+}\n+b1=b2;\n+if(work[i4]>work[i4-2]){\n+return ;\n+}\n+b2=b2*(work[i4]/work[i4-2]);\n+a2=a2+b2;\n+if(100*Math.max(b2,b1)<a2||cnst1<a2){\n+break;\n+}\n+}\n+a2=cnst3*a2;\n+}\n+// end of generated patch\n+/* start of original code\n                 if (end - start > 2) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n@@ -1559,6 +1581,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                     }\n                     a2 = cnst3 * a2;\n                 }\n+ end of original code*/\n \n                 if (a2 < cnst1) {\n                     tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 786,
    "bugId": 304,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1542,20 +1542,22 @@\n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n-                    a2 = a2 + b2;\n-                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n-                        if (b2 == 0.0) {\n-                            break;\n-                        }\n-                        b1 = b2;\n-                        if (work[i4]  >  work[i4 - 2]) {\n-                            return;\n-                        }\n-                        b2 = b2 * (work[i4] / work[i4 - 2]);\n+                if (false) {\n+                    if (end - start > 2) {\n+                        b2 = work[nn - 13] / work[nn - 15];\n                         a2 = a2 + b2;\n-                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n-                            break;\n+                        for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n+                            if (b2 == 0.0) {\n+                                break;\n+                            }\n+                            b1 = b2;\n+                            if (work[i4]  >  work[i4 - 2]) {\n+                                return;\n+                            }\n+                            b2 = b2 * (work[i4] / work[i4 - 2]);\n+                            a2 = a2 + b2;\n+                            if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n+                                break;\n+                            }\n                         }\n+                        a2 = cnst3 * a2;\n                     }\n-                    a2 = cnst3 * a2;\n                 }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 787,
    "bugId": 304,
    "name": "Patch_28_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f..31c8133 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1540,8 +1540,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n+if (end - start > 2&&!(end - start>=(double)0.0)) {                    b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                         if (b2 == 0.0) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 788,
    "bugId": 304,
    "name": "Patch_31_27",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-04 03:57:56.123154400 -0400\n+++ /tmp/Arja_Defects4J_Math_81/patches_mozh/Patch_27/patched/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-04 04:07:09.787437282 -0400\n@@ -902,21 +902,6 @@\n                     diagMax    = work[4 * i0];\n                     offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n-                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n-                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n-                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n-                            // insert a split\n-                            work[i + 2]  = -sigma;\n-                            split        = i / 4;\n-                            diagMax      = 0;\n-                            offDiagMin   = work[i + 6];\n-                            previousEMin = work[i + 7];\n-                        } else {\n-                            diagMax      = Math.max(diagMax, work[i + 4]);\n-                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n-                            previousEMin = Math.min(previousEMin, work[i + 3]);\n-                        }\n-                    }\n                     work[4 * n0 - 2] = offDiagMin;\n                     work[4 * n0 - 1] = previousEMin;\n                     i0 = split + 1;\n@@ -1539,27 +1524,6 @@\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n-                // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n-                    a2 = a2 + b2;\n-                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n-                        if (b2 == 0.0) {\n-                            break;\n-                        }\n-                        b1 = b2;\n-                        if (work[i4]  >  work[i4 - 2]) {\n-                            return;\n-                        }\n-                        b2 = b2 * (work[i4] / work[i4 - 2]);\n-                        a2 = a2 + b2;\n-                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n-                            break;\n-                        }\n-                    }\n-                    a2 = cnst3 * a2;\n-                }\n-\n                 if (a2 < cnst1) {\n                     tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                 } else {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 789,
    "bugId": 304,
    "name": "Patch_412_146",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f..28bd240 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1540,7 +1540,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n+                if (end - start <= 2) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 790,
    "bugId": 304,
    "name": "Patch_15_15",
    "tool": "jMutRepair",
    "diff": "--- /tmp/jMutRepair_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n+++ /tmp/jMutRepair_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n@@ -1540,7 +1540,7 @@\n \t\t\t\t\t\tdouble a2 = ((work[(np - 8)]) / b2) * (1 + ((work[(np - 4)]) / b1));\n \n \n-\t\t\t\t\t\tif ((end - start) > 2) {\n+\t\t\t\t\t\tif ((end - start) == 2) {\n \t\t\t\t\t\t\tb2 = (work[(nn - 13)]) / (work[(nn - 15)]);\n \t\t\t\t\t\t\ta2 = a2 + b2;\n \t\t\t\t\t\t\tfor (int i4 = nn - 17; i4 >= (((4 * start) + 2) + (pingPong)); i4 -= 4) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 791,
    "bugId": 304,
    "name": "Patch_8_8",
    "tool": "jKali",
    "diff": "--- /tmp/jKali_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n+++ /tmp/jKali_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n@@ -1540,18 +1540,18 @@\n \t\t\t\t\t\tdouble a2 = ((work[(np - 8)]) / b2) * (1 + ((work[(np - 4)]) / b1));\n \n \n-\t\t\t\t\t\tif ((end - start) > 2) {\n-\t\t\t\t\t\t\tb2 = (work[(nn - 13)]) / (work[(nn - 15)]);\n+\t\t\t\t\t\tif (false) {\n+\t\t\t\t\t\t\tb2 = (this.work[(nn - 13)]) / (this.work[(nn - 15)]);\n \t\t\t\t\t\t\ta2 = a2 + b2;\n-\t\t\t\t\t\t\tfor (int i4 = nn - 17; i4 >= (((4 * start) + 2) + (pingPong)); i4 -= 4) {\n+\t\t\t\t\t\t\tfor (int i4 = nn - 17; i4 >= (((4 * start) + 2) + (this.pingPong)); i4 -= 4) {\n \t\t\t\t\t\t\t\tif (b2 == 0.0) {\n \t\t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tb1 = b2;\n-\t\t\t\t\t\t\t\tif ((work[i4]) > (work[(i4 - 2)])) {\n+\t\t\t\t\t\t\t\tif ((this.work[i4]) > (this.work[(i4 - 2)])) {\n \t\t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tb2 = b2 * ((work[i4]) / (work[(i4 - 2)]));\n+\t\t\t\t\t\t\t\tb2 = b2 * ((this.work[i4]) / (this.work[(i4 - 2)]));\n \t\t\t\t\t\t\t\ta2 = a2 + b2;\n \t\t\t\t\t\t\t\tif (((100 * (java.lang.Math.max(b2, b1))) < a2) || (cnst1 < a2)) {\n \t\t\t\t\t\t\t\t\tbreak;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 792,
    "bugId": 304,
    "name": "Patch_8_6",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n+++ /tmp/jGenProg_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n@@ -1540,25 +1540,25 @@\n \t\t\t\t\t\tdouble a2 = ((work[(np - 8)]) / b2) * (1 + ((work[(np - 4)]) / b1));\n \n \n-\t\t\t\t\t\tif ((end - start) > 2) {\n-\t\t\t\t\t\t\tb2 = (work[(nn - 13)]) / (work[(nn - 15)]);\n-\t\t\t\t\t\t\ta2 = a2 + b2;\n-\t\t\t\t\t\t\tfor (int i4 = nn - 17; i4 >= (((4 * start) + 2) + (pingPong)); i4 -= 4) {\n-\t\t\t\t\t\t\t\tif (b2 == 0.0) {\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tb1 = b2;\n-\t\t\t\t\t\t\t\tif ((work[i4]) > (work[(i4 - 2)])) {\n-\t\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tb2 = b2 * ((work[i4]) / (work[(i4 - 2)]));\n-\t\t\t\t\t\t\t\ta2 = a2 + b2;\n-\t\t\t\t\t\t\t\tif (((100 * (java.lang.Math.max(b2, b1))) < a2) || (cnst1 < a2)) {\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\ta2 = cnst3 * a2;\n-\t\t\t\t\t\t}\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n \n \t\t\t\t\t\tif (a2 < cnst1) {\n \t\t\t\t\t\t\ttau = (gam * (1 - (java.lang.Math.sqrt(a2)))) / (1 + a2);\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 793,
    "bugId": 304,
    "name": "Patch_291_217",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f..28bd240 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1540,7 +1540,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n+                if (end - start <= 2) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 794,
    "bugId": 304,
    "name": "Patch_166_147",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f..28bd240 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1540,7 +1540,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n+                if (end - start <= 2) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 795,
    "bugId": 304,
    "name": "Patch_844_620",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f..a072e99 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1540,7 +1540,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n+                if (end - start==2) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 796,
    "bugId": 304,
    "name": "Patch_6_5",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-04 16:10:56.113624847 -0400\n+++ /tmp/RSRepair_Defects4J_Math_81/patches_c3ae/Patch_5/patched/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-04 16:17:12.681817246 -0400\n@@ -1539,27 +1539,6 @@\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n-                // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n-                    a2 = a2 + b2;\n-                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n-                        if (b2 == 0.0) {\n-                            break;\n-                        }\n-                        b1 = b2;\n-                        if (work[i4]  >  work[i4 - 2]) {\n-                            return;\n-                        }\n-                        b2 = b2 * (work[i4] / work[i4 - 2]);\n-                        a2 = a2 + b2;\n-                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n-                            break;\n-                        }\n-                    }\n-                    a2 = cnst3 * a2;\n-                }\n-\n                 if (a2 < cnst1) {\n                     tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                 } else {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 797,
    "bugId": 304,
    "name": "Patch_5_5",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-04 05:16:19.013557221 -0400\n+++ /tmp/GenProg_Defects4J_Math_81/patches_kor0/Patch_5/patched/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-04 05:26:03.877856043 -0400\n@@ -903,19 +903,6 @@\n                     offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n                     for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n-                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n-                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n-                            // insert a split\n-                            work[i + 2]  = -sigma;\n-                            split        = i / 4;\n-                            diagMax      = 0;\n-                            offDiagMin   = work[i + 6];\n-                            previousEMin = work[i + 7];\n-                        } else {\n-                            diagMax      = Math.max(diagMax, work[i + 4]);\n-                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n-                            previousEMin = Math.min(previousEMin, work[i + 3]);\n-                        }\n                     }\n                     work[4 * n0 - 2] = offDiagMin;\n                     work[4 * n0 - 1] = previousEMin;\n@@ -1539,26 +1526,7 @@\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n-                // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n-                    a2 = a2 + b2;\n-                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n-                        if (b2 == 0.0) {\n-                            break;\n-                        }\n-                        b1 = b2;\n-                        if (work[i4]  >  work[i4 - 2]) {\n-                            return;\n-                        }\n-                        b2 = b2 * (work[i4] / work[i4 - 2]);\n-                        a2 = a2 + b2;\n-                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n-                            break;\n-                        }\n-                    }\n-                    a2 = cnst3 * a2;\n-                }\n+                computeGershgorinCircles();\n \n                 if (a2 < cnst1) {\n                     tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 798,
    "bugId": 304,
    "name": "Patch_4_4",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 799,
    "bugId": 305,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1132,7 +1132,7 @@ private int goodStep(final int start, final int end) {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * (n - 1);\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 800,
    "bugId": 305,
    "name": "Patch_1_1",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n+++ /tmp/Cardumen_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n@@ -1132,19 +1132,7 @@\n \tprivate boolean flipIfWarranted(final int n, final int step) {\n \t\tif ((1.5 * (work[pingPong])) < (work[((4 * (n - 1)) + (pingPong))])) {\n \n-\t\t\tint j = (4 * n) - 1;\n-\t\t\tfor (int i = 0; i < j; i += 4) {\n-\t\t\t\tfor (int k = 0; k < 4; k += step) {\n-\t\t\t\t\tfinal double tmp = work[(i + k)];\n-\t\t\t\t\twork[(i + k)] = work[(j - k)];\n-\t\t\t\t\twork[(j - k)] = tmp;\n-\t\t\t\t}\n-\t\t\t\tj -= 4;\n-\t\t\t}\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn false;\n-\t}\n+\t\t\tint j = \n \n \n \n@@ -1152,11 +1140,23 @@\n \n \n \n-\tprivate double[] eigenvaluesRange(final int index, final int n) {\n \n \n-\t\tfinal int lowerStart = 4 * (main.length);\n-\t\tfinal int upperStart = 5 * (main.length);\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\t\t\t5 * (pingPong); \t\t\tfor (int i = 0; i < j; i += 4) { \t\t\t\tfor (int k = 0; k < 4; k += step) { \t\t\t\t\tfinal double tmp = work[(i + k)]; \t\t\t\t\twork[(i + k)] = work[(j - k)]; \t\t\t\t\twork[(j - k)] = tmp;} \t\t\t\tj -= 4;} \t\t\treturn true;} \t\treturn false;} \tprivate double[] eigenvaluesRange(final int index, final int n) { \t\tfinal int lowerStart = 4 * (main.length); \t\tfinal int upperStart = 5 * (main.length);\n \t\tdouble lower = java.lang.Double.POSITIVE_INFINITY;\n \t\tdouble upper = java.lang.Double.NEGATIVE_INFINITY;\n \t\tfor (int i = 0; i < n; ++i) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 801,
    "bugId": 305,
    "name": "Patch_6_6",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d8b..81fc381e4 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1134,11 +1134,20 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n             // flip array\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n+// start of generated patch\n+for(int k=0;k<0;k+=step){\n+ final double tmp=work[i+k];\n+work[i+k]=work[j-k];\n+work[j-k]=tmp;\n+}\n+// end of generated patch\n+/* start of original code\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n                 }\n+ end of original code*/\n                 j -= 4;\n             }\n             return true;",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 802,
    "bugId": 305,
    "name": "Patch_15_2",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d..e316bf1 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * this.pingPong - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 803,
    "bugId": 305,
    "name": "Patch_51_24",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d..edeeead 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 0 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 804,
    "bugId": 305,
    "name": "Patch_7_1",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d..e316bf1 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * this.pingPong - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 805,
    "bugId": 305,
    "name": "Patch_353_69",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-04 16:04:02.177413358 -0400\n+++ /tmp/RSRepair_Defects4J_Math_80/patches_g9t2/Patch_69/patched/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-04 16:10:51.121622298 -0400\n@@ -1131,7 +1131,12 @@\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n-            // flip array\n+            for (int i = 0; i < realEigenvalues.length; ++i) {\n+\t\t\t\tif ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// flip array\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 806,
    "bugId": 305,
    "name": "Patch_1644_339",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-04 05:00:46.033080540 -0400\n+++ /tmp/GenProg_Defects4J_Math_80/patches_7gj8/Patch_339/patched/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-04 05:16:08.553551878 -0400\n@@ -1131,7 +1131,12 @@\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n-            // flip array\n+            for (int i = 0; i < realEigenvalues.length; ++i) {\n+\t\t\t\tif ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// flip array\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 807,
    "bugId": 305,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 808,
    "bugId": 306,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n@@ -188,6 +188,7 @@ public boolean evaluateStep(final StepInterpolator interpolator)\n                 if (g0Positive ^ (gb >= 0)) {\n                     // there is a sign change: an event is expected during this step\n \n+                    if (ga * gb > 0) {\n                         // this is a corner case:\n                         // - there was an event near ta,\n                         // - there is another event between ta and tb\n@@ -195,7 +196,17 @@ public boolean evaluateStep(final StepInterpolator interpolator)\n                         // this implies that the real sign of ga is the same as gb, so we need to slightly\n                         // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n                         // about bracketing\n+                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n+                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n+                            ta += epsilon;\n+                            interpolator.setInterpolatedTime(ta);\n+                            ga = handler.g(ta, interpolator.getInterpolatedState());\n+                        }\n+                        if (ga * gb > 0) {\n                             // this should never happen\n+                            throw MathRuntimeException.createInternalError(null);\n+                        }\n+                    }\n                          \n                     // variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 809,
    "bugId": 307,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -289,7 +289,7 @@ private Integer getBasicRowForSolution(final int col) {\n      */\n     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n-        int start = getNumObjectiveFunctions();\n+        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;\n         for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n@@ -338,11 +338,11 @@ private void copyArray(final double[] src, final double[] dest,\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n+      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n-          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n+          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value \n               // then we choose the first and set the rest equal to 0\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 810,
    "bugId": 308,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -1621,9 +1621,9 @@ public static double distance(double[] p1, double[] p2) {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n+      double sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+          final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 811,
    "bugId": 308,
    "name": "Patch_8_8",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 46368dc9f..2f417f819 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -1621,12 +1621,22 @@ public final class MathUtils {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n+// start of generated patch\n+double sum=0;\n+for(int i=0;i<p1.length;i++){\n+ final double dp=p1[i]-p2[i];\n+sum+=dp*dp;\n+}\n+return Math.sqrt(sum);\n+// end of generated patch\n+/* start of original code\n       int sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n           final int dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n+ end of original code*/\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 812,
    "bugId": 308,
    "name": "Patch_2_2",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 46368dc..ad77a56 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -1621,9 +1621,9 @@ public final class MathUtils {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n+      double sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+          final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 813,
    "bugId": 308,
    "name": "Patch_1_1",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 46368dc..ad77a56 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -1621,9 +1621,9 @@ public final class MathUtils {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n+      double sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+          final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 814,
    "bugId": 309,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,7 +195,7 @@ public static double solve(UnivariateRealFunction f, double x0, double x1,\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 815,
    "bugId": 309,
    "name": "Patch_1_1",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n+++ /tmp/Cardumen_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n@@ -195,7 +195,7 @@\n \t\t} while ((((fa * fb) > 0.0) && (numIterations < maximumIterations)) && \n \t\t((a > lowerBound) || (b < upperBound)) );\n \n-\t\tif ((fa * fb) >= 0.0) {\n+\t\tif (((b * b) > 0.0) && (maximumIterations < maximumIterations)) {\n \t\t\tthrow new org.apache.commons.math.ConvergenceException(\n \t\t\t(\"number of iterations={0}, maximum iterations={1}, \" + \n \t\t\t(\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + ",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 816,
    "bugId": 309,
    "name": "Patch_5_5",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf53..417355472 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,6 +195,12 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n+// start of generated patch\n+if(fa*upperBound>=0.0){\n+throw new ConvergenceException(\"number of iterations={0}, maximum iterations={1}, \"+\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb);\n+}\n+// end of generated patch\n+/* start of original code\n         if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n@@ -203,6 +209,7 @@ public class UnivariateRealSolverUtils {\n                       numIterations, maximumIterations, initial,\n                       lowerBound, upperBound, a, b, fa, fb);\n         }\n+ end of original code*/\n         \n         return new double[]{a, b};\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 817,
    "bugId": 309,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -197,9 +197,11 @@\n    \n-        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+        if (false) {\n+            if (fa * fb >= 0.0 ) {\n+                throw new ConvergenceException(\n+                \"number of iterations={0}, maximum iterations={1}, \" +\n+                \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n+                \"final b value={6}, f(a)={7}, f(b)={8}\",\n+                numIterations, maximumIterations, initial,\n+                lowerBound, upperBound, a, b, fa, fb);\n+            }\n         }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 818,
    "bugId": 309,
    "name": "Patch_21_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf..dc9479b 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,8 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n+if (fa * fb >= 0.0 &&!(fa * fb==0.0)) {            throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 819,
    "bugId": 309,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-06-27 11:46:00.424383562 -0400\n+++ /tmp/Arja_Defects4J_Math_85/patches_cw89/Patch_1/patched/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-06-27 11:51:16.920489188 -0400\n@@ -195,15 +195,6 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n-        }\n-        \n         return new double[]{a, b};\n     }\n \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 820,
    "bugId": 309,
    "name": "Patch_1_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf..e6398f6 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 821,
    "bugId": 309,
    "name": "Patch_3_3",
    "tool": "jMutRepair",
    "diff": "--- /tmp/jMutRepair_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n+++ /tmp/jMutRepair_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n@@ -195,7 +195,7 @@\n \t\t} while ((((fa * fb) > 0.0) && (numIterations < maximumIterations)) && \n \t\t((a > lowerBound) || (b < upperBound)) );\n \n-\t\tif ((fa * fb) >= 0.0) {\n+\t\tif ((fa * fb) > 0.0) {\n \t\t\tthrow new org.apache.commons.math.ConvergenceException(\n \t\t\t(\"number of iterations={0}, maximum iterations={1}, \" + \n \t\t\t(\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + ",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 822,
    "bugId": 309,
    "name": "Patch_2_2",
    "tool": "jKali",
    "diff": "--- /tmp/jKali_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n+++ /tmp/jKali_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n@@ -195,7 +195,7 @@\n \t\t} while ((((fa * fb) > 0.0) && (numIterations < maximumIterations)) && \n \t\t((a > lowerBound) || (b < upperBound)) );\n \n-\t\tif ((fa * fb) >= 0.0) {\n+\t\tif (false) {\n \t\t\tthrow new org.apache.commons.math.ConvergenceException(\n \t\t\t(\"number of iterations={0}, maximum iterations={1}, \" + \n \t\t\t(\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + ",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 823,
    "bugId": 309,
    "name": "Patch_1_1",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n+++ /tmp/jGenProg_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n@@ -195,14 +195,14 @@\n \t\t} while ((((fa * fb) > 0.0) && (numIterations < maximumIterations)) && \n \t\t((a > lowerBound) || (b < upperBound)) );\n \n-\t\tif ((fa * fb) >= 0.0) {\n-\t\t\tthrow new org.apache.commons.math.ConvergenceException(\n-\t\t\t(\"number of iterations={0}, maximum iterations={1}, \" + \n-\t\t\t(\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \n-\t\t\t\"final b value={6}, f(a)={7}, f(b)={8}\")), \n-\t\t\tnumIterations, maximumIterations, initial, \n-\t\t\tlowerBound, upperBound, a, b, fa, fb);\n-\t\t}\n+\n+\n+\n+\n+\n+\n+\n+\n \n \t\treturn new double[]{ a, b };\n \t}",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 824,
    "bugId": 309,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf..e6398f6 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 825,
    "bugId": 309,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -197,9 +197,9 @@\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (-1 == fb) {\n             throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+            \"number of iterations={0}, maximum iterations={1}, \" +\n+            \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n+            \"final b value={6}, f(a)={7}, f(b)={8}\",\n+            numIterations, maximumIterations, initial,\n+            lowerBound, upperBound, a, b, fa, fb);\n         }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 826,
    "bugId": 309,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf..e6398f6 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 827,
    "bugId": 309,
    "name": "Patch_5_5",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf..eca9540 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb>0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 828,
    "bugId": 309,
    "name": "Patch_3_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-07-11 19:59:30.505999704 -0400\n+++ /tmp/RSRepair_Defects4J_Math_85/patches_lewz/Patch_1/patched/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-07-11 20:02:53.398926022 -0400\n@@ -195,15 +195,6 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n-        }\n-        \n         return new double[]{a, b};\n     }\n \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 829,
    "bugId": 309,
    "name": "Patch_2_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-07-09 00:56:28.347533953 -0400\n+++ /tmp/GenProg_Defects4J_Math_85/patches_perx/Patch_1/patched/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-07-09 01:01:52.964215293 -0400\n@@ -195,14 +195,11 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n-        }\n+        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n+\t\t\tthrow MathRuntimeException.createIllegalArgumentException(\n+\t\t\t\t\t\"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\", lowerBound,\n+\t\t\t\t\tinitial, upperBound);\n+\t\t}\n         \n         return new double[]{a, b};\n     }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 830,
    "bugId": 309,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 831,
    "bugId": 310,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,7 +107,11 @@ public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n+        if (v instanceof Comparable<?>){\n             addValue((Comparable<?>) v);            \n+        } else {\n+            throw new IllegalArgumentException(\"Object must implement Comparable\");\n+        }\n     }\n     \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 832,
    "bugId": 310,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex c8deca3..1887afe 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,7 +107,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+if (!(v instanceof Comparable<?>)){throw new IllegalArgumentException();}            addValue((Comparable<?>) v);            \n     }\n     \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 833,
    "bugId": 310,
    "name": "Patch_6_6",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex c8deca3..7ecb4f1 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,7 +107,12 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+            if (v instanceof Comparable<?>) {\n+\taddValue((Comparable<?>) v);\n+} else {\n+\tthrow new IllegalArgumentException(\"Illegal argument: v\");\n+}\n+            \n     }\n     \n     /**\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 834,
    "bugId": 310,
    "name": "Patch_12_11",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex c8deca3..7ecb4f1 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,7 +107,12 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+            if (v instanceof Comparable<?>) {\n+\taddValue((Comparable<?>) v);\n+} else {\n+\tthrow new IllegalArgumentException(\"Illegal argument: v\");\n+}\n+            \n     }\n     \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 835,
    "bugId": 310,
    "name": "Patch_14_12",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex c8deca3..bfe0188 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,7 +107,12 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+            if (v instanceof Comparable<?>) {\n+\taddValue((Comparable<?>) v);\n+\t} else {\n+\tthrow new IllegalArgumentException(\"Illegal argument: v\");\n+}\n+            \n     }\n     \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 836,
    "bugId": 311,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -272,12 +272,10 @@ protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n+            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n-                } else {\n+            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                 return null;\n-                }\n             }\n         }\n         return row;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 837,
    "bugId": 312,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n@@ -111,9 +111,6 @@ public CholeskyDecompositionImpl(final RealMatrix matrix,\n \n             final double[] lI = lTData[i];\n \n-            if (lTData[i][i] < absolutePositivityThreshold) {\n-                throw new NotPositiveDefiniteMatrixException();\n-            }\n             // check off-diagonal elements (and reset them to 0)\n             for (int j = i + 1; j < order; ++j) {\n                 final double[] lJ = lTData[j];\n@@ -134,6 +131,9 @@ public CholeskyDecompositionImpl(final RealMatrix matrix,\n             final double[] ltI = lTData[i];\n \n             // check diagonal element\n+            if (ltI[i] < absolutePositivityThreshold) {\n+                throw new NotPositiveDefiniteMatrixException();\n+            }\n \n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 838,
    "bugId": 313,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -326,19 +326,18 @@ protected RealPointValuePair getSolution() {\n         Integer basicRow =\n             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n+        Set<Integer> basicRows = new HashSet<Integer>();\n         for (int i = 0; i < coefficients.length; i++) {\n             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n+            if (basicRows.contains(basicRow)) {\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n+                coefficients[i] = 0;\n+            } else {\n+                basicRows.add(basicRow);\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 839,
    "bugId": 313,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -338,3 +338,5 @@\n                     if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n+                         if (mostNegative != coefficients[0]) {\n+                             coefficients[i] = 0;\n+                         }\n                     }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 840,
    "bugId": 313,
    "name": "Patch_317_260",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2019-06-27 12:27:25.988626596 -0400\n+++ /tmp/Arja_Defects4J_Math_88/patches_02mm/Patch_260/patched/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2019-06-27 12:35:13.942696952 -0400\n@@ -335,7 +335,9 @@\n                     (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()))\n+\t\t\t\t\t\t\t- (restrictToNonNegative ? 0 : mostNegative);\n+\t\t\t\t\tif (tableau.getEntry(basicRow, j) == 1) {\n                          coefficients[i] = 0;\n                     }\n                 }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 841,
    "bugId": 313,
    "name": "Patch_117_64",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 3bcb17f..c6aee06 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n                     (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (tableau.getEntry(basicRow, i) == 1) {\n                          coefficients[i] = 0;\n                     }\n                 }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 842,
    "bugId": 313,
    "name": "Patch_9909_5900",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 3bcb17f..c6aee06 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n                     (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (tableau.getEntry(basicRow, i) == 1) {\n                          coefficients[i] = 0;\n                     }\n                 }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 843,
    "bugId": 313,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -338,3 +338,5 @@\n                     if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n+                         if ((org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.size()) != (coefficients.length)) {\n+                             coefficients[i] = 0;\n+                         }\n                     }\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 844,
    "bugId": 313,
    "name": "Patch_99_66",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 3bcb17f..c6aee06 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n                     (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (tableau.getEntry(basicRow, i) == 1) {\n                          coefficients[i] = 0;\n                     }\n                 }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 845,
    "bugId": 313,
    "name": "Patch_198_105",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 3bcb17f..a48c4eb 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n                     (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (j == i && (tableau.getEntry(basicRow, j) == 1)) {\n                          coefficients[i] = 0;\n                     }\n                 }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 846,
    "bugId": 313,
    "name": "Patch_67_37",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2019-07-11 20:23:59.483588319 -0400\n+++ /tmp/RSRepair_Defects4J_Math_88/patches_oqu5/Patch_37/patched/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2019-07-11 20:27:26.720791410 -0400\n@@ -335,7 +335,9 @@\n                     (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()))\n+\t\t\t\t\t\t\t- (restrictToNonNegative ? 0 : mostNegative);\n+\t\t\t\t\tif (tableau.getEntry(basicRow, j) == 1) {\n                          coefficients[i] = 0;\n                     }\n                 }\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 847,
    "bugId": 314,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n@@ -256,8 +256,8 @@ public Fraction abs() {\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+        long nOd = ((long) numerator) * object.denominator;\n+        long dOn = ((long) denominator) * object.numerator;\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 848,
    "bugId": 315,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -342,8 +342,10 @@ public static boolean equals(double[] x, double[] y) {\n      * @throws IllegalArgumentException if n < 0\n      */\n     public static long factorial(final int n) {\n-        long result = Math.round(factorialDouble(n));\n-        if (result == Long.MAX_VALUE) {\n+        if (n < 0) {\n+            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n+        }\n+        if (n > 20) {\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }\n@@ -374,6 +376,9 @@ public static double factorialDouble(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n         }\n+        if (n < 21) {\n+            return factorial(n);\n+        }\n         return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }\n \n@@ -394,6 +399,9 @@ public static double factorialLog(final int n) {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n+        if (n < 21) {\n+            return Math.log(factorial(n));\n+        }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double)i);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 849,
    "bugId": 315,
    "name": "Patch_5_5",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex 7d8aa4d..1bdade6 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -25,6 +25,13 @@ import java.util.Arrays;\n  * @version $Revision$ $Date$\n  */\n public final class MathUtils {\n+private static long patch_method(int n){\n+  long result=1;\n+  for (int i=2; i <= n; i++) {\n+    result*=i;\n+  }\n+  return result;\n+}\n \n     /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */\n     public static final double EPSILON = 0x1.0p-53;\n@@ -374,7 +381,7 @@ public final class MathUtils {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n         }\n-        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n+if (n<(int)20.0){return patch_method(n);}        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }\n \n     /**",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 850,
    "bugId": 316,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n@@ -141,10 +141,12 @@ protected double getDomainUpperBound(double p) {\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+        double ret = 1.0;\n         double d = getDenominatorDegreesOfFreedom();\n+        if (d > 2.0) {\n             // use mean\n             ret = d / (d - 2.0);\n+        }\n         return ret;\n     }\n     \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 851,
    "bugId": 316,
    "name": "Patch_1_1",
    "tool": "Cardumem",
    "diff": "--- /tmp/Cardumen_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpljava\n+++ /tmp/Cardumen_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpljava\n@@ -144,7 +144,7 @@\n \t\tdouble ret;\n \t\tdouble d = getDenominatorDegreesOfFreedom();\n \n-\t\tret = d / (d - 2.0);\n+\t\tret = p + (p * p);\n \t\treturn ret;\n \t}",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 852,
    "bugId": 316,
    "name": "Patch_25_18",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-06-27 15:00:17.375598914 -0400\n+++ /tmp/Arja_Defects4J_Math_95/patches_x287/Patch_18/patched/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-06-27 15:03:46.410310536 -0400\n@@ -143,8 +143,7 @@\n     protected double getInitialDomain(double p) {\n         double ret;\n         double d = getDenominatorDegreesOfFreedom();\n-            // use mean\n-            ret = d / (d - 2.0);\n+            ret = 0.5;\n         return ret;\n     }\n     \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 853,
    "bugId": 316,
    "name": "Patch_21_8",
    "tool": "jGenProg",
    "diff": "--- /tmp/jGenProg_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpljava\n+++ /tmp/jGenProg_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpljava\n@@ -142,9 +142,9 @@\n \n \tprotected double getInitialDomain(double p) {\n \t\tdouble ret;\n-\t\tdouble d = getDenominatorDegreesOfFreedom();\n+\t\tdouble d = getDenominatorDegreesOfFreedom(); \t\tret = 0.0;\n+\n \n-\t\tret = d / (d - 2.0);\n \t\treturn ret;\n \t}",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 854,
    "bugId": 316,
    "name": "Patch_59_19",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\nindex e19e97a..1d583f7 100644\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n@@ -144,7 +144,7 @@ public class FDistributionImpl\n         double ret;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n-            ret = d / (d - 2.0);\n+            ret = d / (Double.MAX_VALUE - 2.0);\n         return ret;\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 855,
    "bugId": 316,
    "name": "Patch_43_16",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\nindex e19e97a..94ca2f0 100644\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n@@ -144,7 +144,7 @@ public class FDistributionImpl\n         double ret;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n-            ret = d / (d - 2.0);\n+            ret = d / (d + 2.0);\n         return ret;\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 856,
    "bugId": 316,
    "name": "Patch_20_5",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-07-11 23:27:16.456205830 -0400\n+++ /tmp/RSRepair_Defects4J_Math_95/patches_rklu/Patch_5/patched/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-07-11 23:31:05.482797123 -0400\n@@ -143,8 +143,7 @@\n     protected double getInitialDomain(double p) {\n         double ret;\n         double d = getDenominatorDegreesOfFreedom();\n-            // use mean\n-            ret = d / (d - 2.0);\n+            ret = 1.0;\n         return ret;\n     }\n     \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 857,
    "bugId": 316,
    "name": "Patch_1122_956",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-07-09 08:00:26.104174318 -0400\n+++ /tmp/GenProg_Defects4J_Math_95/patches_3he6/Patch_956/patched/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-07-09 08:10:23.942262604 -0400\n@@ -141,10 +141,15 @@\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+        if (p == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\t\tif (p == 0) {\n+\t\t\treturn -1;\n+\t\t}\n+\t\tdouble ret;\n         double d = getDenominatorDegreesOfFreedom();\n-            // use mean\n-            ret = d / (d - 2.0);\n+            ret = 0.0;\n         return ret;\n     }\n     \n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 858,
    "bugId": 316,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 859,
    "bugId": 317,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -409,7 +409,7 @@ public static double factorialLog(final int n) {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+        if ((u == 0) || (v == 0)) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 860,
    "bugId": 318,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,6 +107,8 @@ public String toString() {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n+        addValue((Comparable<?>) v);\n+    }\n     \n     /**\n      * Adds 1 to the frequency count for v.\n@@ -118,6 +120,7 @@ public void addValue(Object v) {\n      * @param v the value to add.\n      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n      */\n+    public void addValue(Comparable<?>v){\n         Object obj = v;\n         if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 861,
    "bugId": 318,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex 75914d7..97d0346 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -130,7 +130,7 @@ public class Frequency implements Serializable {\n                 freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n             }\n         } catch (ClassCastException ex) {   \n-            //TreeMap will throw ClassCastException if v is not comparable\n+if (!(v instanceof Comparable<?>)){throw new ClassCastException();}            //TreeMap will throw ClassCastException if v is not comparable\n             throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n         }\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 862,
    "bugId": 319,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n@@ -255,7 +255,7 @@ public boolean equals(Object other) {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 863,
    "bugId": 319,
    "name": "Patch_107_58",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/math/complex/Complex.java b/src/java/org/apache/commons/math/complex/Complex.java\nindex 3571567..ab0a394 100644\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n@@ -255,7 +255,7 @@ public class Complex implements Serializable  {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+                    ret = (Double.doubleToRawLongBits(real)>=Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 864,
    "bugId": 320,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -181,30 +181,43 @@ public static long binomialCoefficient(final int n, final int k) {\n         if ((k == 1) || (k == n - 1)) {\n             return n;\n         }\n-        long result = Math.round(binomialCoefficientDouble(n, k));\n-        if (result == Long.MAX_VALUE) {\n-            throw new ArithmeticException(\n-                \"result too large to represent in a long integer\");\n-        }\n         // Use symmetry for large k\n+        if (k > n / 2)\n+            return binomialCoefficient(n, n - k);\n         \n         // We use the formula\n         // (n choose k) = n! / (n-k)! / k!\n         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n         // which could be written\n         // (n choose k) == (n-1 choose k-1) * n / k\n+        long result = 1;\n+        if (n <= 61) {\n             // For n <= 61, the naive implementation cannot overflow.\n+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n+                result = result * i / j;\n+            }\n+        } else if (n <= 66) {\n             // For n > 61 but n <= 66, the result cannot overflow,\n             // but we must take care not to overflow intermediate values.\n+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                 // We know that (result * i) is divisible by j,\n                 // but (result * i) may overflow, so we split j:\n                 // Filter out the gcd, d, so j/d and i/d are integer.\n                 // result is divisible by (j/d) because (j/d)\n                 // is relative prime to (i/d) and is a divisor of\n                 // result * (i/d).\n+                long d = gcd(i, j);\n+                result = (result / (j / d)) * (i / d);\n+            }\n+        } else {\n             // For n > 66, a result overflow might occur, so we check\n             // the multiplication, taking care to not overflow\n             // unnecessary.\n+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n+                long d = gcd(i, j);\n+                result = mulAndCheck((result / (j / d)), (i / d));\n+            }\n+        }\n         return result;\n     }\n \n@@ -231,9 +244,33 @@ public static long binomialCoefficient(final int n, final int k) {\n      * @throws IllegalArgumentException if preconditions are not met.\n      */\n     public static double binomialCoefficientDouble(final int n, final int k) {\n+        if (n < k) {\n+            throw new IllegalArgumentException(\n+                \"must have n >= k for binomial coefficient (n,k)\");\n+        }\n+        if (n < 0) {\n+            throw new IllegalArgumentException(\n+                \"must have n >= 0 for binomial coefficient (n,k)\");\n+        }\n+        if ((n == k) || (k == 0)) {\n+            return 1d;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return n;\n+        }\n+        if (k > n/2) {\n+            return binomialCoefficientDouble(n, n - k);\n+        }\n+        if (n < 67) {\n+            return binomialCoefficient(n,k);\n+        }\n         \n+        double result = 1d;\n+        for (int i = 1; i <= k; i++) {\n+             result *= (double)(n - k + i) / (double)i;\n+        }\n   \n-        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n+        return Math.floor(result + 0.5);\n     }\n     \n     /**\n@@ -274,11 +311,17 @@ public static double binomialCoefficientLog(final int n, final int k) {\n          * For values small enough to do exact integer computation,\n          * return the log of the exact value \n          */\n+        if (n < 67) {  \n+            return Math.log(binomialCoefficient(n,k));\n+        }\n         \n         /*\n          * Return the log of binomialCoefficientDouble for values that will not\n          * overflow binomialCoefficientDouble\n          */\n+        if (n < 1030) { \n+            return Math.log(binomialCoefficientDouble(n, k));\n+        } \n         \n         /*\n          * Sum logs for values that could overflow\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 865,
    "bugId": 321,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n@@ -988,7 +988,7 @@ public BigDecimal getTrace() throws IllegalArgumentException {\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n-        final BigDecimal[] out = new BigDecimal[v.length];\n+        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n@@ -776,7 +776,7 @@ public double getTrace() throws IllegalArgumentException {\n         if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        final double[] out = new double[v.length];\n+        final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n             final double[] dataRow = data[row];\n             double sum = 0;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 866,
    "bugId": 321,
    "name": "Patch_95_95",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\nindex 7cd61cb2c..81214ae2e 100644\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n@@ -986,9 +986,16 @@ public class BigMatrixImpl implements BigMatrix, Serializable {\n         if (v.length != this.getColumnDimension()) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n+// start of generated patch\n+ final int nRows=this.getRowDimension();\n+ final int nCols=this.getColumnDimension();\n+ final BigDecimal[] out=new BigDecimal[nRows];\n+// end of generated patch\n+/* start of original code\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n         final BigDecimal[] out = new BigDecimal[v.length];\n+ end of original code*/\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {\ndiff --git a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\nindex 791064425..3b587ecf4 100644\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n@@ -773,6 +773,21 @@ public class RealMatrixImpl implements RealMatrix, Serializable {\n     public double[] operate(double[] v) throws IllegalArgumentException {\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n+// start of generated patch\n+if(v.length!=nCols){\n+throw new IllegalArgumentException(\"vector has wrong length\");\n+}\n+ final double[] out=new double[nRows];\n+for(int row=0;row<nRows;row++){\n+ final double[] dataRow=data[row];\n+double sum=0;\n+for(int i=0;i<nCols;i++){\n+sum+=dataRow[i]*v[i];\n+}\n+out[row]=sum;\n+}\n+// end of generated patch\n+/* start of original code\n         if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n@@ -785,6 +800,7 @@ public class RealMatrixImpl implements RealMatrix, Serializable {\n             }\n             out[row] = sum;\n         }\n+ end of original code*/\n         return out;\n     }\n ",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 867,
    "bugId": 321,
    "name": "Patch_26_26",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_98/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\t2019-06-27 16:54:09.084220647 -0400\n+++ /tmp/Arja_Defects4J_Math_98/patches_c3cy/Patch_26/patched/org/apache/commons/math/linear/BigMatrixImpl.java\t2019-06-27 16:57:37.346922255 -0400\n@@ -988,7 +988,7 @@\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n-        final BigDecimal[] out = new BigDecimal[v.length];\n+        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {\n\n\n--- /tmp/Arja_Defects4J_Math_98/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\t2019-06-27 16:54:09.084220647 -0400\n+++ /tmp/Arja_Defects4J_Math_98/patches_c3cy/Patch_26/patched/org/apache/commons/math/linear/RealMatrixImpl.java\t2019-06-27 16:57:37.354922359 -0400\n@@ -776,7 +776,7 @@\n         if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        final double[] out = new double[v.length];\n+        final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n             final double[] dataRow = data[row];\n             double sum = 0;\n\n\n",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 868,
    "bugId": 321,
    "name": "Patch_34_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\nindex 7cd61cb..4d318a9 100644\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n@@ -988,7 +988,7 @@ public class BigMatrixImpl implements BigMatrix, Serializable {\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n-        final BigDecimal[] out = new BigDecimal[v.length];\n+        final BigDecimal[] out = new BigDecimal[copyOut().length];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 869,
    "bugId": 322,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n@@ -374,7 +374,8 @@ public Complex parse(String source, ParsePosition pos) {\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+        if ((startIndex >= source.length()) ||\n+            (endIndex > source.length()) ||\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 870,
    "bugId": 322,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n@@ -377,4 +377,3 @@\n         if (\n-            source.substring(startIndex, endIndex).compareTo(\n-            getImaginaryCharacter()) != 0) {\n+            startIndex == source.length()) {\n             // set index back to initial, error index should be the start index\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 871,
    "bugId": 323,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n@@ -261,7 +261,7 @@ public double getSlope() {\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 872,
    "bugId": 324,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -34,7 +34,7 @@\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+    private static final double DEFAULT_EPSILON = 10e-15;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 873,
    "bugId": 325,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -135,17 +135,31 @@ public double solve(double min, double max) throws MaxIterationsExceededExceptio\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n+        if (sign > 0) {\n             // check if either value is close to a zero\n+            if (Math.abs(yMin) <= functionValueAccuracy) {\n+                setResult(min, 0);\n+                ret = min;\n+            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n+                setResult(max, 0);\n+                ret = max;\n+            } else {\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw new IllegalArgumentException\n                 (\"Function values at endpoints do not have different signs.\" +\n                         \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                         \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+            }\n+        } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n+        } else {\n             // either min or max is a root\n+            if (yMin == 0.0) {\n+                ret = min;\n+            } else {\n+                ret = max;\n+            }\n         }\n \n         return ret;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 874,
    "bugId": 325,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -137,9 +137,9 @@\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n+        if (this.functionValueAccuracy <= sign) {\n             // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new IllegalArgumentException\n+            (\"Function values at endpoints do not have different signs.\" +\n+            \"  Endpoints: [\" + min + \",\" + max + \"]\" +\n+            \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n         } else {\n",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 875,
    "bugId": 325,
    "name": "Patch_13_13",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 766d87e..481fa56 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -135,8 +135,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n+if (sign >= 0&&!(sign<=(double)0.6)) {            // check if either value is close to a zero\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw new IllegalArgumentException\n                 (\"Function values at endpoints do not have different signs.\" +",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 876,
    "bugId": 325,
    "name": "Patch_72_40",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 766d87e..ce523fc 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -135,7 +135,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n+        if (sign >= 1E-6) {\n             // check if either value is close to a zero\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw new IllegalArgumentException",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 877,
    "bugId": 326,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n@@ -163,7 +163,7 @@ public double getChiSquare(EstimationProblem problem) {\n \n         // compute transpose(J).J, avoiding building big intermediate matrices\n         final int rows = problem.getMeasurements().length;\n-        final int cols = problem.getAllParameters().length;\n+        final int cols = problem.getUnboundParameters().length;\n         final int max  = cols * rows;\n         double[][] jTj = new double[cols][cols];\n         for (int i = 0; i < cols; ++i) {\n@@ -199,12 +199,12 @@ public double getChiSquare(EstimationProblem problem) {\n     public double[] guessParametersErrors(EstimationProblem problem)\n       throws EstimationException {\n         int m = problem.getMeasurements().length;\n-        int p = problem.getAllParameters().length;\n+        int p = problem.getUnboundParameters().length;\n         if (m <= p) {\n             throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n                                           new Object[] { new Integer(m), new Integer(p)});\n         }\n-        double[] errors = new double[problem.getAllParameters().length];\n+        double[] errors = new double[problem.getUnboundParameters().length];\n         final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n         double[][] covar = getCovariances(problem);\n         for (int i = 0; i < errors.length; ++i) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 878,
    "bugId": 327,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n@@ -106,8 +106,18 @@ public void setStandardDeviation(double sd) {\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n+        try {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n                     (standardDeviation * Math.sqrt(2.0))));\n+        } catch (MaxIterationsExceededException ex) {\n+            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n+                return 0.0d;\n+            } else if (x > (mean + 20 * standardDeviation)) {\n+                return 1.0d;\n+            } else {\n+                throw ex;\n+            }\n+        }\n     }\n     \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 879,
    "bugId": 328,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n@@ -71,11 +71,28 @@ public double chiSquare(double[] expected, long[] observed)\n             throw new IllegalArgumentException(\n                 \"observed counts must be non-negative and expected counts must be postive\");\n         }\n+        double sumExpected = 0d;\n+        double sumObserved = 0d;\n+        for (int i = 0; i < observed.length; i++) {\n+            sumExpected += expected[i];\n+            sumObserved += observed[i];\n+        }\n+        double ratio = 1.0d;\n+        boolean rescale = false;\n+        if (Math.abs(sumExpected - sumObserved) > 10E-6) {\n+            ratio = sumObserved / sumExpected;\n+            rescale = true;\n+        }\n         double sumSq = 0.0d;\n         double dev = 0.0d;\n         for (int i = 0; i < observed.length; i++) {\n+            if (rescale) {\n+                dev = ((double) observed[i] - ratio * expected[i]);\n+                sumSq += dev * dev / (ratio * expected[i]);\n+            } else {\n                 dev = ((double) observed[i] - expected[i]);\n                 sumSq += dev * dev / expected[i];\n+            }\n         }\n         return sumSq;\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 880,
    "bugId": 329,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -540,6 +540,11 @@ public static int gcd(final int p, final int q) {\n         int u = p;\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n+                throw MathRuntimeException.createArithmeticException(\n+                        \"overflow: gcd({0}, {1}) is 2^31\",\n+                        new Object[] { p, q });\n+            }\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n@@ -711,6 +716,9 @@ public static int lcm(int a, int b) {\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n+        if (lcm == Integer.MIN_VALUE){\n+            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n+        }\n         return lcm;\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 881,
    "bugId": 329,
    "name": "Patch_3_3",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex d51ec7a..89ee746 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -540,7 +540,7 @@ public final class MathUtils {\n         int u = p;\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n-            return (Math.abs(u) + Math.abs(v));\n+if (u==Integer.MIN_VALUE){throw new ArithmeticException();}if (v==Integer.MIN_VALUE){throw new ArithmeticException();}            return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n@@ -711,7 +711,7 @@ public final class MathUtils {\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n-        return lcm;\n+if (lcm==Integer.MIN_VALUE){throw new ArithmeticException();}        return lcm;\n     }\n \n     /** ",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 882,
    "bugId": 330,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n@@ -162,7 +162,11 @@ public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n         \r\n+        if (num.intValue() < 0) {\r\n             // minus signs should be leading, invalid expression\r\n+            pos.setIndex(initialIndex);\r\n+            return null;\r\n+        }\r\n \r\n         // parse '/'\r\n         int startIndex = pos.getIndex();\r\n@@ -197,7 +201,11 @@ public Fraction parse(String source, ParsePosition pos) {\n             return null;\r\n         }\r\n         \r\n+        if (den.intValue() < 0) {\r\n             // minus signs must be leading, invalid\r\n+            pos.setIndex(initialIndex);\r\n+            return null;\r\n+        }\r\n \r\n         int w = whole.intValue();\r\n         int n = num.intValue();\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 883,
    "bugId": 331,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -124,10 +124,12 @@ public void captureArgumentsFrom(Invocation invocation) {\n                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                 }\n             }\n-            for (int position = indexOfVararg; position < matchers.size(); position++) {\n-                Matcher m = matchers.get(position);\n+            for (Matcher m : uniqueMatcherSet(indexOfVararg)) {\n                 if (m instanceof CapturesArguments) {\n-                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n+                    Object rawArgument = invocation.getRawArguments()[indexOfVararg];\n+                    for (int i = 0; i < Array.getLength(rawArgument); i++) {\n+                        ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));\n+                    }\n                 }\n             }\n         } else {\n@@ -140,6 +142,18 @@ public void captureArgumentsFrom(Invocation invocation) {\n         }\n     }\n \n+    private Set<Matcher> uniqueMatcherSet(int indexOfVararg) {\n+        HashSet<Matcher> set = new HashSet<Matcher>();\n+        for (int position = indexOfVararg; position < matchers.size(); position++) {\n+            Matcher matcher = matchers.get(position);\n+            if(matcher instanceof MatcherDecorator) {\n+                set.add(((MatcherDecorator) matcher).getActualMatcher());\n+            } else {\n+                set.add(matcher);\n+            }\n+        }\n+        return set;\n+    }\n \n     public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n         LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 884,
    "bugId": 332,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/util/Timer.java\n+++ b/src/org/mockito/internal/util/Timer.java\n@@ -1,5 +1,6 @@\n package org.mockito.internal.util;\n \n+import org.mockito.exceptions.Reporter;\n \n public class Timer {\n \n@@ -7,6 +8,7 @@\n     private long startTime = -1;\n \n     public Timer(long durationMillis) {\n+        validateInput(durationMillis);\n         this.durationMillis = durationMillis;\n     }\n \n@@ -25,4 +27,9 @@ public void start() {\n         startTime = System.currentTimeMillis();\n     }\n \n+    private void validateInput(long durationMillis) {\n+        if (durationMillis < 0) {\n+            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);\n+        }\n+    }\n }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 885,
    "bugId": 333,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -120,7 +120,18 @@ public Location getLocation() {\n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+            for (int position = 0; position < indexOfVararg; position++) {\n+                Matcher m = matchers.get(position);\n+                if (m instanceof CapturesArguments) {\n+                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n+                }\n+            }\n+            for (int position = indexOfVararg; position < matchers.size(); position++) {\n+                Matcher m = matchers.get(position);\n+                if (m instanceof CapturesArguments) {\n+                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n+                }\n+            }\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 886,
    "bugId": 334,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n@@ -376,6 +376,7 @@ private void readTypeVariables() {\n             for (Type type : typeVariable.getBounds()) {\r\n                 registerTypeVariablesOn(type);\r\n             }\r\n+            registerTypeParametersOn(new TypeVariable[] { typeVariable });\r\n             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\r\n         }\r\n \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 887,
    "bugId": 335,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n@@ -421,7 +421,7 @@ public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwar\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n-                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n+                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                 undesired.getLocation(),\n                 scenario\n         ));\n@@ -431,7 +431,7 @@ public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n         throw new VerificationInOrderFailure(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n-                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n+                \"But found this interaction on mock '\" + safelyGetMockName(undesired.getMock()) + \"':\",\n                 undesired.getLocation()\n         ));\n     }\n@@ -674,6 +674,9 @@ public void cannotInjectDependency(Field field, Object matchingMock, Exception d\n     }\n \n     private String exceptionCauseMessageIfAvailable(Exception details) {\n+        if (details.getCause() == null) {\n+            return details.getMessage();\n+        }\n         return details.getCause().getMessage();\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 888,
    "bugId": 336,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/creation/DelegatingMethod.java\n+++ b/src/org/mockito/internal/creation/DelegatingMethod.java\n@@ -52,11 +52,19 @@ public boolean isAbstract() {\n      */\n     @Override\n     public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o instanceof DelegatingMethod) {\n+            DelegatingMethod that = (DelegatingMethod) o;\n+            return method.equals(that.method);\n+        } else {\n             return method.equals(o);\n+        }\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+        return method.hashCode();\n     }\n }\n\\ No newline at end of file\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 889,
    "bugId": 337,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n@@ -14,6 +14,7 @@\n import org.mockito.internal.util.MockUtil;\r\n import org.mockito.internal.util.reflection.GenericMetadataSupport;\r\n import org.mockito.invocation.InvocationOnMock;\r\n+import org.mockito.mock.MockCreationSettings;\r\n import org.mockito.stubbing.Answer;\r\n \r\n import java.io.IOException;\r\n@@ -68,7 +69,7 @@ private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu\n \r\n         // record deep stub answer\r\n         return recordDeepStubAnswer(\r\n-                newDeepStubMock(returnTypeGenericMetadata),\r\n+                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),\r\n                 container\r\n         );\r\n     }\r\n@@ -84,22 +85,26 @@ private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu\n      * @param parentMock The parent of the current deep stub mock.\r\n      * @return The mock\r\n      */\r\n-    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\r\n+    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {\r\n+        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);\r\n         return mockitoCore().mock(\r\n                 returnTypeGenericMetadata.rawType(),\r\n-                withSettingsUsing(returnTypeGenericMetadata)\r\n+                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)\r\n         );\r\n     }\r\n \r\n-    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\r\n+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\r\n         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\r\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\r\n                 : withSettings();\r\n \r\n-        return mockSettings.serializable()\r\n+        return propagateSerializationSettings(mockSettings, parentMockSettings)\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r\n \r\n+    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {\r\n+        return mockSettings.serializable(parentMockSettings.getSerializableMode());\r\n+    }\r\n \r\n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\r\n         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 890,
    "bugId": 338,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n@@ -88,7 +88,7 @@ public void verify(VerificationData data) {\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+            catch (AssertionError e) {\n                 error = handleVerifyException(e);\n             }\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 891,
    "bugId": 339,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n@@ -119,7 +119,7 @@\n      * @return <code>false</code>.\r\n      */\r\n     public static boolean anyBoolean() {\r\n-        return reportMatcher(Any.ANY).returnFalse();\r\n+        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();\r\n     }\r\n \r\n     /**\r\n@@ -134,7 +134,7 @@ public static boolean anyBoolean() {\n      * @return <code>0</code>.\r\n      */\r\n     public static byte anyByte() {\r\n-        return reportMatcher(Any.ANY).returnZero();\r\n+        return reportMatcher(new InstanceOf(Byte.class)).returnZero();\r\n     }\r\n \r\n     /**\r\n@@ -149,7 +149,7 @@ public static byte anyByte() {\n      * @return <code>0</code>.\r\n      */\r\n     public static char anyChar() {\r\n-        return reportMatcher(Any.ANY).returnChar();\r\n+        return reportMatcher(new InstanceOf(Character.class)).returnChar();\r\n     }\r\n \r\n     /**\r\n@@ -164,7 +164,7 @@ public static char anyChar() {\n      * @return <code>0</code>.\r\n      */\r\n     public static int anyInt() {\r\n-        return reportMatcher(Any.ANY).returnZero();\r\n+        return reportMatcher(new InstanceOf(Integer.class)).returnZero();\r\n     }\r\n \r\n     /**\r\n@@ -179,7 +179,7 @@ public static int anyInt() {\n      * @return <code>0</code>.\r\n      */\r\n     public static long anyLong() {\r\n-        return reportMatcher(Any.ANY).returnZero();\r\n+        return reportMatcher(new InstanceOf(Long.class)).returnZero();\r\n     }\r\n \r\n     /**\r\n@@ -194,7 +194,7 @@ public static long anyLong() {\n      * @return <code>0</code>.\r\n      */\r\n     public static float anyFloat() {\r\n-        return reportMatcher(Any.ANY).returnZero();\r\n+        return reportMatcher(new InstanceOf(Float.class)).returnZero();\r\n     }\r\n \r\n     /**\r\n@@ -209,7 +209,7 @@ public static float anyFloat() {\n      * @return <code>0</code>.\r\n      */\r\n     public static double anyDouble() {\r\n-        return reportMatcher(Any.ANY).returnZero();\r\n+        return reportMatcher(new InstanceOf(Double.class)).returnZero();\r\n     }\r\n \r\n     /**\r\n@@ -224,7 +224,7 @@ public static double anyDouble() {\n      * @return <code>0</code>.\r\n      */\r\n     public static short anyShort() {\r\n-        return reportMatcher(Any.ANY).returnZero();\r\n+        return reportMatcher(new InstanceOf(Short.class)).returnZero();\r\n     }\r\n \r\n     /**\r\n@@ -241,7 +241,7 @@ public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T anyObject() {\r\n-        return (T) reportMatcher(Any.ANY).returnNull();\r\n+        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();\r\n     }\r\n \r\n     /**\r\n@@ -289,7 +289,7 @@ public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any(Class<T> clazz) {\r\n-        return (T) reportMatcher(Any.ANY).returnFor(clazz);\r\n+        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);\r\n     }\r\n     \r\n     /**\r\n@@ -306,7 +306,7 @@ public static short anyShort() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T any() {\r\n-        return (T) anyObject();\r\n+        return (T) reportMatcher(Any.ANY).returnNull();\r\n     }\r\n \r\n     /**\r\n@@ -321,7 +321,7 @@ public static short anyShort() {\n      * @return empty String (\"\")\r\n      */\r\n     public static String anyString() {\r\n-        return reportMatcher(Any.ANY).returnString();\r\n+        return reportMatcher(new InstanceOf(String.class)).returnString();\r\n     }\r\n     \r\n     /**\r\n@@ -336,7 +336,7 @@ public static String anyString() {\n      * @return empty List.\r\n      */\r\n     public static List anyList() {\r\n-        return reportMatcher(Any.ANY).returnList();\r\n+        return reportMatcher(new InstanceOf(List.class)).returnList();\r\n     }    \r\n     \r\n     /**\r\n@@ -355,7 +355,7 @@ public static List anyList() {\n      * @return empty List.\r\n      */\r\n     public static <T> List<T> anyListOf(Class<T> clazz) {\r\n-        return (List) reportMatcher(Any.ANY).returnList();\r\n+        return anyList();\r\n     }    \r\n     \r\n     /**\r\n@@ -370,7 +370,7 @@ public static List anyList() {\n      * @return empty Set\r\n      */\r\n     public static Set anySet() {\r\n-        return reportMatcher(Any.ANY).returnSet();\r\n+        return reportMatcher(new InstanceOf(Set.class)).returnSet();\r\n     }\r\n     \r\n     /**\r\n@@ -389,7 +389,7 @@ public static Set anySet() {\n      * @return empty Set\r\n      */\r\n     public static <T> Set<T> anySetOf(Class<T> clazz) {\r\n-        return (Set) reportMatcher(Any.ANY).returnSet();\r\n+        return anySet();\r\n     }\r\n \r\n     /**\r\n@@ -404,7 +404,7 @@ public static Set anySet() {\n      * @return empty Map.\r\n      */\r\n     public static Map anyMap() {\r\n-        return reportMatcher(Any.ANY).returnMap();\r\n+        return reportMatcher(new InstanceOf(Map.class)).returnMap();\r\n     }\r\n \r\n     /**\r\n@@ -424,7 +424,7 @@ public static Map anyMap() {\n      * @return empty Map.\r\n      */\r\n     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {\r\n-        return reportMatcher(Any.ANY).returnMap();\r\n+        return anyMap();\r\n     }\r\n     \r\n     /**\r\n@@ -439,7 +439,7 @@ public static Map anyMap() {\n      * @return empty Collection.\r\n      */\r\n     public static Collection anyCollection() {\r\n-        return reportMatcher(Any.ANY).returnList();\r\n+        return reportMatcher(new InstanceOf(Collection.class)).returnList();\r\n     }    \r\n     \r\n     /**\r\n@@ -458,7 +458,7 @@ public static Collection anyCollection() {\n      * @return empty Collection.\r\n      */\r\n     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\r\n-        return (Collection) reportMatcher(Any.ANY).returnList();\r\n+        return anyCollection();\r\n     }    \r\n \r\n     /**\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 892,
    "bugId": 340,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n+++ b/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n@@ -5,7 +5,9 @@\n package org.mockito.internal.stubbing.answers;\r\n \r\n import java.io.Serializable;\n+import java.lang.reflect.Modifier;\n \n+import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \r\n@@ -33,6 +35,9 @@\n     private static final long serialVersionUID = 9057165148930624087L;\r\n \r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n+    \tif (Modifier.isAbstract(invocation.getMethod().getModifiers())) {\n+    \t\treturn new GloballyConfiguredAnswer().answer(invocation);\n+    \t}\n         return invocation.callRealMethod();\r\n     }\r\n }\n\\ No newline at end of file\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 893,
    "bugId": 341,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n@@ -76,7 +76,7 @@ protected void registerTypeVariablesOn(Type classType) {\n \r\n             if (actualTypeArgument instanceof WildcardType) {\r\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\r\n-            } else {\r\n+            } else if (typeParameter != actualTypeArgument) {\r\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\r\n             }\r\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 894,
    "bugId": 342,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n@@ -1,921 +1,921 @@\n /*\r\n  * Copyright (c) 2007 Mockito contributors\r\n  * This program is made available under the terms of the MIT License.\r\n  */\r\n package org.mockito;\r\n \r\n import org.mockito.internal.MockitoCore;\r\n import org.mockito.internal.creation.MockSettingsImpl;\r\n import org.mockito.internal.debugging.MockitoDebuggerImpl;\r\n import org.mockito.internal.stubbing.answers.*;\r\n import org.mockito.internal.stubbing.defaultanswers.*;\r\n import org.mockito.internal.verification.VerificationModeFactory;\r\n import org.mockito.internal.verification.api.VerificationMode;\r\n import org.mockito.runners.MockitoJUnitRunner;\r\n import org.mockito.stubbing.*;\r\n \r\n /**\r\n  * <p align=\"left\"><img src=\"logo.jpg\"/></p>\r\n  * Mockito library enables mocks creation, verification and stubbing.\r\n  * <p>\r\n  * This javadoc content is also available on the <a href=\"http://mockito.org\">http://mockito.org</a> web page. \r\n  * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.\r\n  * Also, it makes possible to access documentation straight from the IDE even if you work offline.   \r\n  * \r\n  * <h1>Contents</h1>\r\n  * \r\n  * <b> \r\n  *      <a href=\"#1\">1. Let's verify some behaviour! </a><br/> \r\n  *      <a href=\"#2\">2. How about some stubbing? </a><br/>\r\n  *      <a href=\"#3\">3. Argument matchers </a><br/>\r\n  *      <a href=\"#4\">4. Verifying exact number of invocations / at least once / never </a><br/> \r\n  *      <a href=\"#5\">5. Stubbing void methods with exceptions </a><br/> \r\n  *      <a href=\"#6\">6. Verification in order </a><br/> \r\n  *      <a href=\"#7\">7. Making sure interaction(s) never happened on mock </a><br/> \r\n  *      <a href=\"#8\">8. Finding redundant invocations </a><br/> \r\n  *      <a href=\"#9\">9. Shorthand for mocks creation - &#064;Mock annotation </a><br/> \r\n  *      <a href=\"#10\">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> \r\n  *      <a href=\"#11\">11. Stubbing with callbacks </a><br/>\r\n  *      <a href=\"#12\">12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids </a><br/>\r\n  *      <a href=\"#13\">13. Spying on real objects </a><br/>\r\n  *      <a href=\"#14\">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>\r\n  *      <a href=\"#15\">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>\r\n  *      <a href=\"#16\">16. Real partial mocks (Since 1.8.0) </a><br/>\r\n  *      <a href=\"#17\">17. Resetting mocks (Since 1.8.0) </a><br/>\r\n  *      <a href=\"#18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </a><br/>\r\n  *      <a href=\"#19\">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>\r\n  *      <a href=\"#20\">20. (**New**) Serializable mocks (Since 1.8.1) </a><br/>\r\n  * </b>\r\n  * \r\n  * <p>\r\n  * Following examples mock a List, because everyone knows its interface (methods\r\n  * like add(), get(), clear() will be used). <br>\r\n  * You probably wouldn't mock List class 'in real'.\r\n  * \r\n  * <h3 id=\"1\">1. Let's verify some behaviour!</h3>\r\n  * \r\n  * <pre>\r\n  * //Let's import Mockito statically so that the code looks clearer\r\n  * import static org.mockito.Mockito.*;\r\n  * \r\n  * //mock creation\r\n  * List mockedList = mock(List.class);\r\n  *\r\n  * //using mock object\r\n  * mockedList.add(\"one\");\r\n  * mockedList.clear();\r\n  *\r\n  * //verification\r\n  * verify(mockedList).add(\"one\");\r\n  * verify(mockedList).clear();\r\n  * </pre>\r\n  * \r\n  * <p>\r\n  * Once created, mock will remember all interactions. Then you can selectively\r\n  * verify whatever interaction you are interested in.\r\n  * \r\n  * <h3 id=\"2\">2. How about some stubbing?</h3>\r\n  * \r\n  * <pre>\r\n  * //You can mock concrete classes, not only interfaces\r\n  * LinkedList mockedList = mock(LinkedList.class);\r\n  * \r\n  * //stubbing\r\n  * when(mockedList.get(0)).thenReturn(\"first\");\r\n  * when(mockedList.get(1)).thenThrow(new RuntimeException());\r\n  * \r\n  * //following prints \"first\"\r\n  * System.out.println(mockedList.get(0));\r\n  * \r\n  * //following throws runtime exception\r\n  * System.out.println(mockedList.get(1));\r\n  * \r\n  * //following prints \"null\" because get(999) was not stubbed\r\n  * System.out.println(mockedList.get(999));\r\n  *  \r\n  * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>\r\n  * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\r\n  * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\r\n  * verify(mockedList).get(0);\r\n  * </pre>\r\n  * \r\n  * <ul>\r\n  * <li> By default, for all methods that return value, mock returns null, an\r\n  * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,\r\n  * false, ... for int/Integer, boolean/Boolean, ...). </li>\r\n  * \r\n  * <li> Stubbing can be overridden: for example common stubbing can go to\r\n  * fixture setup but the test methods can override it.\r\n  * Please note that overridding stubbing is a potential code smell that points out too much stubbing</li>\r\n  * \r\n  * <li> Once stubbed, the method will always return stubbed value regardless\r\n  * of how many times it is called. </li>\r\n  * \r\n  * <li> Last stubbing is more important - when you stubbed the same method with\r\n  * the same arguments many times. </li>\r\n  * \r\n  * </ul>\r\n  * \r\n  * <h3 id=\"3\">3. Argument matchers</h3>\r\n  * \r\n  * Mockito verifies argument values in natural java style: by using an equals() method.\r\n  * Sometimes, when extra flexibility is required then you might use argument matchers:  \r\n  * \r\n  * <pre>\r\n  * //stubbing using built-in anyInt() argument matcher\r\n  * when(mockedList.get(anyInt())).thenReturn(\"element\");\r\n  * \r\n  * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):\r\n  * when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");\r\n  * \r\n  * //following prints \"element\"\r\n  * System.out.println(mockedList.get(999));\r\n  * \r\n  * //<b>you can also verify using an argument matcher</b>\r\n  * verify(mockedList).get(anyInt());\r\n  * </pre>\r\n  * \r\n  * <p>\r\n  * Argument matchers allow flexible verification or stubbing. \r\n  * {@link Matchers Click here to see} more built-in matchers \r\n  * and examples of <b>custom argument matchers / hamcrest matchers</b>.\r\n  * <p>\r\n  * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.\r\n  * <p>\r\n  * Be reasonable with using complicated argument matching.\r\n  * The natural matching style using equals() with occasional anyX() matchers tend to give clean & simple tests.\r\n  * Sometimes it's just better to refactor the code to allow equals() matching or even implement equals() method to help out with testing.\r\n  * <p>\r\n  * Also, read <a href=\"#15\">section 15</a> or javadoc for {@link ArgumentCaptor} class.\r\n  * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  \r\n  * <p>\r\n  * <b>Warning on argument matchers:</b>\r\n  * <p>\r\n  * If you are using argument matchers, <b>all arguments</b> have to be provided\r\n  * by matchers.\r\n  * <p>\r\n  * E.g: (example shows verification but the same applies to stubbing):\r\n  * \r\n  * <pre>\r\n  *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\r\n  *   //above is correct - eq() is also an argument matcher\r\n  *   \r\n  *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\r\n  *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.\r\n  * </pre>\r\n  * \r\n  * <h3 id=\"4\">4. Verifying exact number of invocations / at least x / never</h3>\r\n  * \r\n  * <pre>\r\n  * //using mock \r\n  * mockedList.add(\"once\");\r\n  * \r\n  * mockedList.add(\"twice\");\r\n  * mockedList.add(\"twice\");\r\n  * \r\n  * mockedList.add(\"three times\");\r\n  * mockedList.add(\"three times\");\r\n  * mockedList.add(\"three times\");\r\n  * \r\n  * //following two verifications work exactly the same - times(1) is used by default\r\n  * verify(mockedList).add(\"once\");\r\n  * verify(mockedList, times(1)).add(\"once\");\r\n  * \r\n  * //exact number of invocations verification\r\n  * verify(mockedList, times(2)).add(\"twice\");\r\n  * verify(mockedList, times(3)).add(\"three times\");\r\n  * \r\n  * //verification using never(). never() is an alias to times(0)\r\n  * verify(mockedList, never()).add(\"never happened\");\r\n  * \r\n  * //verification using atLeast()/atMost()\r\n  * verify(mockedList, atLeastOnce()).add(\"three times\");\r\n  * verify(mockedList, atLeast(2)).add(\"five times\");\r\n  * verify(mockedList, atMost(5)).add(\"three times\");\r\n  * \r\n  * </pre>\r\n  * \r\n  * <p>\r\n  * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\r\n  * omitted.\r\n  * \r\n  * <h3 id=\"5\">5. Stubbing void methods with exceptions</h3>\r\n  * \r\n  * <pre>\r\n  *   doThrow(new RuntimeException()).when(mockedList).clear();\r\n  *   \r\n  *   //following throws RuntimeException:\r\n  *   mockedList.clear();\r\n  * </pre>\r\n  * \r\n  * Read more about doThrow|doAnswer family of methods in paragraph 12.\r\n  * <p>\r\n  * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.\r\n  * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\r\n  * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \r\n  * \r\n  * <h3 id=\"6\">6. Verification in order</h3>\r\n  * \r\n  * <pre>\r\n  * List firstMock = mock(List.class);\r\n  * List secondMock = mock(List.class);\r\n  * \r\n  * //using mocks\r\n  * firstMock.add(\"was called first\");\r\n  * secondMock.add(\"was called second\");\r\n  * \r\n  * //create inOrder object passing any mocks that need to be verified in order\r\n  * InOrder inOrder = inOrder(firstMock, secondMock);\r\n  * \r\n  * //following will make sure that firstMock was called before secondMock\r\n  * inOrder.verify(firstMock).add(\"was called first\");\r\n  * inOrder.verify(secondMock).add(\"was called second\");\r\n  * </pre>\r\n  * \r\n  * Verification in order is flexible - <b>you don't have to verify all\r\n  * interactions</b> one-by-one but only those that you are interested in\r\n  * testing in order.\r\n  * <p>\r\n  * Also, you can create InOrder object passing only mocks that are relevant for\r\n  * in-order verification.\r\n  * \r\n  * <h3 id=\"7\">7. Making sure interaction(s) never happened on mock</h3>\r\n  * \r\n  * <pre>\r\n  * //using mocks - only mockOne is interacted\r\n  * mockOne.add(\"one\");\r\n  * \r\n  * //ordinary verification\r\n  * verify(mockOne).add(\"one\");\r\n  * \r\n  * //verify that method was never called on a mock\r\n  * verify(mockOne, never()).add(\"two\");\r\n  * \r\n  * //verify that other mocks were not interacted\r\n  * verifyZeroInteractions(mockTwo, mockThree);\r\n  * \r\n  * </pre>\r\n  * \r\n  * <h3 id=\"8\">8. Finding redundant invocations</h3>\r\n  * \r\n  * <pre>\r\n  * //using mocks\r\n  * mockedList.add(\"one\");\r\n  * mockedList.add(\"two\");\r\n  * \r\n  * verify(mockedList).add(\"one\");\r\n  * \r\n  * //following verification will fail \r\n  * verifyNoMoreInteractions(mockedList);\r\n  * </pre>\r\n  * \r\n  * A word of <b>warning</b>: \r\n  * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \r\n  * verifyNoMoreInteractions() is not recommended to use in every test method. \r\n  * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\r\n  * Abusing it leads to overspecified, less maintainable tests. You can find further reading \r\n  * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\r\n  * \r\n  * <p>   \r\n  * See also {@link Mockito#never()} - it is more explicit and\r\n  * communicates the intent well.\r\n  * <p>\r\n  * \r\n  * <h3 id=\"9\">9. Shorthand for mocks creation - &#064;Mock annotation</h3>\r\n  * \r\n  * <ul>\r\n  * <li>Minimizes repetitive mock creation code.</li>\r\n  * <li>Makes the test class more readable.</li>\r\n  * <li>Makes the verification error easier to read because the <b>field name</b>\r\n  * is used to identify the mock.</li>\r\n  * </ul>\r\n  * \r\n  * <pre>\r\n  *   public class ArticleManagerTest { \r\n  *     \r\n  *       &#064;Mock private ArticleCalculator calculator;\r\n  *       &#064;Mock private ArticleDatabase database;\r\n  *       &#064;Mock private UserProvider userProvider;\r\n  *     \r\n  *       private ArticleManager manager;\r\n  * </pre>\r\n  * \r\n  * <b>Important!</b> This needs to be somewhere in the base class or a test\r\n  * runner:\r\n  * \r\n  * <pre>\r\n  * MockitoAnnotations.initMocks(testClass);\r\n  * </pre>\r\n  * \r\n  * You can use built-in runner: {@link MockitoJUnitRunner}.\r\n  * <p>\r\n  * Read more here: {@link MockitoAnnotations}\r\n  * \r\n  * <h3 id=\"10\"> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>\r\n  * \r\n  * Sometimes we need to stub with different return value/exception for the same\r\n  * method call. Typical use case could be mocking iterators. \r\n  * Original version of Mockito did not have this feature to promote simple mocking. \r\n  * For example, instead of iterators one could use {@link Iterable} or simply\r\n  * collections. Those offer natural ways of stubbing (e.g. using real\r\n  * collections). In rare scenarios stubbing consecutive calls could be useful,\r\n  * though:\r\n  * <p>\r\n  * \r\n  * <pre>\r\n  * when(mock.someMethod(\"some arg\"))\r\n  *   .thenThrow(new RuntimeException())\r\n  *   .thenReturn(\"foo\");\r\n  * \r\n  * //First call: throws runtime exception:\r\n  * mock.someMethod(\"some arg\");\r\n  * \r\n  * //Second call: prints \"foo\"\r\n  * System.out.println(mock.someMethod(\"some arg\"));\r\n  * \r\n  * //Any consecutive call: prints \"foo\" as well (last stubbing wins). \r\n  * System.out.println(mock.someMethod(\"some arg\"));\r\n  * </pre>\r\n  * \r\n  * Alternative, shorter version of consecutive stubbing:\r\n  * \r\n  * <pre>\r\n  * when(mock.someMethod(\"some arg\"))\r\n  *   .thenReturn(\"one\", \"two\", \"three\");\r\n  * </pre>\r\n  * \r\n  * <h3 id=\"11\"> 11. Stubbing with callbacks</h3>\r\n  * \r\n  * Allows stubbing with generic {@link Answer} interface.\r\n *  <p>\r\n  * Yet another controversial feature which was not included in Mockito\r\n  * originally. We recommend using simple stubbing with thenReturn() or\r\n  * thenThrow() only. Those two should be <b>just enough</b> to test/test-drive\r\n  * any clean & simple code.\r\n  * \r\n  * <pre>\r\n  * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\r\n  *     Object answer(InvocationOnMock invocation) {\r\n  *         Object[] args = invocation.getArguments();\r\n  *         Object mock = invocation.getMock();\r\n  *         return \"called with arguments: \" + args;\r\n  *     }\r\n  * });\r\n  * \r\n  * //Following prints \"called with arguments: foo\"\r\n  * System.out.println(mock.someMethod(\"foo\"));\r\n  * </pre>\r\n  * \r\n  * <h3 id=\"12\"> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>\r\n  * \r\n  * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\r\n  * <p>\r\n  * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \r\n  * The main reason is improved readability and consistency with the family of doAnswer() methods.\r\n  * <p>\r\n  * Use doThrow() when you want to stub a void method with an exception:\r\n  * <pre>\r\n  *   doThrow(new RuntimeException()).when(mockedList).clear();\r\n  *   \r\n  *   //following throws RuntimeException:\r\n  *   mockedList.clear();\r\n  * </pre>\r\n  * \r\n  * Read more about other methods:\r\n  * <p>\r\n  * {@link Mockito#doThrow(Throwable)}\r\n  * <p>\r\n  * {@link Mockito#doAnswer(Answer)}\r\n  * <p>\r\n  * {@link Mockito#doNothing()}\r\n  * <p>\r\n  * {@link Mockito#doReturn(Object)}\r\n  * \r\n  * <h3 id=\"13\"> 13. Spying on real objects</h3>\r\n  * \r\n  * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\r\n  * <p>\r\n  * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\r\n  * \r\n  * <p>\r\n  * Spying on real objects can be associated with \"partial mocking\" concept. \r\n  * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks. \r\n  * The reason was we thought partial mock is a code smell. \r\n  * At some point we found legitimate use cases for partial mocks \r\n  * (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=\r\n  * \"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\"\r\n  * >here</a>)\r\n  * <p>\r\n  *\r\n  * <pre>\r\n  *   List list = new LinkedList();\r\n  *   List spy = spy(list);\r\n  * \r\n  *   //optionally, you can stub out some methods:\r\n  *   when(spy.size()).thenReturn(100);\r\n  * \r\n  *   //using the spy calls <b>real</b> methods\r\n  *   spy.add(\"one\");\r\n  *   spy.add(\"two\");\r\n  * \r\n  *   //prints \"one\" - the first element of a list\r\n  *   System.out.println(spy.get(0));\r\n  * \r\n  *   //size() method was stubbed - 100 is printed\r\n  *   System.out.println(spy.size());\r\n  * \r\n  *   //optionally, you can verify\r\n  *   verify(spy).add(\"one\");\r\n  *   verify(spy).add(\"two\");\r\n  * </pre>\r\n  * \r\n  * <h4>Important gotcha on spying real objects!</h4>\r\n  * \r\n  * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\r\n  * \r\n  * <pre>\r\n  *   List list = new LinkedList();\r\n  *   List spy = spy(list);\r\n  *   \r\n  *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\r\n  *   when(spy.get(0)).thenReturn(\"foo\");\r\n  *   \r\n  *   //You have to use doReturn() for stubbing\r\n  *   doReturn(\"foo\").when(spy).get(0);\r\n  * </pre>\r\n  * \r\n  * 2. Watch out for final methods. \r\n  * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\r\n  * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\r\n  * Typically you may get a NullPointerException because mock instances don't have fields initiated.\r\n  * \r\n  * <h3 id=\"14\">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>\r\n  * \r\n  * You can create a mock with specified strategy for its return values.\r\n  * It's quite advanced feature and typically you don't need it to write decent tests.\r\n  * However, it can be helpful for working with <b>legacy systems</b>.\r\n  * <p>\r\n  * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\r\n  * \r\n  * <pre>\r\n  *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\r\n  *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \r\n  * </pre>\r\n  * \r\n  * <p>\r\n  * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}\r\n  * \r\n  * <h3 id=\"15\">15. Capturing arguments for further assertions (Since 1.8.0) </h3>\r\n  * \r\n  * Mockito verifies argument values in natural java style: by using an equals() method.\r\n  * This is also the recommended way of matching arguments because it makes tests clean & simple.\r\n  * In some situations though, it is helpful to assert on certain arguments after the actual verification.\r\n  * For example:\r\n  * <pre>\r\n  *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\r\n  *   verify(mock).doSomething(argument.capture());\r\n  *   assertEquals(\"John\", argument.getValue().getName());\r\n  * </pre>\r\n  * \r\n  * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\r\n  * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\r\n  * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\r\n  * <p>\r\n  * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\r\n  * Both techniques can be used for making sure certain arguments where passed to mocks. \r\n  * However, ArgumentCaptor may be a better fit if:\r\n  * <ul>  \r\n  * <li>custom argument matcher is not likely to be reused</li>\r\n  * <li>you just need it to assert on argument values to complete verification</li>\r\n  * </ul>\r\n  * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\r\n  * \r\n  * <h3 id=\"16\">16. Real partial mocks (Since 1.8.0) </h3>\r\n  *  \r\n  *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.\r\n  *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:\r\n  *  <a href=\"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\">here</a>\r\n  *  <p>\r\n  *  <b>Before release 1.8</b> spy() was not producing real partial mocks and it was confusing for some users.\r\n  *  Read more about spying: <a href=\"#13\">here</a> or in javadoc for {@link Mockito#spy(Object)} method. \r\n  *  <p>\r\n  *  <pre>\r\n  *    //you can create partial mock with spy() method:    \r\n  *    List list = spy(new LinkedList());\r\n  *    \r\n  *    //you can enable partial mock capabilities selectively on mocks:\r\n  *    Foo mock = mock(Foo.class);\r\n  *    //Be sure the real implementation is 'safe'.\r\n  *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.\r\n  *    when(mock.someMethod()).thenCallRealMethod();\r\n  *  </pre>\r\n  *  \r\n  * As usual you are going to read <b>the partial mock warning</b>:\r\n  * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\r\n  * How does partial mock fit into this paradigm? Well, it just doesn't... \r\n  * Partial mock usually means that the complexity has been moved to a different method on the same object.\r\n  * In most cases, this is not the way you want to design your application.\r\n  * <p>\r\n  * However, there are rare cases when partial mocks come handy: \r\n  * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\r\n  * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\r\n  *  \r\n  * <h3 id=\"17\">17. Resetting mocks (Since 1.8.0) </h3>\r\n  *  \r\n  * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\r\n  * Normally, you don't need to reset your mocks, just create new mocks for each test method. \r\n  * <p>\r\n  * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\r\n  * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.\r\n  * Follow the whisper of your test methods: \"Please keep us small & focused on single behavior\". \r\n  * There are several threads about it on mockito mailing list.\r\n  * <p>\r\n  * The only reason we added reset() method is to\r\n  * make it possible to work with container-injected mocks.\r\n  * See issue 55 (<a href=\"http://code.google.com/p/mockito/issues/detail?id=55\">here</a>)\r\n  * or FAQ (<a href=\"http://code.google.com/p/mockito/wiki/FAQ\">here</a>).\r\n  * <p>\r\n  * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much). \r\n  * <pre>\r\n  *   List mock = mock(List.class);\r\n  *   when(mock.size()).thenReturn(10);\r\n  *   mock.add(1);\r\n  *   \r\n  *   reset(mock);\r\n  *   //at this point the mock forgot any interactions & stubbing\r\n  * </pre>\r\n  *  \r\n  * <h3 id=\"18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>\r\n  * \r\n  * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \r\n  * <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\r\n  * <p>\r\n  * In case of questions you may also post to mockito mailing list: \r\n  * <a href=\"http://groups.google.com/group/mockito\">http://groups.google.com/group/mockito</a>\r\n  * <p>\r\n  * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. \r\n  * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}\r\n  * \r\n  * <h3 id=\"19\">19. Aliases for behavior driven development (Since 1.8.0) </h3>\r\n  * \r\n  * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.\r\n  * This is exactly how we write our tests and we warmly encourage you to do so!\r\n  * <p>\r\n  * Start learning about BDD here: <a href=\"http://en.wikipedia.org/wiki/Behavior_Driven_Development\">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>\r\n  * <p>\r\n  * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.\r\n  * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test. \r\n  * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method. \r\n  * Now it really nicely integrates with the <b>given</b> component of a BDD style test!  \r\n  * <p>\r\n  * Here is how the test might look like: \r\n  * <pre>\r\n  * import static org.mockito.BDDMockito.*;\r\n  * \r\n  * Seller seller = mock(Seller.class);\r\n  * Shop shop = new Shop(seller);\r\n  * \r\n  * public void shouldBuyBread() throws Exception {\r\n  *   //given  \r\n  *   given(seller.askForBread()).willReturn(new Bread());\r\n  *   \r\n  *   //when\r\n  *   Goods goods = shop.buyBread();\r\n  *   \r\n  *   //then\r\n  *   assertThat(goods, containBread());\r\n  * }  \r\n  * </pre>\r\n  * \r\n  * <h3 id=\"20\">20. (**New**) Serializable mocks (Since 1.8.1) </h3>\r\n  * \r\n  * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\r\n  * <p>\r\n  * WARNING: This should be rarely used in unit testing. \r\n  * <p>\r\n  * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\r\n  * was in a web environment and the objects from the external dependency were being serialized to pass between layers. \r\n  * <p>\r\n  * To create serializable mock use {@link MockSettings#serializable()}:\r\n  * <pre>\r\n  *   List serializableMock = mock(List.class, withSettings().serializable());\r\n  * </pre>\r\n  * <p>\r\n  * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>\r\n  * serialization requirements</a> are met by the class.\r\n  * <p>\r\n  * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version \r\n  * which accepts MockSettings. No worries, you will hardly ever use it.\r\n  * \r\n  * <pre>\r\n  * List<Object> list = new ArrayList<Object>();\r\n  * List<Object> spy = mock(ArrayList.class, withSettings()\r\n  *                 .spiedInstance(list)\r\n  *                 .defaultAnswer(CALLS_REAL_METHODS)\r\n  *                 .serializable());\r\n  * </pre>\r\n  */\r\n @SuppressWarnings(\"unchecked\")\r\n public class Mockito extends Matchers {\r\n     \r\n     private static final MockitoCore MOCKITO_CORE = new MockitoCore();\r\n     \r\n     /**\r\n      * The default Answer of every mock <b>if</b> the mock was not stubbed. \r\n      * Typically it just returns some empty value. \r\n      * <p>\r\n      * {@link Answer} can be used to define the return values of unstubbed invocations. \r\n      * <p>\r\n      * This implementation first tries the global configuration. \r\n      * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)\r\n      */\r\n     public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();\r\n     \r\n     /**\r\n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\r\n      * <p>\r\n      * {@link Answer} can be used to define the return values of unstubbed invocations.\r\n      * <p>\r\n      * This implementation can be helpful when working with legacy code.\r\n      * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.\r\n      * This implementation of Answer <b>returns SmartNull instead of null</b>.\r\n      * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.\r\n      * <p>\r\n      * ReturnsSmartNulls first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})\r\n      * then it tries to return SmartNull. If the return type is final then plain null is returned.\r\n      * <p>\r\n      * ReturnsSmartNulls will be probably the default return values strategy in Mockito 2.0\r\n      * <p>\r\n      * Example:\r\n      * <pre>\r\n      *   Foo mock = (Foo.class, RETURNS_SMART_NULLS);\r\n      *   \r\n      *   //calling unstubbed method here:\r\n      *   Stuff stuff = mock.getStuff();\r\n      *   \r\n      *   //using object returned by unstubbed call:\r\n      *   stuff.doSomething();\r\n      *   \r\n      *   //Above doesn't yield NullPointerException this time!\r\n      *   //Instead, SmartNullPointerException is thrown. \r\n      *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  \r\n      * </pre>\r\n      */\r\n     public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();\r\n     \r\n     /**\r\n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\r\n      * <p>\r\n      * {@link Answer} can be used to define the return values of unstubbed invocations.\r\n      * <p>\r\n      * This implementation can be helpful when working with legacy code. \r\n      * <p>\r\n      * ReturnsMocks first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})\r\n      * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.\r\n      * <p>\r\n      */\r\n     public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();\r\n \r\n     /**\r\n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\r\n      * <p>\r\n      * {@link Answer} can be used to define the return values of unstubbed invocations.\r\n      * <p>\r\n      * This implementation can be helpful when working with legacy code.\r\n      * When this implementation is used, unstubbed methods will delegate to the real implementation.\r\n      * This is a way to create a partial mock object that calls real methods by default.\r\n      * <p>\r\n      * As usual you are going to read <b>the partial mock warning</b>:\r\n      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\r\n      * How does partial mock fit into this paradigm? Well, it just doesn't... \r\n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\r\n      * In most cases, this is not the way you want to design your application.\r\n      * <p>\r\n      * However, there are rare cases when partial mocks come handy: \r\n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\r\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\r\n      * <p>\r\n      * Example:\r\n      * <pre>\r\n      * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);\r\n      *\r\n      * // this calls the real implementation of Foo.getSomething()\r\n      * value = mock.getSomething();\r\n      *\r\n      * when(mock.getSomething()).thenReturn(fakeValue);\r\n      *\r\n      * // now fakeValue is returned\r\n      * value = mock.getSomething();\r\n      * </pre>\r\n      */\r\n     public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();\r\n     \r\n     /**\r\n      * Creates mock object of given class or interface.\r\n      * <p>\r\n      * See examples in javadoc for {@link Mockito} class\r\n      * \r\n      * @param classToMock class or interface to mock\r\n      * @return mock object\r\n      */\r\n     public static <T> T mock(Class<T> classToMock) {\r\n         return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));\r\n     }\r\n     \r\n     /**\r\n      * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. \r\n      * <p>\r\n      * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. \r\n      * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\r\n      * <p>\r\n      * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\r\n      * <p>\r\n      * \r\n      * See examples in javadoc for {@link Mockito} class\r\n      * \r\n      * @param classToMock class or interface to mock\r\n      * @param name of the mock \r\n      * @return mock object\r\n      */\r\n     public static <T> T mock(Class<T> classToMock, String name) {\r\n         return mock(classToMock, withSettings()\r\n                 .name(name)\r\n                 .defaultAnswer(RETURNS_DEFAULTS));\r\n     }\r\n     \r\n     /**\r\n      * @deprecated\r\n      * <b>Please use mock(Foo.class, defaultAnswer);</b>\r\n      * <p>\r\n      * See {@link Mockito#mock(Class, Answer)}\r\n      * <p>\r\n      * Why it is deprecated? ReturnValues is being replaced by Answer\r\n      * for better consistency & interoperability of the framework. \r\n      * Answer interface has been in Mockito for a while and it has the same responsibility as ReturnValues.\r\n      * There's no point in mainting exactly the same interfaces.\r\n      * <p>\r\n      * Creates mock with a specified strategy for its return values. \r\n      * It's quite advanced feature and typically you don't need it to write decent tests.\r\n      * However it can be helpful when working with legacy systems.\r\n      * <p>\r\n      * Obviously return values are used only when you don't stub the method call.\r\n      *\r\n      * <pre>\r\n      *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\r\n      *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); \r\n      * </pre>\r\n      * \r\n      * <p>See examples in javadoc for {@link Mockito} class</p>\r\n      * \r\n      * @param classToMock class or interface to mock\r\n      * @param returnValues default return values for unstubbed methods\r\n      *\r\n      * @return mock object\r\n      */\r\n     @Deprecated\r\n     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\r\n         return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));\r\n     }\r\n     \r\n     /**\r\n      * Creates mock with a specified strategy for its answers to interactions. \r\n      * It's quite advanced feature and typically you don't need it to write decent tests.\r\n      * However it can be helpful when working with legacy systems.\r\n      * <p>\r\n      * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\r\n      *\r\n      * <pre>\r\n      *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);\r\n      *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \r\n      * </pre>\r\n      * \r\n      * <p>See examples in javadoc for {@link Mockito} class</p>\r\n      * \r\n      * @param classToMock class or interface to mock\r\n      * @param defaultAnswer default answer for unstubbed methods\r\n      *\r\n      * @return mock object\r\n      */\r\n     public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {\r\n         return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));\r\n     }\r\n     \r\n     /**\r\n      * Creates a mock with some non-standard settings.\r\n      * <p>\r\n      * The number of configuration points for a mock grows \r\n      * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods. \r\n      * Hence {@link MockSettings}.\r\n      * <pre>\r\n      *   Listener mock = mock(Listener.class, withSettings()\r\n      *     .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS));\r\n      *   );  \r\n      * </pre>\r\n      * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks? \r\n      * Is the code under test so complicated that it requires non-standard mocks? \r\n      * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?\r\n      * <p>\r\n      * See also {@link Mockito#withSettings()}\r\n      * <p>\r\n      * See examples in javadoc for {@link Mockito} class\r\n      * \r\n      * @param classToMock class or interface to mock\r\n      * @param mockSettings additional mock settings\r\n      * @return mock object\r\n      */\r\n     public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\r\n-        return MOCKITO_CORE.mock(classToMock, mockSettings);\r\n+        return MOCKITO_CORE.mock(classToMock, mockSettings, true);\r\n     }\r\n     \r\n     /**\r\n      * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\r\n      * <p>\r\n      * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\r\n      * <p>\r\n      * As usual you are going to read <b>the partial mock warning</b>:\r\n      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\r\n      * How does partial mock fit into this paradigm? Well, it just doesn't... \r\n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\r\n      * In most cases, this is not the way you want to design your application.\r\n      * <p>\r\n      * However, there are rare cases when partial mocks come handy: \r\n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\r\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\r\n      * <p>\r\n      * Example:\r\n      * \r\n      * <pre>\r\n      *   List list = new LinkedList();\r\n      *   List spy = spy(list);\r\n      * \r\n      *   //optionally, you can stub out some methods:\r\n      *   when(spy.size()).thenReturn(100);\r\n      * \r\n      *   //using the spy calls <b>real</b> methods\r\n      *   spy.add(\"one\");\r\n      *   spy.add(\"two\");\r\n      * \r\n      *   //prints \"one\" - the first element of a list\r\n      *   System.out.println(spy.get(0));\r\n      * \r\n      *   //size() method was stubbed - 100 is printed\r\n      *   System.out.println(spy.size());\r\n      * \r\n      *   //optionally, you can verify\r\n      *   verify(spy).add(\"one\");\r\n      *   verify(spy).add(\"two\");\r\n      * </pre>\r\n      * \r\n      * <h4>Important gotcha on spying real objects!</h4>\r\n      * \r\n      * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\r\n      * \r\n      * <pre>\r\n      *   List list = new LinkedList();\r\n      *   List spy = spy(list);\r\n      *   \r\n      *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\r\n      *   when(spy.get(0)).thenReturn(\"foo\");\r\n      *   \r\n      *   //You have to use doReturn() for stubbing\r\n      *   doReturn(\"foo\").when(spy).get(0);\r\n      * </pre>\r\n      * \r\n      * 2. Watch out for final methods. \r\n      * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\r\n      * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\r\n      * Typically you may get a NullPointerException because mock instances don't have fields initiated.\r\n      * \r\n      * <p>\r\n      * See examples in javadoc for {@link Mockito} class\r\n      * \r\n      * @param object\r\n      *            to spy on\r\n      * @return a spy of the real object\r\n      */\r\n     public static <T> T spy(T object) {\r\n         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\r\n                 .spiedInstance(object)\r\n-                .defaultAnswer(CALLS_REAL_METHODS)); \r\n+                .defaultAnswer(CALLS_REAL_METHODS), true); \r\n     }\r\n \r\n     /**\r\n      * <pre>\r\n      *   //Instead of:\r\n      *   stub(mock.count()).toReturn(10);\r\n      * \r\n      *   //Please do:\r\n      *   when(mock.count()).thenReturn(10);\r\n      * </pre> \r\n      * \r\n      * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} \r\n      * <p>\r\n      * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:\r\n      * <pre>\r\n      *   Mockito.stub;  <i>replace with:</i>  Mockito.when;\r\n      *   stub(          <i>replace with:</i>  when(\r\n      *   .toReturn(     <i>replace with:</i>  .thenReturn(\r\n      *   .toThrow(      <i>replace with:</i>  .thenThrow(\r\n      *   .toAnswer(     <i>replace with:</i>  .thenAnswer(\r\n      * </pre>\r\n      * If you're an existing user then sorry for making your code littered with deprecation warnings. \r\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n@@ -1,38 +1,39 @@\n /*\r\n  * Copyright (c) 2007 Mockito contributors\r\n  * This program is made available under the terms of the MIT License.\r\n  */\r\n package org.mockito.internal;\r\n \r\n import org.mockito.InOrder;\r\n import org.mockito.MockSettings;\r\n import org.mockito.exceptions.Reporter;\r\n import org.mockito.exceptions.misusing.NotAMockException;\r\n import org.mockito.internal.creation.MockSettingsImpl;\r\n import org.mockito.internal.invocation.Invocation;\r\n import org.mockito.internal.progress.IOngoingStubbing;\r\n import org.mockito.internal.progress.MockingProgress;\r\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\r\n import org.mockito.internal.stubbing.OngoingStubbingImpl;\r\n import org.mockito.internal.stubbing.StubberImpl;\r\n import org.mockito.internal.util.MockUtil;\r\n import org.mockito.internal.verification.api.VerificationMode;\r\n import org.mockito.stubbing.*;\r\n \r\n import java.util.Arrays;\r\n import java.util.List;\r\n \r\n @SuppressWarnings(\"unchecked\")\r\n public class MockitoCore {\r\n \r\n     private final Reporter reporter = new Reporter();\r\n     private final MockUtil mockUtil = new MockUtil();\r\n     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\r\n     \r\n-    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }\r\n-    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\r\n+    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) {\r\n         mockingProgress.validateState();\r\n+        if (shouldResetOngoingStubbing) {\r\n             mockingProgress.resetOngoingStubbing();\r\n+        }\r\n         return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\r\n     }\r\n     \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 895,
    "bugId": 343,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\n@@ -1,6 +1,7 @@\n package org.mockito.internal.configuration.injection;\r\n \r\n import org.mockito.exceptions.base.MockitoException;\r\n+import org.mockito.internal.util.reflection.BeanPropertySetter;\r\n import org.mockito.internal.util.reflection.FieldSetter;\r\n \r\n import java.lang.reflect.Field;\r\n@@ -22,7 +23,9 @@ public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Fie\n             return new OngoingInjecter() {\r\n                 public boolean thenInject() {\r\n                     try {\r\n+                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\r\n                             new FieldSetter(fieldInstance, field).set(matchingMock);\r\n+                        }\r\n                     } catch (Exception e) {\r\n                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\r\n                     }\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 896,
    "bugId": 344,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n@@ -17,6 +17,7 @@\n import org.mockito.internal.stubbing.OngoingStubbingImpl;\r\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\r\n import org.mockito.internal.stubbing.VoidMethodStubbableImpl;\r\n+import org.mockito.internal.verification.MockAwareVerificationMode;\r\n import org.mockito.internal.verification.VerificationDataImpl;\r\n import org.mockito.stubbing.Answer;\r\n import org.mockito.stubbing.VoidMethodStubbable;\r\n@@ -73,9 +74,11 @@ public Object handle(Invocation invocation) throws Throwable {\n         if (verificationMode != null) {\r\n             //We need to check if verification was started on the correct mock \r\n             // - see VerifyingWithAnExtraCallToADifferentMockTest\r\n+            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\r\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \r\n                 verificationMode.verify(data);\r\n                 return null;\r\n+            }\r\n         }\r\n         \r\n         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\r\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n@@ -20,6 +20,7 @@\n import org.mockito.internal.stubbing.OngoingStubbingImpl;\r\n import org.mockito.internal.stubbing.StubberImpl;\r\n import org.mockito.internal.util.MockUtil;\r\n+import org.mockito.internal.verification.MockAwareVerificationMode;\r\n import org.mockito.internal.verification.VerificationDataImpl;\r\n import org.mockito.internal.verification.VerificationModeFactory;\r\n import org.mockito.internal.verification.api.InOrderContext;\r\n@@ -70,7 +71,7 @@ public IOngoingStubbing stub() {\n         } else if (!mockUtil.isMock(mock)) {\r\n             reporter.notAMockPassedToVerify();\r\n         }\r\n-        mockingProgress.verificationStarted(mode);\r\n+        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\r\n         return mock;\r\n     }\r\n     \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 897,
    "bugId": 345,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/util/reflection/GenericMaster.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMaster.java\n@@ -17,8 +17,12 @@ public Class getGenericType(Field field) {\n         Type generic = field.getGenericType();\r\n         if (generic != null && generic instanceof ParameterizedType) {\r\n             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\r\n+            if (actual instanceof Class) {\r\n                 return (Class) actual;\r\n+            } else if (actual instanceof ParameterizedType) {\r\n                 //in case of nested generics we don't go deep\r\n+                return (Class) ((ParameterizedType) actual).getRawType();\r\n+            }\r\n         }\r\n         \r\n         return Object.class;\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 898,
    "bugId": 346,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n@@ -74,12 +74,14 @@ public Object handle(Invocation invocation) throws Throwable {\n         if (verificationMode != null) {\r\n             //We need to check if verification was started on the correct mock \r\n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\r\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \r\n+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \r\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \r\n                 verificationMode.verify(data);\r\n                 return null;\r\n+            } else {\r\n                 // this means there is an invocation on a different mock. Re-adding verification mode \r\n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\r\n+                mockingProgress.verificationStarted(verificationMode);\r\n             }\r\n         }\r\n         \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 899,
    "bugId": 347,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n@@ -17,9 +17,11 @@\n     private Object spiedInstance;\r\n     private Answer<Object> defaultAnswer;\r\n     private MockName mockName;\r\n+    private boolean serializable;\r\n \r\n     public MockSettings serializable() {\r\n-        return this.extraInterfaces(java.io.Serializable.class);\r\n+        this.serializable = true;\r\n+        return this;\r\n     }\r\n \r\n     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\r\n@@ -71,7 +73,7 @@ public MockSettings defaultAnswer(Answer defaultAnswer) {\n     }\r\n \r\n     public boolean isSerializable() {\r\n-        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\r\n+        return serializable;\r\n     }\r\n \r\n     public void initiateMockName(Class classToMock) {\r\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -16,6 +16,7 @@\n import org.mockito.internal.creation.jmock.ClassImposterizer;\r\n import org.mockito.internal.util.reflection.LenientCopyTool;\r\n \r\n+import java.io.Serializable;\r\n \r\n @SuppressWarnings(\"unchecked\")\r\n public class MockUtil {\r\n@@ -42,7 +43,11 @@ public MockUtil() {\n         Class<?>[] interfaces = settings.getExtraInterfaces();\r\n \r\n         Class<?>[] ancillaryTypes;\r\n+        if (settings.isSerializable()) {\r\n+            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\r\n+        } else {\r\n             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\r\n+        }\r\n \r\n         Object spiedInstance = settings.getSpiedInstance();\r\n         \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 900,
    "bugId": 348,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n@@ -84,6 +84,8 @@ Object returnValueFor(Class<?> type) {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n             //new instances are used instead of Collections.emptyList(), etc.\n             //to avoid UnsupportedOperationException if code under test modifies returned collection\n+        } else if (type == Iterable.class) {\n+            return new ArrayList<Object>(0);\n         } else if (type == Collection.class) {\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 901,
    "bugId": 349,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/matchers/Equality.java\n+++ b/src/org/mockito/internal/matchers/Equality.java\n@@ -10,7 +10,9 @@\n public class Equality {\r\n \r\n     public static boolean areEqual(Object o1, Object o2) {\r\n-        if (o1 == null || o2 == null) {\r\n+        if (o1 == o2 ) {\r\n+            return true;\r\n+\t} else if (o1 == null || o2 == null) {\r\n             return o1 == null && o2 == null;\r\n         } else if (isArray(o1)) {\r\n             return isArray(o2) && areArraysEqual(o1, o2);\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 902,
    "bugId": 350,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\n+++ b/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\n@@ -29,9 +29,10 @@ public ByteBuddyMockMaker() {\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n+        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n+            mockInstance = instantiator.newInstance(mockedProxyType);\n             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n \n@@ -42,7 +43,7 @@ public ByteBuddyMockMaker() {\n                     \"  class to mock : \" + describeClass(mockedProxyType),\n                     \"  created class : \" + describeClass(settings.getTypeToMock()),\n                     \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+                    \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 903,
    "bugId": 351,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n@@ -111,7 +111,7 @@ private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object\n     private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n         for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n             Field field = it.next();\n-            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();\n             if (injected != null) {\n                 injectionOccurred |= true;\n                 mocks.remove(injected);\n--- a/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java\n@@ -10,6 +10,7 @@\n \n import java.lang.reflect.Field;\n import java.util.Collection;\n+import java.util.List;\n \n /**\n  * This node returns an actual injecter which will be either :\n@@ -20,7 +21,7 @@\n  * </ul>\n  */\n public class FinalMockCandidateFilter implements MockCandidateFilter {\n-    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n+    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {\n         if(mocks.size() == 1) {\n             final Object matchingMock = mocks.iterator().next();\n \n--- a/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java\n@@ -6,13 +6,14 @@\n \n import java.lang.reflect.Field;\n import java.util.Collection;\n+import java.util.List;\n \n public interface MockCandidateFilter {\n \n     OngoingInjecter filterCandidate(\n             Collection<Object> mocks,\n             Field fieldToBeInjected,\n-            Object fieldInstance\n+            List<Field> fields, Object instance\n     );\n \n }\n--- a/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java\n@@ -20,7 +20,7 @@ public NameBasedCandidateFilter(MockCandidateFilter next) {\n \t}\n \n \tpublic OngoingInjecter filterCandidate(Collection<Object> mocks,\n-\t\t\tField field, Object fieldInstance) {\n+\t\t\tField field, List<Field> fields, Object fieldInstance) {\n \t\tList<Object> mockNameMatches = new ArrayList<Object>();\n \t\tif (mocks.size() > 1) {\n \t\t\tfor (Object mock : mocks) {\n@@ -28,7 +28,7 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks,\n \t\t\t\t\tmockNameMatches.add(mock);\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn next.filterCandidate(mockNameMatches, field,\n+\t\t\treturn next.filterCandidate(mockNameMatches, field, fields,\n \t\t\t\t\tfieldInstance);\n \t\t\t/*\n \t\t\t * In this case we have to check whether we have conflicting naming\n@@ -39,7 +39,23 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks,\n \t\t\t * whenever we find a field that does match its name with the mock\n \t\t\t * name, we should take that field instead.\n \t\t\t */\n+\t\t} else if (mocks.size() == 1) {\n+\t\t\tString mockName = mockUtil.getMockName(mocks.iterator().next())\n+\t\t\t\t\t.toString();\n+\n+\t\t\tfor (Field otherField : fields) {\n+\t\t\t\tif (!otherField.equals(field)\n+\t\t\t\t\t\t&& otherField.getType().equals(field.getType())\n+\t\t\t\t\t\t&& otherField.getName().equals(mockName)) {\n+\n+\t\t\t\t\treturn new OngoingInjecter() {\n+\t\t\t\t\t\tpublic Object thenInject() {\n+\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t};\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\treturn next.filterCandidate(mocks, field, fieldInstance);\n+\t\treturn next.filterCandidate(mocks, field, fields, fieldInstance);\n \t}\n }\n--- a/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java\n@@ -17,7 +17,7 @@ public TypeBasedCandidateFilter(MockCandidateFilter next) {\n         this.next = next;\n     }\n \n-    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {\n         List<Object> mockTypeMatches = new ArrayList<Object>();\n         for (Object mock : mocks) {\n             if (field.getType().isAssignableFrom(mock.getClass())) {\n@@ -25,6 +25,6 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Ob\n             }\n         }\n \n-        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n+        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);\n     }\n }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 904,
    "bugId": 352,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\n+++ b/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\n@@ -14,18 +14,23 @@ public ConstructorInstantiator(Object outerClassInstance) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n+        return withParams(cls, outerClassInstance);\n     }\n \n-    private <T> T withOuterClass(Class<T> cls) {\n+    private static <T> T withParams(Class<T> cls, Object... params) {\n         try {\n             //this is kind of overengineered because we don't need to support more params\n             //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n+                Class<?>[] types = constructor.getParameterTypes();\n+                if (paramsMatch(types, params)) {\n+                    return (T) constructor.newInstance(params);\n+                }\n+            }\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n+        throw paramsException(cls, null);\n     }\n \n     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {\n@@ -33,6 +38,17 @@ public ConstructorInstantiator(Object outerClassInstance) {\n                 + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e);\n     }\n \n+    private static boolean paramsMatch(Class<?>[] types, Object[] params) {\n+        if (params.length != types.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < params.length; i++) {\n+            if (!types[i].isInstance(params[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n \n     private static <T> T noArgConstructor(Class<T> cls) {\n         try {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 905,
    "bugId": 353,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n@@ -41,14 +41,16 @@\n     \r\n     private static final long serialVersionUID = -7105341425736035847L;\r\n \r\n-    private MockitoCore mockitoCore = new MockitoCore();\r\n-    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\r\n+    private transient MockitoCore mockitoCore;\r\n+    private transient ReturnsEmptyValues delegate;\r\n \r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\r\n         GenericMetadataSupport returnTypeGenericMetadata =\r\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\r\n \r\n         Class<?> rawType = returnTypeGenericMetadata.rawType();\r\n+        instantiateMockitoCoreIfNeeded();\r\n+        instantiateDelegateIfNeeded();\r\n         if (!mockitoCore.isTypeMockable(rawType)) {\r\n             return delegate.returnValueFor(rawType);\r\n         }\r\n@@ -56,7 +58,17 @@ public Object answer(InvocationOnMock invocation) throws Throwable {\n         return getMock(invocation, returnTypeGenericMetadata);\r\n     }\r\n \r\n+    private synchronized void instantiateMockitoCoreIfNeeded() {\r\n+        if (mockitoCore == null) {\r\n+            mockitoCore = new MockitoCore();\r\n+        }\r\n+    }\r\n \r\n+    private synchronized void instantiateDelegateIfNeeded() {\r\n+        if (delegate == null) {\r\n+            delegate = new ReturnsEmptyValues();\r\n+        }\r\n+    }\r\n \r\n     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\r\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\r\n@@ -97,6 +109,7 @@ private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM\n                 : withSettings();\r\n \r\n         return mockSettings\r\n+\t\t        .serializable()\r\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n     }\r\n \r\n@@ -111,7 +124,7 @@ protected GenericMetadataSupport actualParameterizedType(Object mock) {\n \r\n     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\r\n \r\n-        container.addAnswer(new Answer<Object>() {\r\n+        container.addAnswer(new SerializableAnswer() {\r\n             public Object answer(InvocationOnMock invocation) throws Throwable {\r\n                 return mock;\r\n             }\r\n@@ -120,7 +133,9 @@ public Object answer(InvocationOnMock invocation) throws Throwable {\n         return mock;\r\n     }\r\n \t\r\n+\tabstract class SerializableAnswer implements Answer<Object>, Serializable {\r\n \t\t\r\n+\t}\r\n \t\r\n \r\n     protected GenericMetadataSupport actualParameterizedType(Object mock) {\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 906,
    "bugId": 354,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n@@ -90,7 +90,8 @@ public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks,\n \r\n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\r\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\r\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\r\n+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\r\n+            mocks.remove(injected);\r\n         }\r\n     }\r\n \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 907,
    "bugId": 355,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n@@ -73,7 +73,7 @@ public Object answer(InvocationOnMock invocation) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 908,
    "bugId": 356,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/matchers/Same.java\n+++ b/src/org/mockito/internal/matchers/Same.java\n@@ -26,7 +26,7 @@ public boolean matches(Object actual) {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+        description.appendText(wanted == null ? \"null\" : wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 909,
    "bugId": 356,
    "name": "Patch_8",
    "tool": "AVATAR",
    "diff": "diff --git a/src/org/mockito/internal/matchers/Same.java b/src/org/mockito/internal/matchers/Same.java\nindex 6c172fe..22b1a4b 100644\n--- a/src/org/mockito/internal/matchers/Same.java\n+++ b/src/org/mockito/internal/matchers/Same.java\n@@ -26,7 +26,10 @@ public class Same extends ArgumentMatcher<Object> implements Serializable {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+        if (wanted != null) {\n+\tdescription.appendText(wanted.toString());\n+}\n+\n         appendQuoting(description);\n         description.appendText(\")\");\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 910,
    "bugId": 356,
    "name": "Patch_8_2",
    "tool": "FixMiner",
    "diff": "diff --git a/src/org/mockito/internal/matchers/Same.java b/src/org/mockito/internal/matchers/Same.java\nindex 6c172fee2..978030ee2 100644\n--- a/src/org/mockito/internal/matchers/Same.java\n+++ b/src/org/mockito/internal/matchers/Same.java\n@@ -26,7 +26,10 @@ public class Same extends ArgumentMatcher<Object> implements Serializable {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+        if (wanted != null) {\n+description.appendText(wanted.toString());\n+}\n+\n         appendQuoting(description);\n         description.appendText(\")\");\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 911,
    "bugId": 356,
    "name": "Patch_5_4",
    "tool": "TBar",
    "diff": "diff --git a/src/org/mockito/internal/matchers/Same.java b/src/org/mockito/internal/matchers/Same.java\nindex 6c172fe..35f2e7d 100644\n--- a/src/org/mockito/internal/matchers/Same.java\n+++ b/src/org/mockito/internal/matchers/Same.java\n@@ -26,7 +26,10 @@ public class Same extends ArgumentMatcher<Object> implements Serializable {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+        if (wanted != null) {\n+\tdescription.appendText(wanted.toString());\n+\t}\n+\n         appendQuoting(description);\n         description.appendText(\")\");\n     }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 912,
    "bugId": 357,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n@@ -1,85 +1,108 @@\n /*\r\n  * Copyright (c) 2007 Mockito contributors\r\n  * This program is made available under the terms of the MIT License.\r\n  */\r\n package org.mockito.internal.stubbing.defaultanswers;\r\n \r\n+import org.mockito.MockSettings;\r\n import org.mockito.internal.InternalMockHandler;\r\n import org.mockito.internal.creation.settings.CreationSettings;\r\n import org.mockito.internal.stubbing.InvocationContainerImpl;\r\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\r\n import org.mockito.internal.util.MockCreationValidator;\r\n import org.mockito.internal.util.MockUtil;\r\n import org.mockito.internal.util.reflection.GenericMetadataSupport;\r\n import org.mockito.invocation.InvocationOnMock;\r\n import org.mockito.stubbing.Answer;\r\n \r\n import java.io.Serializable;\r\n \r\n+import static org.mockito.Mockito.mock;\r\n+import static org.mockito.Mockito.withSettings;\r\n \r\n /**\r\n  * Returning deep stub implementation.\r\n  *\r\n  * Will return previously created mock if the invocation matches.\r\n  *\r\n  * <p>Supports nested generic information, with this answer you can write code like this :\r\n  *\r\n  * <pre class=\"code\"><code class=\"java\">\r\n  *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\r\n  *\r\n  *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\r\n  *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\r\n  * </code></pre>\r\n  * </p>\r\n  *\r\n  * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\r\n  * @see org.mockito.Answers#RETURNS_DEEP_STUBS\r\n  */\r\n public class ReturnsDeepStubs implements Answer<Object>, Serializable {\r\n     \r\n     private static final long serialVersionUID = -7105341425736035847L;\r\n \r\n     private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\r\n \r\n     public Object answer(InvocationOnMock invocation) throws Throwable {\r\n         GenericMetadataSupport returnTypeGenericMetadata =\r\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\r\n \r\n         Class<?> rawType = returnTypeGenericMetadata.rawType();\r\n         if (!new MockCreationValidator().isTypeMockable(rawType)) {\r\n             return delegate.returnValueFor(rawType);\r\n         }\r\n \r\n-        return getMock(invocation);\r\n+        return getMock(invocation, returnTypeGenericMetadata);\r\n     }\r\n \r\n-    private Object getMock(InvocationOnMock invocation) throws Throwable {\r\n+    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\r\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\r\n     \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\r\n \r\n         // matches invocation for verification\r\n         for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\r\n     \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\r\n     \t\t\treturn stubbedInvocationMatcher.answer(invocation);\r\n     \t\t}\r\n \t\t}\r\n \r\n         // deep stub\r\n-        return recordDeepStubMock(invocation, container);\r\n+        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\r\n     }\r\n \r\n     /**\r\n      * Creates a mock using the Generics Metadata.\r\n      *\r\n      * @param returnTypeGenericMetadata The metadata to use to create the new mock.\r\n      * @return The mock\r\n      */\r\n+    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\r\n+        return mock(\r\n+                returnTypeGenericMetadata.rawType(),\r\n+                withSettingsUsing(returnTypeGenericMetadata)\r\n+        );\r\n+    }\r\n \r\n+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\r\n+        MockSettings mockSettings =\r\n+                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\r\n+                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\r\n+                : withSettings();\r\n \r\n+        return mockSettings\r\n+                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n+    }\r\n \r\n+    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\r\n+        return new ReturnsDeepStubs() {\r\n+            @Override\r\n+            protected GenericMetadataSupport actualParameterizedType(Object mock) {\r\n+                return returnTypeGenericMetadata;\r\n+            }\r\n+        };\r\n+    }\r\n \r\n-    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {\r\n-        Class<?> clz = invocation.getMethod().getReturnType();\r\n-        final Object mock = org.mockito.Mockito.mock(clz, this);\r\n+    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\r\n \r\n         container.addAnswer(new Answer<Object>() {\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 913,
    "bugId": 358,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -61,8 +61,7 @@ public MockUtil() {\n \r\n     public <T> void resetMock(T mock) {\r\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\r\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\r\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\r\n+        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\r\n         ((Factory) mock).setCallback(0, newFilter);\r\n     }\r\n \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 914,
    "bugId": 359,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n@@ -63,6 +63,6 @@ public static boolean isPrimitiveWrapper(Class<?> type) {\n         primitiveValues.put(int.class, 0);\r\n         primitiveValues.put(long.class, 0L);\r\n         primitiveValues.put(float.class, 0F);\r\n-        primitiveValues.put(double.class, 0);\r\n+        primitiveValues.put(double.class, 0D);\r\n     }\r\n }\n\\ No newline at end of file\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 915,
    "bugId": 359,
    "name": "Patch_9_4",
    "tool": "TBar",
    "diff": "diff --git a/src/org/mockito/internal/util/Primitives.java b/src/org/mockito/internal/util/Primitives.java\nindex b44b825..ea0bba1 100644\n--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n@@ -63,6 +63,6 @@ public class Primitives {\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+        primitiveValues.put(double.class, 0d);\n     }\n }\n\\ No newline at end of file",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 916,
    "bugId": 360,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n@@ -16,6 +16,7 @@\n import org.mockito.exceptions.base.MockitoException;\r\n import org.mockito.internal.util.MockUtil;\r\n \r\n+import static org.mockito.Mockito.withSettings;\r\n \r\n @SuppressWarnings({\"unchecked\"})\r\n public class SpyAnnotationEngine implements AnnotationEngine {\r\n@@ -46,7 +47,10 @@ public void process(Class<?> context, Object testClass) {\n                         // instance has been spied earlier\r\n                         Mockito.reset(instance);\r\n                     } else {\r\n-                        field.set(testClass, Mockito.spy(instance));\r\n+                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()\r\n+                                .spiedInstance(instance)\r\n+                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\r\n+                                .name(field.getName())));\r\n                     }\r\n                 } catch (IllegalAccessException e) {\r\n                     throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 917,
    "bugId": 361,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n@@ -6,6 +6,7 @@\n \r\n import java.io.Serializable;\r\n import java.lang.reflect.Method;\r\n+import java.util.Arrays;\r\n \r\n import org.mockito.Mockito;\r\n import org.mockito.cglib.proxy.MethodInterceptor;\r\n@@ -57,7 +58,8 @@ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr\n         }\r\n \r\n \t\tprivate String formatMethodCall() {\r\n-\t\t\treturn invocation.getMethod().getName() + \"()\";\r\n+\t\t\tString args = Arrays.toString(invocation.getArguments());\r\n+\t\t\treturn invocation.getMethod().getName() + \"(\" + args.substring(1, args.length() - 1) +\t\")\";\r\n \t\t}\r\n     }\r\n \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 918,
    "bugId": 362,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -103,7 +103,7 @@ public String toString(PrintSettings printSettings) {\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 919,
    "bugId": 363,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n@@ -8,6 +8,7 @@\n \n import org.hamcrest.Matcher;\n import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n import org.mockito.internal.matchers.*;\n@@ -199,6 +200,9 @@ public int getArgumentsCount() {\n     }\n \n     public Object callRealMethod() throws Throwable {\n+        if (this.getMethod().getDeclaringClass().isInterface()) {\n+            new Reporter().cannotCallRealMethodOnInterface();\n+        }\n         return realMethod.invoke(mock, rawArguments);\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 920,
    "bugId": 364,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -95,8 +95,19 @@ public boolean hasSameMethod(Invocation candidate) {\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n+        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+        \tClass[] params1 = m1.getParameterTypes();\n+        \tClass[] params2 = m2.getParameterTypes();\n+        \tif (params1.length == params2.length) {\n+        \t    for (int i = 0; i < params1.length; i++) {\n+        \t\tif (params1[i] != params2[i])\n+        \t\t    return false;\n+        \t    }\n+        \t    return true;\n+        \t}\n+        }\n+        return false;\n     }\n     \n     public Location getLocation() {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 921,
    "bugId": 365,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n@@ -359,7 +359,7 @@ public static Collection anyCollection() {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T isA(Class<T> clazz) {\r\n-        return reportMatcher(new InstanceOf(clazz)).<T>returnNull();\r\n+        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);\r\n     }\r\n \r\n     /**\r\n@@ -476,7 +476,7 @@ public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T eq(T value) {\r\n-        return reportMatcher(new Equals(value)).<T>returnNull();\r\n+        return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());\r\n     }  \r\n \r\n     /**\r\n@@ -513,7 +513,7 @@ public static short eq(short value) {\n      * @return <code>null</code>.\r\n      */\r\n     public static <T> T same(T value) {\r\n-        return reportMatcher(new Same(value)).<T>returnNull();\r\n+        return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());\r\n     }\r\n \r\n     /**\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 922,
    "bugId": 366,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n@@ -435,10 +435,11 @@ public void misplacedArgumentMatcher(Location location) {\n                 ));\n     }\n \n-    public void smartNullPointerException(Location location) {\n+    public void smartNullPointerException(Object obj, Location location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n                 new Location(),\n+                obj,\n                 \"Because this method was *not* stubbed correctly:\",\n                 location,\n                 \"\"\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n@@ -53,7 +53,7 @@ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr\n                 return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\r\n             }\r\n \r\n-            new Reporter().smartNullPointerException(location);\r\n+            new Reporter().smartNullPointerException(obj, location);\r\n             return null;\r\n         }\r\n \r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 923,
    "bugId": 367,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n@@ -45,6 +45,6 @@ private boolean safelyMatches(Matcher m, Object arg) {\n     }\r\n \r\n     private boolean toStringEquals(Matcher m, Object arg) {\r\n-        return StringDescription.toString(m).equals(arg.toString());\r\n+        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\r\n     }\r\n }\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 924,
    "bugId": 367,
    "name": "Patch_11",
    "tool": "AVATAR",
    "diff": "diff --git a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\nindex 671fbc5..42b89f6 100644\n--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n@@ -45,6 +45,9 @@ public class ArgumentMatchingTool {\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+        if (arg == null) {\n+    return false;\n+}\n+return StringDescription.toString(m).equals(arg.toString());\n     }\n }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 925,
    "bugId": 367,
    "name": "Patch_19_7",
    "tool": "FixMiner",
    "diff": "diff --git a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\nindex 671fbc5..42b89f6 100644\n--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n@@ -45,6 +45,9 @@ public class ArgumentMatchingTool {\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+        if (arg == null) {\n+    return false;\n+}\n+return StringDescription.toString(m).equals(arg.toString());\n     }\n }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 926,
    "bugId": 367,
    "name": "Patch_28_9",
    "tool": "TBar",
    "diff": "diff --git a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\nindex 671fbc5..b4e88ae 100644\n--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n@@ -45,6 +45,9 @@ public class ArgumentMatchingTool {\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+        if (arg == null) {\n+\t    return false;\n+\t}\n+return StringDescription.toString(m).equals(arg.toString());\n     }\n }",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 927,
    "bugId": 368,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/Period.java\n+++ b/src/main/java/org/joda/time/Period.java\n@@ -1625,13 +1625,19 @@ public Period normalizedStandard(PeriodType type) {\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n+            long totalMonths = years * 12L + months;\n+            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\n+                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);\n+                result = result.withYears(normalizedYears);\n+                totalMonths = totalMonths - (normalizedYears * 12);\n             }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\n+                int normalizedMonths = FieldUtils.safeToInt(totalMonths);\n+                result = result.withMonths(normalizedMonths);\n+                totalMonths = totalMonths - normalizedMonths;\n+            }\n+            if (totalMonths != 0) {\n+                throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\n             }\n         }\n         return result;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 928,
    "bugId": 369,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/MutableDateTime.java\n+++ b/src/main/java/org/joda/time/MutableDateTime.java\n@@ -636,7 +636,9 @@ public void add(DurationFieldType type, int amount) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"Field must not be null\");\n         }\n+        if (amount != 0) {\n             setMillis(type.getField(getChronology()).add(getMillis(), amount));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -657,7 +659,9 @@ public void setYear(final int year) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addYears(final int years) {\n+        if (years != 0) {\n             setMillis(getChronology().years().add(getMillis(), years));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -678,7 +682,9 @@ public void setWeekyear(final int weekyear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeekyears(final int weekyears) {\n+        if (weekyears != 0) {\n             setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -699,7 +705,9 @@ public void setMonthOfYear(final int monthOfYear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMonths(final int months) {\n+        if (months != 0) {\n             setMillis(getChronology().months().add(getMillis(), months));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -720,7 +728,9 @@ public void setWeekOfWeekyear(final int weekOfWeekyear) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeeks(final int weeks) {\n+        if (weeks != 0) {\n             setMillis(getChronology().weeks().add(getMillis(), weeks));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -761,7 +771,9 @@ public void setDayOfWeek(final int dayOfWeek) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addDays(final int days) {\n+        if (days != 0) {\n             setMillis(getChronology().days().add(getMillis(), days));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -782,7 +794,9 @@ public void setHourOfDay(final int hourOfDay) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addHours(final int hours) {\n+        if (hours != 0) {\n             setMillis(getChronology().hours().add(getMillis(), hours));\n+        }\n     }\n     \n     //-----------------------------------------------------------------------\n@@ -813,7 +827,9 @@ public void setMinuteOfHour(final int minuteOfHour) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMinutes(final int minutes) {\n+        if (minutes != 0) {\n             setMillis(getChronology().minutes().add(getMillis(), minutes));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -844,7 +860,9 @@ public void setSecondOfMinute(final int secondOfMinute) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addSeconds(final int seconds) {\n+        if (seconds != 0) {\n             setMillis(getChronology().seconds().add(getMillis(), seconds));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -877,7 +895,9 @@ public void setMillisOfSecond(final int millisOfSecond) {\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n+        if (millis != 0) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 929,
    "bugId": 370,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -214,11 +214,20 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DateTimeFieldType loopType = types[i];\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n+                if (loopUnitField.isSupported() == false) {\n+                    if (lastUnitField.isSupported()) {\n+                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n+                                        types[i - 1].getName() + \" < \" + loopType.getName());\n+                    } else {\n+                        throw new IllegalArgumentException(\"Types array must not contain duplicate unsupported: \" +\n+                                        types[i - 1].getName() + \" and \" + loopType.getName());\n+                    }\n+                }\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                 if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n-                } else if (compare == 0) {\n+                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {\n                     if (types[i - 1].getRangeDurationType() == null) {\n                         if (loopType.getRangeDurationType() == null) {\n                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n--- a/src/main/java/org/joda/time/field/UnsupportedDurationField.java\n+++ b/src/main/java/org/joda/time/field/UnsupportedDurationField.java\n@@ -224,9 +224,6 @@ public long getUnitMillis() {\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n-        if (durationField.isSupported()) {\n-            return 1;\n-        }\n         return 0;\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 930,
    "bugId": 371,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -461,7 +461,7 @@ public Partial with(DateTimeFieldType fieldType, int value) {\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 931,
    "bugId": 371,
    "name": "Patch_12_10",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java\nindex 0d4edf4..9a91995 100644\n--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -461,7 +461,7 @@ public final class Partial\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            Partial newPartial = new Partial(newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 932,
    "bugId": 371,
    "name": "Patch_85_21",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java\nindex 0d4edf4..9a91995 100644\n--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -461,7 +461,7 @@ public final class Partial\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            Partial newPartial = new Partial(newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 933,
    "bugId": 372,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n@@ -25,8 +25,16 @@ public void validate(Answer<?> answer, Invocation invocation) {\n             validateDoNothing((DoesNothing) answer, invocation);\r\n         }\r\n         \r\n+        if (answer instanceof CallsRealMethods) {\r\n+            validateMockingConcreteClass((CallsRealMethods) answer, invocation);\r\n+        }\r\n     }\r\n \r\n+    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {\r\n+        if (invocation.getMethod().getDeclaringClass().isInterface()) {\r\n+            reporter.cannotCallRealMethodOnInterface();\r\n+        }\r\n+    }\r\n \r\n     private void validateDoNothing(DoesNothing answer, Invocation invocation) {\r\n         if (!invocation.isVoid()) {\r\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 934,
    "bugId": 373,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -215,7 +215,7 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n-                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n+                if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                 } else if (compare == 0) {\n@@ -446,6 +446,9 @@ public Partial with(DateTimeFieldType fieldType, int value) {\n                         if (compare > 0) {\n                             break;\n                         } else if (compare == 0) {\n+                            if (fieldType.getRangeDurationType() == null) {\n+                                break;\n+                            }\n                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                             if (rangeField.compareTo(loopRangeField) > 0) {\n--- a/src/main/java/org/joda/time/field/UnsupportedDurationField.java\n+++ b/src/main/java/org/joda/time/field/UnsupportedDurationField.java\n@@ -224,6 +224,9 @@ public long getUnitMillis() {\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n+        if (durationField.isSupported()) {\n+            return 1;\n+        }\n         return 0;\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 935,
    "bugId": 374,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -276,14 +276,17 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n+        if (minutesOffset < -59 || minutesOffset > 59) {\n             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n         }\n+        if (hoursOffset > 0 && minutesOffset < 0) {\n+            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n+        }\n         int offset = 0;\n         try {\n             int hoursInMinutes = hoursOffset * 60;\n             if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 936,
    "bugId": 375,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/chrono/GJChronology.java\n+++ b/src/main/java/org/joda/time/chrono/GJChronology.java\n@@ -193,6 +193,10 @@ public static synchronized GJChronology getInstance(\n             cutoverInstant = DEFAULT_CUTOVER;\n         } else {\n             cutoverInstant = gregorianCutover.toInstant();\n+            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));\n+            if (cutoverDate.getYear() <= 0) {\n+                throw new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\");\n+            }\n         }\n \n         GJChronology chrono;\n@@ -976,6 +980,17 @@ public long add(long instant, int value) {\n                 if (instant < iCutover) {\n                     // Only adjust if gap fully crossed.\n                     if (instant + iGapDuration < iCutover) {\n+                        if (iConvertByWeekyear) {\n+                            int wyear = iGregorianChronology.weekyear().get(instant);\n+                            if (wyear <= 0) {\n+                                instant = iGregorianChronology.weekyear().add(instant, -1);\n+                            }\n+                        } else {\n+                            int year = iGregorianChronology.year().get(instant);\n+                            if (year <= 0) {\n+                                instant = iGregorianChronology.year().add(instant, -1);\n+                            }\n+                        }\n                         instant = gregorianToJulian(instant);\n                     }\n                 }\n@@ -998,6 +1013,17 @@ public long add(long instant, long value) {\n                 if (instant < iCutover) {\n                     // Only adjust if gap fully crossed.\n                     if (instant + iGapDuration < iCutover) {\n+                        if (iConvertByWeekyear) {\n+                            int wyear = iGregorianChronology.weekyear().get(instant);\n+                            if (wyear <= 0) {\n+                                instant = iGregorianChronology.weekyear().add(instant, -1);\n+                            }\n+                        } else {\n+                            int year = iGregorianChronology.year().get(instant);\n+                            if (year <= 0) {\n+                                instant = iGregorianChronology.year().add(instant, -1);\n+                            }\n+                        }\n                         instant = gregorianToJulian(instant);\n                     }\n                 }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 937,
    "bugId": 376,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -705,9 +705,9 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n+        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 938,
    "bugId": 376,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 447674a2..1ea5e67e 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -705,9 +705,16 @@ public class DateTimeFormatter {\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n+// start of generated patch\n+long instantLocal=instantMillis+chrono.getZone().getOffset(instantMillis);\n+chrono=selectChronology(chrono);\n+int defaultYear=chrono.year().get(instantMillis);\n+// end of generated patch\n+/* start of original code\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         int defaultYear = chrono.year().get(instantLocal);\n+ end of original code*/\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 939,
    "bugId": 376,
    "name": "Patch_115",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 447674a..f8489b2 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -707,7 +707,7 @@ public class DateTimeFormatter {\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+        int defaultYear = chrono.year().get(instantMillis);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 940,
    "bugId": 376,
    "name": "Patch_13_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 447674a..f8489b2 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -707,7 +707,7 @@ public class DateTimeFormatter {\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+        int defaultYear = chrono.year().get(instantMillis);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 941,
    "bugId": 376,
    "name": "Patch_8_6",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 447674a..f8489b2 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -707,7 +707,7 @@ public class DateTimeFormatter {\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+        int defaultYear = chrono.year().get(instantMillis);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 942,
    "bugId": 376,
    "name": "Patch_167_35",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 447674a..f8489b2 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -707,7 +707,7 @@ public class DateTimeFormatter {\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+        int defaultYear = chrono.year().get(instantMillis);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 943,
    "bugId": 377,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -255,16 +255,19 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff\n         if (hoursOffset == 0 && minutesOffset == 0) {\n             return DateTimeZone.UTC;\n         }\n+        if (hoursOffset < -23 || hoursOffset > 23) {\n+            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n+        }\n         if (minutesOffset < 0 || minutesOffset > 59) {\n             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n         }\n         int offset = 0;\n         try {\n-            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n+            int hoursInMinutes = hoursOffset * 60;\n             if (hoursInMinutes < 0) {\n-                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n+                minutesOffset = hoursInMinutes - minutesOffset;\n             } else {\n-                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n+                minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n@@ -280,6 +283,9 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff\n      * @return the DateTimeZone object for the offset\n      */\n     public static DateTimeZone forOffsetMillis(int millisOffset) {\n+        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\n+            throw new IllegalArgumentException(\"Millis out of range: \" + millisOffset);\n+        }\n         String id = printOffset(millisOffset);\n         return fixedOffsetZone(id, millisOffset);\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 944,
    "bugId": 378,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java\n+++ b/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java\n@@ -49,6 +49,7 @@\n     /** Serialization version. */\n     private static final long serialVersionUID = 9386874258972L;\n     /** The start of 1972. */\n+    private static final long START_1972 = 2L * 365L * 86400L * 1000L;\n \n     /** The period in the units of this period. */\n     private volatile int iPeriod;\n@@ -101,7 +102,7 @@ protected static int between(ReadablePartial start, ReadablePartial end, Readabl\n             throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n         }\n         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n-        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n+        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));\n         return values[0];\n     }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 945,
    "bugId": 379,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/LocalDate.java\n+++ b/src/main/java/org/joda/time/LocalDate.java\n@@ -207,9 +207,10 @@ public static LocalDate fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n+        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDate(\n-            yearOfEra,\n+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH)\n         );\n@@ -240,7 +241,12 @@ public static LocalDate fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n+        if (date.getTime() < 0) {\n             // handle years in era BC\n+            GregorianCalendar cal = new GregorianCalendar();\n+            cal.setTime(date);\n+            return fromCalendarFields(cal);\n+        }\n         return new LocalDate(\n             date.getYear() + 1900,\n             date.getMonth() + 1,\n--- a/src/main/java/org/joda/time/LocalDateTime.java\n+++ b/src/main/java/org/joda/time/LocalDateTime.java\n@@ -196,9 +196,10 @@ public static LocalDateTime fromCalendarFields(Calendar calendar) {\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n+        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDateTime(\n-            yearOfEra,\n+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH),\n             calendar.get(Calendar.HOUR_OF_DAY),\n@@ -233,7 +234,12 @@ public static LocalDateTime fromDateFields(Date date) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n+        if (date.getTime() < 0) {\n             // handle years in era BC\n+            GregorianCalendar cal = new GregorianCalendar();\n+            cal.setTime(date);\n+            return fromCalendarFields(cal);\n+        }\n         return new LocalDateTime(\n             date.getYear() + 1900,\n             date.getMonth() + 1,\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 946,
    "bugId": 380,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n@@ -65,10 +65,11 @@\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {\n+        protected Boolean initialValue() {\n+            return Boolean.FALSE;\n+        }\n+    };\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 947,
    "bugId": 381,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+++ b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n@@ -206,7 +206,12 @@ public long add(long instant, long months) {\n         if (valueToAdd == 0) {\n             return values;\n         }\n+        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n             // month is largest field and being added to, such as month-day\n+            int curMonth0 = partial.getValue(0) - 1;\n+            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n+            return set(partial, 0, values, newMonth);\n+        }\n         if (DateTimeUtils.isContiguous(partial)) {\n             long instant = 0L;\n             for (int i = 0, isize = partial.size(); i < isize; i++) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 948,
    "bugId": 382,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n@@ -1095,7 +1095,7 @@ public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 // valueLong contains the seconds and millis fields\n                 // the minimum output is 0.000, which is 4 or 5 digits with a negative\n-                sum = Math.max(sum, 4);\n+                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));\n                 // plus one for the decimal point\n                 sum++;\n                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n@@ -1130,6 +1130,7 @@ public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n             if (iPrefix != null) {\n                 iPrefix.printTo(buf, value);\n             }\n+            int bufLen = buf.length();\n             int minDigits = iMinPrintedDigits;\n             if (minDigits <= 1) {\n                 FormatUtils.appendUnpaddedInteger(buf, value);\n@@ -1139,6 +1140,9 @@ public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                 if (iFieldType == SECONDS_MILLIS || dp > 0) {\n+                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {\n+                        buf.insert(bufLen, '-');\n+                    }\n                     buf.append('.');\n                     FormatUtils.appendPaddedInteger(buf, dp, 3);\n                 }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 949,
    "bugId": 383,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/field/FieldUtils.java\n+++ b/src/main/java/org/joda/time/field/FieldUtils.java\n@@ -135,6 +135,9 @@ public static int safeMultiply(int val1, int val2) {\n     public static long safeMultiply(long val1, int val2) {\n         switch (val2) {\n             case -1:\n+                if (val1 == Long.MIN_VALUE) {\n+                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n+                }\n                 return -val1;\n             case 0:\n                 return 0L;\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 950,
    "bugId": 383,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/joda/time/field/FieldUtils.java b/src/main/java/org/joda/time/field/FieldUtils.java\nindex a0fe7e2..10cb24c 100644\n--- a/src/main/java/org/joda/time/field/FieldUtils.java\n+++ b/src/main/java/org/joda/time/field/FieldUtils.java\n@@ -135,7 +135,7 @@ public class FieldUtils {\n     public static long safeMultiply(long val1, int val2) {\n         switch (val2) {\n             case -1:\n-                return -val1;\n+if (val1==Long.MIN_VALUE){throw new ArithmeticException();}                return -val1;\n             case 0:\n                 return 0L;\n             case 1:",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 951,
    "bugId": 384,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -1164,19 +1164,32 @@ public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n+        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n+        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n+        long offsetBefore = getOffset(instantBefore);\n+        long offsetAfter = getOffset(instantAfter);\n+        if (offsetBefore <= offsetAfter) {\n             return instant;  // not an overlap (less than is a gap, equal is normal case)\n         }\n         \n         // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+        long diff = offsetBefore - offsetAfter;\n+        long transition = nextTransition(instantBefore);\n+        long overlapStart = transition - diff;\n+        long overlapEnd = transition + diff;\n+        if (instant < overlapStart || instant >= overlapEnd) {\n+          return instant;  // not an overlap\n+        }\n         \n         // calculate result\n+        long afterStart = instant - overlapStart;\n+        if (afterStart >= diff) {\n           // currently in later offset\n+          return earlierOrLater ? instant : instant - diff;\n+        } else {\n           // currently in earlier offset\n+          return earlierOrLater ? instant + diff : instant;\n+        }\n     }\n //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 952,
    "bugId": 384,
    "name": "Patch_58_11",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 74a3802..4a93375 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -1165,7 +1165,7 @@ public abstract class DateTimeZone implements Serializable {\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+        long instantAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n         if (instantBefore == instantAfter) {\n             return instant;  // not an overlap (less than is a gap, equal is normal case)\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 953,
    "bugId": 384,
    "name": "Patch_134_66",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 74a3802..d3f20e0 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -1165,7 +1165,7 @@ public abstract class DateTimeZone implements Serializable {\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+        long instantAfter = convertUTCToLocal(hashCode() + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n         if (instantBefore == instantAfter) {\n             return instant;  // not an overlap (less than is a gap, equal is normal case)\n         }",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 954,
    "bugId": 385,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -706,7 +706,7 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 955,
    "bugId": 386,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n@@ -2539,12 +2539,18 @@ public int estimateParsedLength() {\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n+            String best = null;\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+                \tif (best == null || id.length() > best.length()) {\n+                \t\tbest = id;\n+                \t}\n                 }\n             }\n+            if (best != null) {\n+                bucket.setZone(DateTimeZone.forID(best));\n+                return position + best.length();\n+            }\n             return ~position;\n         }\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 956,
    "bugId": 387,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/chrono/GJChronology.java\n+++ b/src/main/java/org/joda/time/chrono/GJChronology.java\n@@ -361,9 +361,21 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n \n         // Assume date is Gregorian.\n         long instant;\n+        try {\n             instant = iGregorianChronology.getDateTimeMillis\n                 (year, monthOfYear, dayOfMonth,\n                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        } catch (IllegalFieldValueException ex) {\n+            if (monthOfYear != 2 || dayOfMonth != 29) {\n+                throw ex;\n+            }\n+            instant = iGregorianChronology.getDateTimeMillis\n+                (year, monthOfYear, 28,\n+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+            if (instant >= iCutoverMillis) {\n+                throw ex;\n+            }\n+        }\n         if (instant < iCutoverMillis) {\n             // Maybe it's Julian.\n             instant = iJulianChronology.getDateTimeMillis\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 957,
    "bugId": 387,
    "name": "Patch_109",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/joda/time/chrono/GJChronology.java b/src/main/java/org/joda/time/chrono/GJChronology.java\nindex 29e559d..c9e9415 100644\n--- a/src/main/java/org/joda/time/chrono/GJChronology.java\n+++ b/src/main/java/org/joda/time/chrono/GJChronology.java\n@@ -347,35 +347,7 @@ public final class GJChronology extends AssembledChronology {\n         return instant;\n     }\n \n-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                  int hourOfDay, int minuteOfHour,\n-                                  int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n-        Chronology base;\n-        if ((base = getBase()) != null) {\n-            return base.getDateTimeMillis\n-                (year, monthOfYear, dayOfMonth,\n-                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        }\n-\n-        // Assume date is Gregorian.\n-        long instant;\n-            instant = iGregorianChronology.getDateTimeMillis\n-                (year, monthOfYear, dayOfMonth,\n-                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        if (instant < iCutoverMillis) {\n-            // Maybe it's Julian.\n-            instant = iJulianChronology.getDateTimeMillis\n-                (year, monthOfYear, dayOfMonth,\n-                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-            if (instant >= iCutoverMillis) {\n-                // Okay, it's in the illegal cutover gap.\n-                throw new IllegalArgumentException(\"Specified date does not exist\");\n-            }\n-        }\n-        return instant;\n-    }\n+    \n \n     /**\n      * Gets the cutover instant between Gregorian and Julian chronologies.",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 958,
    "bugId": 388,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -897,7 +897,7 @@ public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+        } else if (offsetLocal >= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 959,
    "bugId": 388,
    "name": "Patch_26_26",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 855cad05..51d629bf 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -897,6 +897,19 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+} else // start of generated patch\n+if(instantLocal>0){\n+long prev=previousTransition(instantAdjusted);\n+if(prev<instantAdjusted){\n+int offsetPrev=getOffset(prev);\n+int diff=offsetPrev-offsetLocal;\n+if(instantAdjusted-prev<=diff){\n+return offsetPrev;\n+}\n+}\n+}\n+// end of generated patch\n+/* start of original code\n         } else if (offsetLocal > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n@@ -907,6 +920,7 @@ public abstract class DateTimeZone implements Serializable {\n                 }\n             }\n         }\n+ end of original code*/\n         return offsetAdjusted;\n     }\n ",
    "description": "",
    "tags": [
      {
        "tagId": 2,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 960,
    "bugId": 388,
    "name": "Patch_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 855cad0..ec05941 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -897,7 +897,7 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+        } else if (offsetLocal >= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 961,
    "bugId": 388,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 855cad0..ec05941 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -897,7 +897,7 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+        } else if (offsetLocal >= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 962,
    "bugId": 388,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 855cad0..ec05941 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -897,7 +897,7 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+        } else if (offsetLocal >= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 963,
    "bugId": 388,
    "name": "Patch_5_5",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 855cad0..bab51eb 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -897,7 +897,7 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+        } else if (offsetLocal>=0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 964,
    "bugId": 389,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/tz/DefaultNameProvider.java\n+++ b/src/main/java/org/joda/time/tz/DefaultNameProvider.java\n@@ -63,22 +63,32 @@ public String getName(Locale locale, String id, String nameKey) {\n         if (byNameKeyCache == null) {\n             byIdCache.put(id, byNameKeyCache = createCache());\n             \n+            String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n+            String[] setEn = null;\n+            for (String[] strings : zoneStringsEn) {\n+              if (strings != null && strings.length == 5 && id.equals(strings[0])) {\n+                setEn = strings;\n+                break;\n+              }\n+            }\n             String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();\n             String[] setLoc = null;\n             for (String[] strings : zoneStringsLoc) {\n               if (strings != null && strings.length == 5 && id.equals(strings[0])) {\n                 setLoc = strings;\n+                break;\n+              }\n+            }\n             \n-              byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]});\n+            if (setEn != null && setLoc != null) {\n+              byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]});\n               // need to handle case where summer and winter have the same\n               // abbreviation, such as EST in Australia [1716305]\n               // we handle this by appending \"-Summer\", cf ZoneInfoCompiler\n-              if (setLoc[2].equals(setLoc[4])) {\n-                  byNameKeyCache.put(setLoc[4] + \"-Summer\", new String[] {setLoc[4], setLoc[3]});\n+              if (setEn[2].equals(setEn[4])) {\n+                  byNameKeyCache.put(setEn[4] + \"-Summer\", new String[] {setLoc[4], setLoc[3]});\n               } else {\n-                  byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]});\n-              }\n-                break;\n+                  byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});\n               }\n             }\n         }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 965,
    "bugId": 390,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/base/BasePeriod.java\n+++ b/src/main/java/org/joda/time/base/BasePeriod.java\n@@ -219,8 +219,13 @@ protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+        super();\n         // bug [3264409]\n+        iType = PeriodType.time();\n+        int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n+        iType = PeriodType.standard();\n+        iValues = new int[8];\n+        System.arraycopy(values, 0, iValues, 4, 4);\n     }\n \n     /**\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 966,
    "bugId": 391,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -561,6 +561,11 @@ private static synchronized String getConvertedId(String id) {\n             // Backwards compatibility with TimeZone.\n             map = new HashMap<String, String>();\n             map.put(\"GMT\", \"UTC\");\n+            map.put(\"WET\", \"WET\");\n+            map.put(\"CET\", \"CET\");\n+            map.put(\"MET\", \"CET\");\n+            map.put(\"ECT\", \"CET\");\n+            map.put(\"EET\", \"EET\");\n             map.put(\"MIT\", \"Pacific/Apia\");\n             map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n             map.put(\"AST\", \"America/Anchorage\");\n@@ -569,23 +574,19 @@ private static synchronized String getConvertedId(String id) {\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n+            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n             map.put(\"PRT\", \"America/Puerto_Rico\");\n             map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n+            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n             map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n             map.put(\"ART\", \"Africa/Cairo\");\n             map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n             map.put(\"NET\", \"Asia/Yerevan\");\n             map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n+            map.put(\"IST\", \"Asia/Kolkata\");\n             map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 967,
    "bugId": 392,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,15 @@ public int getOffsetFromLocal(long instantLocal) {\n                     return offsetLocal;\n                 }\n             }\n+        } else if (offsetLocal > 0) {\n+            long prev = previousTransition(instantAdjusted);\n+            if (prev < instantAdjusted) {\n+                int offsetPrev = getOffset(prev);\n+                int diff = offsetPrev - offsetLocal;\n+                if (instantAdjusted - prev <= diff) {\n+                    return offsetPrev;\n+                }\n+            }\n         }\n         return offsetAdjusted;\n     }\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 968,
    "bugId": 393,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/src/main/java/org/joda/time/chrono/ZonedChronology.java\n@@ -433,7 +433,7 @@ public long add(long instant, int value) {\n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n-               return iZone.convertLocalToUTC(localInstant, false);\n+               return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }\n \n@@ -445,7 +445,7 @@ public long add(long instant, long value) {\n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n-               return iZone.convertLocalToUTC(localInstant, false);\n+               return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }\n \n@@ -457,14 +457,14 @@ public long addWrapField(long instant, int value) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.addWrapField(localInstant, value);\n-                return iZone.convertLocalToUTC(localInstant, false);\n+                return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }\n \n         public long set(long instant, int value) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, value);\n-            long result = iZone.convertLocalToUTC(localInstant, false);\n+            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n             if (get(result) != value) {\n                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                     \"Illegal instant due to time zone offset transition: \" +\n@@ -478,7 +478,7 @@ public long set(long instant, String text, Locale locale) {\n             // cannot verify that new value stuck because set may be lenient\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, text, locale);\n-            return iZone.convertLocalToUTC(localInstant, false);\n+            return iZone.convertLocalToUTC(localInstant, false, instant);\n         }\n \n         public int getDifference(long minuendInstant, long subtrahendInstant) {\n@@ -525,7 +525,7 @@ public long roundFloor(long instant) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundFloor(localInstant);\n-                return iZone.convertLocalToUTC(localInstant, false);\n+                return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }\n \n@@ -537,7 +537,7 @@ public long roundCeiling(long instant) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundCeiling(localInstant);\n-                return iZone.convertLocalToUTC(localInstant, false);\n+                return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }\n \n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 969,
    "bugId": 393,
    "name": "Patch_194_27",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/joda/time/chrono/ZonedChronology.java b/src/main/java/org/joda/time/chrono/ZonedChronology.java\nindex f165f3d..3de48de 100644\n--- a/src/main/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/src/main/java/org/joda/time/chrono/ZonedChronology.java\n@@ -464,7 +464,7 @@ public final class ZonedChronology extends AssembledChronology {\n         public long set(long instant, int value) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, value);\n-            long result = iZone.convertLocalToUTC(localInstant, false);\n+            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n             if (get(result) != value) {\n                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                     \"Illegal instant due to time zone offset transition: \" +",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 970,
    "bugId": 393,
    "name": "Patch_61_47",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/joda/time/chrono/ZonedChronology.java b/src/main/java/org/joda/time/chrono/ZonedChronology.java\nindex f165f3d..3de48de 100644\n--- a/src/main/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/src/main/java/org/joda/time/chrono/ZonedChronology.java\n@@ -464,7 +464,7 @@ public final class ZonedChronology extends AssembledChronology {\n         public long set(long instant, int value) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, value);\n-            long result = iZone.convertLocalToUTC(localInstant, false);\n+            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n             if (get(result) != value) {\n                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                     \"Illegal instant due to time zone offset transition: \" +",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 971,
    "bugId": 393,
    "name": "Patch_72_29",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/joda/time/chrono/ZonedChronology.java b/src/main/java/org/joda/time/chrono/ZonedChronology.java\nindex f165f3d..3de48de 100644\n--- a/src/main/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/src/main/java/org/joda/time/chrono/ZonedChronology.java\n@@ -464,7 +464,7 @@ public final class ZonedChronology extends AssembledChronology {\n         public long set(long instant, int value) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, value);\n-            long result = iZone.convertLocalToUTC(localInstant, false);\n+            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n             if (get(result) != value) {\n                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                     \"Illegal instant due to time zone offset transition: \" +",
    "description": "",
    "tags": [
      {
        "tagId": 1,
        "description": "",
        "references": [
          { "referenceId": 1, "fieldNames": [] },
          { "referenceId": 3, "fieldNames": ["tagId"] }
        ]
      }
    ],
    "references": [
      { "referenceId": 3, "fieldNames": [] },
      { "referenceId": 1, "fieldNames": ["id", "description", "references"] }
    ]
  },
  {
    "id": 972,
    "bugId": 394,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,11 @@ public long computeMillis(boolean resetFields, String text) {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+            if (resetFields) {\n+                for (int i = 0; i < count; i++) {\n+                    millis = savedFields[i].set(millis, i == (count - 1));\n+                }\n+            }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  },
  {
    "id": 973,
    "bugId": 395,
    "name": "",
    "tool": "Human",
    "diff": "--- a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n@@ -798,9 +798,11 @@ private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no\n         int size = elementPairs.size();\n         if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n             Separator sep = (Separator) elementPairs.get(0);\n+            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                 sep = sep.finish(f.getPrinter(), f.getParser());\n                 return new PeriodFormatter(sep, sep);\n+            }\n         }\n         Object[] comp = createComposite(elementPairs);\n         if (notPrinter) {\n",
    "description": "",
    "tags": [],
    "references": [
      { "referenceId": 2, "fieldNames": [] },
      {
        "referenceId": 1,
        "fieldNames": ["id", "name", "description", "references"]
      }
    ]
  }
]
