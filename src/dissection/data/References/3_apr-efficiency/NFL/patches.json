[
  {
    "id": 1,
    "bugId": 309,
    "name": "Patch_3093_2946",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Math_85/src/java/org/apache/commons/math/distribution/NormalDistributionImpljava\n+++ /tmp/Cardumen_Defects4J_Math_85/src/java/org/apache/commons/math/distribution/NormalDistributionImpljava\n@@ -178,7 +178,7 @@\n \t\tif (p < 0.5) {\n \t\t\tret = -(java.lang.Double.MAX_VALUE);\n \t\t}else {\n-\t\t\tret = getMean();\n+\t\t\tret = ((standardDeviation) - (standardDeviation)) / ((mean) * (java.lang.Math.sqrt(2.0)));\n \t\t}\n \n \t\treturn ret;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 1,
    "bugId": 309,
    "name": "Patch_5_5",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf53..417355472 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,6 +195,12 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n+// start of generated patch\n+if(fa*upperBound>=0.0){\n+throw new ConvergenceException(\"number of iterations={0}, maximum iterations={1}, \"+\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb);\n+}\n+// end of generated patch\n+/* start of original code\n         if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n@@ -203,6 +209,7 @@ public class UnivariateRealSolverUtils {\n                       numIterations, maximumIterations, initial,\n                       lowerBound, upperBound, a, b, fa, fb);\n         }\n+ end of original code*/\n         \n         return new double[]{a, b};\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 1,
    "bugId": 309,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -198,8 +198,10 @@\n         if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+            if (false) {\n+                throw new ConvergenceException(\n+                \"number of iterations={0}, maximum iterations={1}, \" +\n+                \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n+                \"final b value={6}, f(a)={7}, f(b)={8}\",\n+                numIterations, maximumIterations, initial,\n+                lowerBound, upperBound, a, b, fa, fb);\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 1,
    "bugId": 309,
    "name": "Patch_15_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf..dc9479b 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,8 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n+if (fa * fb >= 0.0 &&!(fa * fb==0.0)) {            throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 1,
    "bugId": 309,
    "name": "Patch_22_11",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-07-31 07:09:20.145761363 -0400\n+++ /tmp/Arja_Defects4J_Math_85/patches_bgjg/Patch_11/patched/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-07-31 07:15:17.938253459 -0400\n@@ -196,12 +196,6 @@\n                 ((a > lowerBound) || (b < upperBound)));\n    \n         if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n         }\n         \n         return new double[]{a, b};\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 1,
    "bugId": 309,
    "name": "Patch_69_69",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n+++ /tmp/jMutRepair_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n@@ -195,7 +195,7 @@\n \t\t} while ((((fa * fb) > 0.0) && (numIterations < maximumIterations)) && \n \t\t((a > lowerBound) || (b < upperBound)) );\n \n-\t\tif ((fa * fb) >= 0.0) {\n+\t\tif ((fa * fb) > 0.0) {\n \t\t\tthrow new org.apache.commons.math.ConvergenceException(\n \t\t\t(\"number of iterations={0}, maximum iterations={1}, \" + \n \t\t\t(\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 1,
    "bugId": 309,
    "name": "Patch_5_2",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n+++ /tmp/jGenProg_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsjava\n@@ -196,12 +196,12 @@\n \t\t((a > lowerBound) || (b < upperBound)) );\n \n \t\tif ((fa * fb) >= 0.0) {\n-\t\t\tthrow new org.apache.commons.math.ConvergenceException(\n-\t\t\t(\"number of iterations={0}, maximum iterations={1}, \" + \n-\t\t\t(\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \n-\t\t\t\"final b value={6}, f(a)={7}, f(b)={8}\")), \n-\t\t\tnumIterations, maximumIterations, initial, \n-\t\t\tlowerBound, upperBound, a, b, fa, fb);\n+\n+\n+\n+\n+\n+\n \t\t}\n \n \t\treturn new double[]{ a, b };\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 1,
    "bugId": 309,
    "name": "Patch_7_7",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf..edd4436 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -196,12 +196,7 @@ public class UnivariateRealSolverUtils {\n                 ((a > lowerBound) || (b < upperBound)));\n    \n         if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+            \n         }\n         \n         return new double[]{a, b};",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 1,
    "bugId": 309,
    "name": "Patch_3_1",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf..edd4436 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -196,12 +196,7 @@ public class UnivariateRealSolverUtils {\n                 ((a > lowerBound) || (b < upperBound)));\n    \n         if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+            \n         }\n         \n         return new double[]{a, b};",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 1,
    "bugId": 309,
    "name": "Patch_26_4",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-08-03 01:05:43.548177108 -0400\n+++ /tmp/RSRepair_Defects4J_Math_85/patches_86fl/Patch_4/patched/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-08-03 01:14:32.861781309 -0400\n@@ -196,12 +196,6 @@\n                 ((a > lowerBound) || (b < upperBound)));\n    \n         if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n         }\n         \n         return new double[]{a, b};\n\n\n--- /tmp/RSRepair_Defects4J_Math_85/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\t2019-08-03 01:05:43.548177108 -0400\n+++ /tmp/RSRepair_Defects4J_Math_85/patches_86fl/Patch_4/patched/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\t2019-08-03 01:14:32.873781436 -0400\n@@ -97,9 +97,6 @@\n             if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\n                 return lowerBound;\n             }\n-            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n-                return upperBound;\n-            }     \n             // Failed bracket convergence was not because of corner solution\n             throw new MathException(ex);\n         }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 1,
    "bugId": 309,
    "name": "Patch_220_40",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-08-01 09:58:40.065705381 -0400\n+++ /tmp/GenProg_Defects4J_Math_85/patches_j3jy/Patch_40/patched/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-08-01 10:07:16.324917859 -0400\n@@ -187,7 +187,8 @@\n     \n         do {\n             a = Math.max(a - 1.0, lowerBound);\n-            b = Math.min(b + 1.0, upperBound);\n+            int i = 0;\n+\t\t\tb = Math.min(b + 1.0, upperBound);\n             fa = function.value(a);\n             \n             fb = function.value(b);\n@@ -196,12 +197,6 @@\n                 ((a > lowerBound) || (b < upperBound)));\n    \n         if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n         }\n         \n         return new double[]{a, b};\n\n\n--- /tmp/GenProg_Defects4J_Math_85/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\t2019-08-01 09:58:40.065705381 -0400\n+++ /tmp/GenProg_Defects4J_Math_85/patches_j3jy/Patch_40/patched/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\t2019-08-01 10:07:16.336917956 -0400\n@@ -97,7 +97,10 @@\n             if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\n                 return lowerBound;\n             }\n-            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n+            if (p == 0) {\n+\t\t\t\treturn Double.NEGATIVE_INFINITY;\n+\t\t\t}\n+\t\t\tif (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n                 return upperBound;\n             }     \n             // Failed bracket convergence was not because of corner solution\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 2,
    "bugId": 12,
    "name": "Patch_141_69",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Chart_11/source/org/jfree/chart/util/ShapeUtilitiesjava\n+++ /tmp/Cardumen_Defects4J_Chart_11/source/org/jfree/chart/util/ShapeUtilitiesjava\n@@ -271,7 +271,7 @@\n \t\tif ((p1.getWindingRule()) != (p2.getWindingRule())) {\n \t\t\treturn false;\n \t\t}\n-\t\tjava.awt.geom.PathIterator iterator1 = p1.getPathIterator(null);\n+\t\tjava.awt.geom.PathIterator iterator1 = p2.getPathIterator(null);\n \t\tjava.awt.geom.PathIterator iterator2 = p1.getPathIterator(null);\n \t\tdouble[] d1 = new double[6];\n \t\tdouble[] d2 = new double[6];\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 2,
    "bugId": 12,
    "name": "Patch_38_34",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/util/ShapeUtilities.java b/source/org/jfree/chart/util/ShapeUtilities.java\nindex 31aa6c6..d0ee549 100644\n--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -271,7 +271,7 @@ public class ShapeUtilities {\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n-        PathIterator iterator1 = p1.getPathIterator(null);\n+        PathIterator iterator1 = p2.getPathIterator(null);\n         PathIterator iterator2 = p1.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 2,
    "bugId": 12,
    "name": "Patch_155_50",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/util/ShapeUtilities.java b/source/org/jfree/chart/util/ShapeUtilities.java\nindex 31aa6c6..d0ee549 100644\n--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -271,7 +271,7 @@ public class ShapeUtilities {\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n-        PathIterator iterator1 = p1.getPathIterator(null);\n+        PathIterator iterator1 = p2.getPathIterator(null);\n         PathIterator iterator2 = p1.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 2,
    "bugId": 12,
    "name": "Patch_102_60",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/util/ShapeUtilities.java b/source/org/jfree/chart/util/ShapeUtilities.java\nindex 31aa6c6..d0ee549 100644\n--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -271,7 +271,7 @@ public class ShapeUtilities {\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n-        PathIterator iterator1 = p1.getPathIterator(null);\n+        PathIterator iterator1 = p2.getPathIterator(null);\n         PathIterator iterator2 = p1.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 3,
    "bugId": 316,
    "name": "Patch_33_32",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpljava\n+++ /tmp/Cardumen_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpljava\n@@ -142,9 +142,9 @@\n \n \tprotected double getInitialDomain(double p) {\n \t\tdouble ret;\n-\t\tdouble d = getDenominatorDegreesOfFreedom();\n+\t\tdouble d = \n \n-\t\tret = d / (d - 2.0);\n+\t\tp - 2.0; \t\tret = d / (d - 2.0);\n \t\treturn ret;\n \t}\n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 3,
    "bugId": 316,
    "name": "Patch_179_153",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-07-31 15:45:19.658537419 -0400\n+++ /tmp/Arja_Defects4J_Math_95/patches_9bcp/Patch_153/patched/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-07-31 15:53:44.841617251 -0400\n@@ -97,7 +97,8 @@\n      */\n     public double inverseCumulativeProbability(final double p) \n         throws MathException {\n-        if (p == 0) {\n+        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n+\t\tif (p == 0) {\n             return 0d;\n         }\n         if (p == 1) {\n@@ -145,7 +146,7 @@\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n-        return ret;\n+        return 0;\n     }\n     \n     /**\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 3,
    "bugId": 316,
    "name": "Patch_53_25",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\nindex e19e97a..95f1df5 100644\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n@@ -145,7 +145,7 @@ public class FDistributionImpl\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n-        return ret;\n+        return d;\n     }\n     \n     /**\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 3,
    "bugId": 316,
    "name": "Patch_72_42",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpljava\n+++ /tmp/jGenProg_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpljava\n@@ -144,7 +144,7 @@\n \t\tdouble ret;\n \t\tdouble d = getDenominatorDegreesOfFreedom();\n \n-\t\tret = d / (d - 2.0);\n+\t\tret = d / (d - 2.0); \t\tret = 0.0;\n \t\treturn ret;\n \t}\n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 3,
    "bugId": 316,
    "name": "Patch_56_20",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\nindex e19e97a..94ca2f0 100644\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n@@ -144,7 +144,7 @@ public class FDistributionImpl\n         double ret;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n-            ret = d / (d - 2.0);\n+            ret = d / (d + 2.0);\n         return ret;\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 3,
    "bugId": 316,
    "name": "Patch_167_36",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-08-03 02:47:48.993031315 -0400\n+++ /tmp/RSRepair_Defects4J_Math_95/patches_qui7/Patch_36/patched/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-08-03 02:54:18.165151741 -0400\n@@ -143,8 +143,7 @@\n     protected double getInitialDomain(double p) {\n         double ret;\n         double d = getDenominatorDegreesOfFreedom();\n-            // use mean\n-            ret = d / (d - 2.0);\n+            ret = 1.0;\n         return ret;\n     }\n     \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 3,
    "bugId": 316,
    "name": "Patch_817_386",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-08-01 18:27:13.538747654 -0400\n+++ /tmp/GenProg_Defects4J_Math_95/patches_eusf/Patch_386/patched/org/apache/commons/math/distribution/FDistributionImpl.java\t2019-08-01 18:41:21.707657011 -0400\n@@ -72,7 +72,10 @@\n         if (x <= 0.0) {\n             ret = 0.0;\n         } else {\n-            double n = getNumeratorDegreesOfFreedom();\n+            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+\t\t\tsetDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+\t\t\tsetDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+\t\t\tdouble n = getNumeratorDegreesOfFreedom();\n             double m = getDenominatorDegreesOfFreedom();\n             \n             ret = Beta.regularizedBeta((n * x) / (m + n * x),\n@@ -145,7 +148,7 @@\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n-        return ret;\n+        return p;\n     }\n     \n     /**\n\n\n--- /tmp/GenProg_Defects4J_Math_95/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\t2019-08-01 18:27:09.918709629 -0400\n+++ /tmp/GenProg_Defects4J_Math_95/patches_eusf/Patch_386/patched/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\t2019-08-01 18:41:21.727657221 -0400\n@@ -176,9 +176,8 @@\n             (\"bad value for maximumIterations: \" + maximumIterations);\n         }\n         if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n-            throw new IllegalArgumentException\n-            (\"Invalid endpoint parameters:  lowerBound=\" + lowerBound + \n-              \" initial=\" + initial + \" upperBound=\" + upperBound);\n+            int i = 0;\n+\t\t\tthrow new IllegalArgumentException(\"Function is not polynomial.\");\n         }\n         double a = initial;\n         double b = initial;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 3,
    "bugId": 316,
    "name": "Patch_27_27",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2018-12-01 16:37:45.439471652 -0500\n+++ /tmp/Kali_Defects4J_Math_95/patches_wycb/Patch_25/patched/tmp/Kali_Defects4J_Math_95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2018-12-01 16:38:55.571474896 -0500\n@@ -142,7 +142,9 @@\n      */\n     protected double getInitialDomain(double p) {\n         double ret;\n-        double d = getDenominatorDegreesOfFreedom();\n+        if (true)\n+\t\t\treturn 0;\n+\t\tdouble d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 4,
    "bugId": 88,
    "name": "Patch_33_33",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Closure_63/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n+++ /tmp/Cardumen_Defects4J_Closure_63/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n@@ -94,8 +94,8 @@\n \n \n \n-\t\t\tif (((excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n-\t\t\t(0 <= charno)) && (charno < (sourceExcerpt.length()))) {\n+\t\t\tif (sourceExcerpt != null) \n+\t\t\t{\n \t\t\t\tfor (int i = 0; i < charno; i++) {\n \t\t\t\t\tchar c = sourceExcerpt.charAt(i);\n \t\t\t\t\tif (java.lang.Character.isWhitespace(c)) {\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 4,
    "bugId": 88,
    "name": "Patch_1218_1218",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884c..c1488582 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -94,6 +94,20 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n+// start of generated patch\n+if(excerpt.equals(LINE)&&0<=charno&&charno<=sourceExcerpt.length()){\n+for(int i=0;i<charno;i++){\n+char c=sourceExcerpt.charAt(i);\n+if(Character.isWhitespace(c)){\n+b.append(c);\n+}else {\n+b.append(' ');\n+}\n+}\n+b.append(\"^\\n\");\n+}\n+// end of generated patch\n+/* start of original code\n       if (excerpt.equals(LINE)\n           && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n@@ -106,6 +120,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n         }\n         b.append(\"^\\n\");\n       }\n+ end of original code*/\n     }\n     return b.toString();\n   }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 4,
    "bugId": 88,
    "name": "Patch_52_19",
    "tool": "AVATAR",
    "diff": "diff --git a/build/lib/rhino1_7R3pre/js.jar b/build/lib/rhino1_7R3pre/js.jar\nindex f551981..37f3a40 100644\nBinary files a/build/lib/rhino1_7R3pre/js.jar and b/build/lib/rhino1_7R3pre/js.jar differ\ndiff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..420dbc0 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 4,
    "bugId": 88,
    "name": "Patch_14_14",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Closure_63/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n+++ /tmp/jMutRepair_Defects4J_Closure_63/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n@@ -94,8 +94,8 @@\n \n \n \n-\t\t\tif (((excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n-\t\t\t(0 <= charno)) && (charno < (sourceExcerpt.length()))) {\n+\t\t\tif (((this.excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n+\t\t\t(0 <= charno)) && (charno <= (sourceExcerpt.length()))) {\n \t\t\t\tfor (int i = 0; i < charno; i++) {\n \t\t\t\t\tchar c = sourceExcerpt.charAt(i);\n \t\t\t\t\tif (java.lang.Character.isWhitespace(c)) {\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 4,
    "bugId": 88,
    "name": "Patch_3_3",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Closure_63/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n+++ /tmp/jKali_Defects4J_Closure_63/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n@@ -94,8 +94,8 @@\n \n \n \n-\t\t\tif (((excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n-\t\t\t(0 <= charno)) && (charno < (sourceExcerpt.length()))) {\n+\t\t\tif (true) \n+\t\t\t{\n \t\t\t\tfor (int i = 0; i < charno; i++) {\n \t\t\t\t\tchar c = sourceExcerpt.charAt(i);\n \t\t\t\t\tif (java.lang.Character.isWhitespace(c)) {\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 4,
    "bugId": 88,
    "name": "Patch_22_19",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..d2ac04b 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -94,8 +94,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n-      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+      if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 4,
    "bugId": 88,
    "name": "Patch_43_31",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..ff1e396 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno<=sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 5,
    "bugId": 297,
    "name": "Patch_13_13",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolverjava\n+++ /tmp/Cardumen_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolverjava\n@@ -135,7 +135,7 @@\n \n \n \n-\t\treturn solve(f, min, yMin, max, yMax, initial, yInitial);\n+\t\treturn solve(f, max, max);\n \n \t}\n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 5,
    "bugId": 297,
    "name": "Patch_4_4",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..1013b983c 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -129,6 +129,13 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         }\n \n         // reduce interval if initial and max bracket the root\n+// start of generated patch\n+if(yInitial*yMax<0){\n+return solve(f,initial,yInitial,max,yMax,initial,yInitial);\n+}\n+return solve(f,min,initial);\n+// end of generated patch\n+/* start of original code\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n@@ -136,6 +143,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n+ end of original code*/\n \n     }\n ",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 5,
    "bugId": 297,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5e..13af1aa 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -134,7 +134,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+if (initial>(double)0.0){throw new IllegalArgumentException();}        // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 5,
    "bugId": 297,
    "name": "Patch_25_22",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolverjava\n+++ /tmp/jGenProg_Defects4J_Math_73/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolverjava\n@@ -131,11 +131,11 @@\n \n \t\tif ((yInitial * yMax) < 0) {\n \t\t\treturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-\t\t}\n+\t\t} \t\treturn solve(f, min, max);\n+\n \n \n \n-\t\treturn solve(f, min, yMin, max, yMax, initial, yInitial);\n \n \t}\n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 5,
    "bugId": 297,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n@@ -224,6 +224,6 @@\n     protected void verifySequence(final double lower, final double initial, final double upper) {\n-        if (!isSequence(lower, initial, upper)) {\n+        if ((!(lower < initial)) || ((org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result <= lower) && (1 == lower))) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n-                    lower, initial, upper);\n+            \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n+            lower, initial, upper);\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 6,
    "bugId": 286,
    "name": "Patch_1_1",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Math_63/src/main/java/org/apache/commons/math/util/MathUtilsjava\n+++ /tmp/Cardumen_Defects4J_Math_63/src/main/java/org/apache/commons/math/util/MathUtilsjava\n@@ -414,8 +414,7 @@\n \n \n \tpublic static boolean equals(double x, double y) {\n-\t\treturn ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (x == y);\n-\t}\n+\t\treturn (\n \n \n \n@@ -425,9 +424,6 @@\n \n \n \n-\tpublic static boolean equalsIncludingNaN(double x, double y) {\n-\t\treturn ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, 1));\n-\t}\n \n \n \n@@ -438,9 +434,6 @@\n \n \n \n-\tpublic static boolean equals(double x, double y, double eps) {\n-\t\treturn (org.apache.commons.math.util.MathUtils.equals(x, y, 1)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);\n-\t}\n \n \n \n@@ -452,9 +445,6 @@\n \n \n \n-\tpublic static boolean equalsIncludingNaN(double x, double y, double eps) {\n-\t\treturn (org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x, y)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);\n-\t}\n \n \n \n@@ -473,26 +463,13 @@\n \n \n \n-\tpublic static boolean equals(double x, double y, int maxUlps) {\n \n \n-\t\tassert (maxUlps > 0) && (maxUlps < (org.apache.commons.math.util.MathUtils.NAN_GAP));\n \n-\t\tlong xInt = java.lang.Double.doubleToLongBits(x);\n-\t\tlong yInt = java.lang.Double.doubleToLongBits(y);\n \n \n-\t\tif (xInt < 0) {\n-\t\t\txInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - xInt;\n-\t\t}\n-\t\tif (yInt < 0) {\n-\t\t\tyInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - yInt;\n-\t\t}\n \n-\t\tfinal boolean isEqual = (org.apache.commons.math.util.FastMath.abs((xInt - yInt))) <= maxUlps;\n \n-\t\treturn (isEqual && (!(java.lang.Double.isNaN(x)))) && (!(java.lang.Double.isNaN(y)));\n-\t}\n \n \n \n@@ -505,9 +482,6 @@\n \n \n \n-\tpublic static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n-\t\treturn ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, maxUlps));\n-\t}\n \n \n \n@@ -519,20 +493,6 @@\n \n \n \n-\tpublic static boolean equals(double[] x, double[] y) {\n-\t\tif ((x == null) || (y == null)) {\n-\t\t\treturn !((x == null) ^ (y == null));\n-\t\t}\n-\t\tif ((x.length) != (y.length)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tfor (int i = 0; i < (x.length); ++i) {\n-\t\t\tif (!(org.apache.commons.math.util.MathUtils.equals(x[i], y[i]))) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n \n \n \n@@ -544,20 +504,6 @@\n \n \n \n-\tpublic static boolean equalsIncludingNaN(double[] x, double[] y) {\n-\t\tif ((x == null) || (y == null)) {\n-\t\t\treturn !((x == null) ^ (y == null));\n-\t\t}\n-\t\tif ((x.length) != (y.length)) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tfor (int i = 0; i < (x.length); ++i) {\n-\t\t\tif (!(org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x[i], y[i]))) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n \n \n \n@@ -581,18 +527,6 @@\n \n \n \n-\tpublic static long factorial(final int n) {\n-\t\tif (n < 0) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, \n-\t\t\tn);\n-\t\t}\n-\t\tif (n > 20) {\n-\t\t\tthrow new java.lang.ArithmeticException(\n-\t\t\t\"factorial value is too large to fit in a long\");\n-\t\t}\n-\t\treturn org.apache.commons.math.util.MathUtils.FACTORIALS[n];\n-\t}\n \n \n \n@@ -614,17 +548,6 @@\n \n \n \n-\tpublic static double factorialDouble(final int n) {\n-\t\tif (n < 0) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, \n-\t\t\tn);\n-\t\t}\n-\t\tif (n < 21) {\n-\t\t\treturn org.apache.commons.math.util.MathUtils.factorial(n);\n-\t\t}\n-\t\treturn org.apache.commons.math.util.FastMath.floor(((org.apache.commons.math.util.FastMath.exp(org.apache.commons.math.util.MathUtils.factorialLog(n))) + 0.5));\n-\t}\n \n \n \n@@ -639,21 +562,6 @@\n \n \n \n-\tpublic static double factorialLog(final int n) {\n-\t\tif (n < 0) {\n-\t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\n-\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, \n-\t\t\tn);\n-\t\t}\n-\t\tif (n < 21) {\n-\t\t\treturn org.apache.commons.math.util.FastMath.log(org.apache.commons.math.util.MathUtils.factorial(n));\n-\t\t}\n-\t\tdouble logSum = 0;\n-\t\tfor (int i = 2; i <= n; i++) {\n-\t\t\tlogSum += org.apache.commons.math.util.FastMath.log(i);\n-\t\t}\n-\t\treturn logSum;\n-\t}\n \n \n \n@@ -684,31 +592,123 @@\n \n \n \n-\tpublic static int gcd(final int p, final int q) {\n-\t\tint u = p;\n-\t\tint v = q;\n-\t\tif ((u == 0) || (v == 0)) {\n-\t\t\tif ((u == (java.lang.Integer.MIN_VALUE)) || (v == (java.lang.Integer.MIN_VALUE))) {\n-\t\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(\n-\t\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_32_BITS, \n-\t\t\t\tp, q);\n-\t\t\t}\n-\t\t\treturn (org.apache.commons.math.util.FastMath.abs(u)) + (org.apache.commons.math.util.FastMath.abs(v));\n-\t\t}\n \n \n \n \n \n-\t\tif (u > 0) {\n-\t\t\tu = -u;\n-\t\t}\n-\t\tif (v > 0) {\n-\t\t\tv = -v;\n-\t\t}\n \n-\t\tint k = 0;\n-\t\twhile ((((u & 1) == 0) && ((v & 1) == 0)) && (k < 31)) {\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\t\t(((((NAN_GAP) & 1) == 0) && (((NAN_GAP) & 1) == 0)) && ((NAN_GAP) < 31)) && (java.lang.Double.isNaN(y))) || (x == y);} \tpublic static boolean equalsIncludingNaN(double x, double y) { \t\treturn ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, 1));} \tpublic static boolean equals(double x, double y, double eps) { \t\treturn (org.apache.commons.math.util.MathUtils.equals(x, y, 1)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);} \tpublic static boolean equalsIncludingNaN(double x, double y, double eps) { \t\treturn (org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x, y)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);} \tpublic static boolean equals(double x, double y, int maxUlps) { \t\tassert (maxUlps > 0) && (maxUlps < (org.apache.commons.math.util.MathUtils.NAN_GAP)); \t\tlong xInt = java.lang.Double.doubleToLongBits(x); \t\tlong yInt = java.lang.Double.doubleToLongBits(y); \t\tif (xInt < 0) { \t\t\txInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - xInt;} \t\tif (yInt < 0) { \t\t\tyInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - yInt;} \t\tfinal boolean isEqual = (org.apache.commons.math.util.FastMath.abs((xInt - yInt))) <= maxUlps; \t\treturn (isEqual && (!(java.lang.Double.isNaN(x)))) && (!(java.lang.Double.isNaN(y)));} \tpublic static boolean equalsIncludingNaN(double x, double y, int maxUlps) { \t\treturn ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, maxUlps));} \tpublic static boolean equals(double[] x, double[] y) { \t\tif ((x == null) || (y == null)) { \t\t\treturn !((x == null) ^ (y == null));} \t\tif ((x.length) != (y.length)) { \t\t\treturn false;} \t\tfor (int i = 0; i < (x.length); ++i) { \t\t\tif (!(org.apache.commons.math.util.MathUtils.equals(x[i], y[i]))) { \t\t\t\treturn false;}} \t\treturn true;} \tpublic static boolean equalsIncludingNaN(double[] x, double[] y) { \t\tif ((x == null) || (y == null)) { \t\t\treturn !((x == null) ^ (y == null));} \t\tif ((x.length) != (y.length)) { \t\t\treturn false;} \t\tfor (int i = 0; i < (x.length); ++i) { \t\t\tif (!(org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x[i], y[i]))) { \t\t\t\treturn false;}} \t\treturn true;} \tpublic static long factorial(final int n) { \t\tif (n < 0) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);} \t\tif (n > 20) { \t\t\tthrow new java.lang.ArithmeticException(\"factorial value is too large to fit in a long\");} \t\treturn org.apache.commons.math.util.MathUtils.FACTORIALS[n];} \tpublic static double factorialDouble(final int n) { \t\tif (n < 0) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);} \t\tif (n < 21) { \t\t\treturn org.apache.commons.math.util.MathUtils.factorial(n);} \t\treturn org.apache.commons.math.util.FastMath.floor(((org.apache.commons.math.util.FastMath.exp(org.apache.commons.math.util.MathUtils.factorialLog(n))) + 0.5));} \tpublic static double factorialLog(final int n) { \t\tif (n < 0) { \t\t\tthrow org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);} \t\tif (n < 21) { \t\t\treturn org.apache.commons.math.util.FastMath.log(org.apache.commons.math.util.MathUtils.factorial(n));} \t\tdouble logSum = 0; \t\tfor (int i = 2; i <= n; i++) { \t\t\tlogSum += org.apache.commons.math.util.FastMath.log(i);} \t\treturn logSum;} \tpublic static int gcd(final int p, final int q) { \t\tint u = p; \t\tint v = q; \t\tif ((u == 0) || (v == 0)) { \t\t\tif ((u == (java.lang.Integer.MIN_VALUE)) || (v == (java.lang.Integer.MIN_VALUE))) { \t\t\t\tthrow org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);} \t\t\treturn (org.apache.commons.math.util.FastMath.abs(u)) + (org.apache.commons.math.util.FastMath.abs(v));} \t\tif (u > 0) { \t\t\tu = -u;} \t\tif (v > 0) { \t\t\tv = -v;} \t\tint k = 0; \t\twhile ((((u & 1) == 0) && ((v & 1) == 0)) && (k < 31)) {\n \n \t\t\tu /= 2;\n \t\t\tv /= 2;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 6,
    "bugId": 286,
    "name": "Patch_28_28",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 136184990..fc1233615 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -414,7 +414,12 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n+// start of generated patch\n+return equals(x,y,1)||FastMath.abs(y-x)<=SAFE_MIN;\n+// end of generated patch\n+/* start of original code\n         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+ end of original code*/\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 6,
    "bugId": 286,
    "name": "Patch_4_4",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 1361849..84fbcca 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x == y;\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 6,
    "bugId": 286,
    "name": "Patch_4_4",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 1361849..84fbcca 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x == y;\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 6,
    "bugId": 286,
    "name": "Patch_611_159",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 1361849..6943238 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -527,7 +527,7 @@ public final class MathUtils {\n             return false;\n         }\n         for (int i = 0; i < x.length; ++i) {\n-            if (!equals(x[i], y[i])) {\n+            if (!equals(x[i], y[i], i)) {\n                 return false;\n             }\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 7,
    "bugId": 1,
    "name": "Patch_659_644",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Chart_6/source/org/jfree/chart/util/ShapeListjava\n+++ /tmp/Cardumen_Defects4J_Chart_6/source/org/jfree/chart/util/ShapeListjava\n@@ -78,7 +78,7 @@\n \n \n \tpublic void setShape(int index, java.awt.Shape shape) {\n-\t\tset(index, shape);\n+\t\tset(org.jfree.chart.util.AbstractObjectList.DEFAULT_INITIAL_CAPACITY, shape);\n \t}\n \n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 8,
    "bugId": 26,
    "name": "Patch_286_286",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Chart_24/source/org/jfree/chart/renderer/GrayPaintScalejava\n+++ /tmp/Cardumen_Defects4J_Chart_24/source/org/jfree/chart/renderer/GrayPaintScalejava\n@@ -123,7 +123,7 @@\n \tpublic java.awt.Paint getPaint(double value) {\n \t\tdouble v = java.lang.Math.max(value, this.lowerBound);\n \t\tv = java.lang.Math.min(v, this.upperBound);\n-\t\tint g = ((int) (((value - (this.lowerBound)) / ((this.upperBound) - \n+\t\tint g = ((int) (((java.lang.Math.min(v, upperBound)) / ((this.upperBound) - \n \t\t(this.lowerBound))) * 255.0));\n \t\treturn new java.awt.Color(g, g, g);\n \t}\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 8,
    "bugId": 26,
    "name": "Patch_38_12",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/renderer/GrayPaintScale.java b/source/org/jfree/chart/renderer/GrayPaintScale.java\nindex 1e1e075..e62c43f 100644\n--- a/source/org/jfree/chart/renderer/GrayPaintScale.java\n+++ b/source/org/jfree/chart/renderer/GrayPaintScale.java\n@@ -123,7 +123,7 @@ public class GrayPaintScale\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+        int g = (int) ((v - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 8,
    "bugId": 26,
    "name": "Patch_77_25",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/renderer/GrayPaintScale.java b/source/org/jfree/chart/renderer/GrayPaintScale.java\nindex 1e1e075..405007b 100644\n--- a/source/org/jfree/chart/renderer/GrayPaintScale.java\n+++ b/source/org/jfree/chart/renderer/GrayPaintScale.java\n@@ -122,7 +122,7 @@ public class GrayPaintScale\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n-        v = Math.min(v, this.upperBound);\n+        value = Math.min(v, this.upperBound);\n         int g = (int) ((value - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 8,
    "bugId": 26,
    "name": "Patch_42_20",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/renderer/GrayPaintScale.java b/source/org/jfree/chart/renderer/GrayPaintScale.java\nindex 1e1e075..e62c43f 100644\n--- a/source/org/jfree/chart/renderer/GrayPaintScale.java\n+++ b/source/org/jfree/chart/renderer/GrayPaintScale.java\n@@ -123,7 +123,7 @@ public class GrayPaintScale\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+        int g = (int) ((v - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 9,
    "bugId": 291,
    "name": "Patch_13_13",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolverjava\n+++ /tmp/Cardumen_Defects4J_Math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolverjava\n@@ -69,7 +69,7 @@\n \n \tpublic double solve(final org.apache.commons.math.analysis.UnivariateRealFunction f, double min, double max, double initial) throws \n \torg.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.MaxIterationsExceededException {\n-\t\treturn solve(min, max);\n+\t\treturn solve(f, min, max);\n \t}\n \n \n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 9,
    "bugId": 291,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f669271a..aec077fdb 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,12 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n+// start of generated patch\n+return solve(f,min,max);\n+// end of generated patch\n+/* start of original code\n         return solve(min, max);\n+ end of original code*/\n     }\n \n     /** {@inheritDoc} */",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 9,
    "bugId": 291,
    "name": "Patch_6_2",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolverjava\n+++ /tmp/jGenProg_Defects4J_Math_70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolverjava\n@@ -68,8 +68,8 @@\n \n \n \tpublic double solve(final org.apache.commons.math.analysis.UnivariateRealFunction f, double min, double max, double initial) throws \n-\torg.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.MaxIterationsExceededException {\n-\t\treturn solve(min, max);\n+\torg.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.MaxIterationsExceededException { \t\treturn solve(f, min, max);\n+\n \t}\n \n \n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 9,
    "bugId": 291,
    "name": "Patch_16_16",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f66927..180caef 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,7 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 9,
    "bugId": 291,
    "name": "Patch_16_16",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f66927..180caef 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,7 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 9,
    "bugId": 291,
    "name": "Patch_28_28",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f66927..180caef 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,7 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 10,
    "bugId": 86,
    "name": "Patch_33_33",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Closure_62/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n+++ /tmp/Cardumen_Defects4J_Closure_62/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n@@ -94,8 +94,8 @@\n \n \n \n-\t\t\tif (((excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n-\t\t\t(0 <= charno)) && (charno < (sourceExcerpt.length()))) {\n+\t\t\tif (sourceExcerpt != null) \n+\t\t\t{\n \t\t\t\tfor (int i = 0; i < charno; i++) {\n \t\t\t\t\tchar c = sourceExcerpt.charAt(i);\n \t\t\t\t\tif (java.lang.Character.isWhitespace(c)) {\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 10,
    "bugId": 86,
    "name": "Patch_1218_1218",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884c..c1488582 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -94,6 +94,20 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n+// start of generated patch\n+if(excerpt.equals(LINE)&&0<=charno&&charno<=sourceExcerpt.length()){\n+for(int i=0;i<charno;i++){\n+char c=sourceExcerpt.charAt(i);\n+if(Character.isWhitespace(c)){\n+b.append(c);\n+}else {\n+b.append(' ');\n+}\n+}\n+b.append(\"^\\n\");\n+}\n+// end of generated patch\n+/* start of original code\n       if (excerpt.equals(LINE)\n           && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n@@ -106,6 +120,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n         }\n         b.append(\"^\\n\");\n       }\n+ end of original code*/\n     }\n     return b.toString();\n   }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 10,
    "bugId": 86,
    "name": "Patch_52_19",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..420dbc0 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 10,
    "bugId": 86,
    "name": "Patch_14_14",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Closure_62/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n+++ /tmp/jMutRepair_Defects4J_Closure_62/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n@@ -94,8 +94,8 @@\n \n \n \n-\t\t\tif (((excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n-\t\t\t(0 <= charno)) && (charno < (sourceExcerpt.length()))) {\n+\t\t\tif (((this.excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n+\t\t\t(0 <= charno)) && (charno <= (sourceExcerpt.length()))) {\n \t\t\t\tfor (int i = 0; i < charno; i++) {\n \t\t\t\t\tchar c = sourceExcerpt.charAt(i);\n \t\t\t\t\tif (java.lang.Character.isWhitespace(c)) {\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 10,
    "bugId": 86,
    "name": "Patch_3_3",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Closure_62/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n+++ /tmp/jKali_Defects4J_Closure_62/src/com/google/javascript/jscomp/LightweightMessageFormatterjava\n@@ -94,8 +94,8 @@\n \n \n \n-\t\t\tif (((excerpt.equals(com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt.LINE)) && \n-\t\t\t(0 <= charno)) && (charno < (sourceExcerpt.length()))) {\n+\t\t\tif (true) \n+\t\t\t{\n \t\t\t\tfor (int i = 0; i < charno; i++) {\n \t\t\t\t\tchar c = sourceExcerpt.charAt(i);\n \t\t\t\t\tif (java.lang.Character.isWhitespace(c)) {\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 10,
    "bugId": 86,
    "name": "Patch_22_19",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..d2ac04b 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -94,8 +94,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n-      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+      if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 10,
    "bugId": 86,
    "name": "Patch_43_31",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884..ff1e396 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno<=sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_473_422",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Chart_13/source/org/jfree/chart/block/BorderArrangementjava\n+++ /tmp/Cardumen_Defects4J_Chart_13/source/org/jfree/chart/block/BorderArrangementjava\n@@ -149,27 +149,7 @@\n \t\t\t\t\tcontentSize = arrangeFN(container, g2, constraint.getWidth());\n \t\t\t\t}else\n \t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {\n-\t\t\t\t\t\tcontentSize = arrangeFF(container, g2, constraint);\n-\t\t\t\t\t}else\n-\t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {\n-\t\t\t\t\t\t\tcontentSize = arrangeFR(container, g2, constraint);\n-\t\t\t\t\t\t}\n-\t\t\t}else\n-\t\t\t\tif (w == (org.jfree.chart.block.LengthConstraintType.RANGE)) {\n-\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.NONE)) {\n-\t\t\t\t\t\tthrow new java.lang.RuntimeException(\"Not implemented.\");\n-\t\t\t\t\t}else\n-\t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {\n-\t\t\t\t\t\t\tthrow new java.lang.RuntimeException(\"Not implemented.\");\n-\t\t\t\t\t\t}else\n-\t\t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {\n-\t\t\t\t\t\t\t\tcontentSize = arrangeRR(container, constraint.getWidthRange(), \n-\t\t\t\t\t\t\t\tconstraint.getHeightRange(), g2);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t}\n-\t\treturn new org.jfree.chart.util.Size2D(container.calculateTotalWidth(contentSize.getWidth()), \n-\t\tcontainer.calculateTotalHeight(contentSize.getHeight()));\n-\t}\n+\t\t\t\t\t\tcontentSize = \n \n \n \n@@ -179,66 +159,9 @@\n \n \n \n-\tprotected org.jfree.chart.util.Size2D arrangeNN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2) {\n-\t\tdouble[] w = new double[5];\n-\t\tdouble[] h = new double[5];\n-\t\tif ((this.topBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);\n-\t\t\tw[0] = size.width;\n-\t\t\th[0] = size.height;\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, \n-\t\t\torg.jfree.chart.block.RectangleConstraint.NONE);\n-\t\t\tw[1] = size.width;\n-\t\t\th[1] = size.height;\n-\t\t}\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);\n-\t\t\tw[2] = size.width;\n-\t\t\th[2] = size.height;\n-\t\t}\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);\n-\t\t\tw[3] = size.width;\n-\t\t\th[3] = size.height;\n-\t\t}\n \n-\t\th[2] = java.lang.Math.max(h[2], h[3]);\n-\t\th[3] = h[2];\n \n-\t\tif ((this.centerBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, \n-\t\t\torg.jfree.chart.block.RectangleConstraint.NONE);\n-\t\t\tw[4] = size.width;\n-\t\t\th[4] = size.height;\n-\t\t}\n-\t\tdouble width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));\n-\t\tdouble centerHeight = java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4]));\n-\t\tdouble height = ((h[0]) + (h[1])) + centerHeight;\n-\t\tif ((this.topBlock) != null) {\n-\t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, \n-\t\t\th[0]));\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, \n-\t\t\t(height - (h[1])), width, h[1]));\n-\t\t}\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], \n-\t\t\tcenterHeight));\n-\t\t}\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), \n-\t\t\th[0], w[3], centerHeight));\n-\t\t}\n \n-\t\tif ((this.centerBlock) != null) {\n-\t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], \n-\t\t\t((width - (w[2])) - (w[3])), centerHeight));\n-\t\t}\n-\t\treturn new org.jfree.chart.util.Size2D(width, height);\n-\t}\n \n \n \n@@ -249,18 +172,6 @@\n \n \n \n-\tprotected org.jfree.chart.util.Size2D arrangeFR(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, \n-\torg.jfree.chart.block.RectangleConstraint constraint) {\n-\t\torg.jfree.chart.util.Size2D size1 = arrangeFN(container, g2, constraint.getWidth());\n-\t\tif (constraint.getHeightRange().contains(size1.getHeight())) {\n-\t\t\treturn size1;\n-\t\t}else \n-\t\t{\n-\t\t\tdouble h = constraint.getHeightRange().constrain(size1.getHeight());\n-\t\t\torg.jfree.chart.block.RectangleConstraint c2 = constraint.toFixedHeight(h);\n-\t\t\treturn arrange(container, g2, c2);\n-\t\t}\n-\t}\n \n \n \n@@ -272,56 +183,8 @@\n \n \n \n-\tprotected org.jfree.chart.util.Size2D arrangeFN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, \n-\tdouble width) {\n-\t\tdouble[] w = new double[5];\n-\t\tdouble[] h = new double[5];\n-\t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(width, null, \n-\t\torg.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, \n-\t\torg.jfree.chart.block.LengthConstraintType.NONE);\n-\t\tif ((this.topBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);\n-\t\t\tw[0] = size.width;\n-\t\t\th[0] = size.height;\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c1);\n-\t\t\tw[1] = size.width;\n-\t\t\th[1] = size.height;\n-\t\t}\n-\t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(0.0, \n-\t\tnew org.jfree.data.Range(0.0, width), org.jfree.chart.block.LengthConstraintType.RANGE, \n-\t\t0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c2);\n-\t\t\tw[2] = size.width;\n-\t\t\th[2] = size.height;\n-\t\t}\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\tdouble maxW = java.lang.Math.max((width - (w[2])), 0.0);\n-\t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, \n-\t\t\tnew org.jfree.data.Range(java.lang.Math.min(w[2], maxW), maxW), \n-\t\t\torg.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.NONE);\n-\t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c3);\n-\t\t\tw[3] = size.width;\n-\t\t\th[3] = size.height;\n-\t\t}\n \n-\t\th[2] = java.lang.Math.max(h[2], h[3]);\n-\t\th[3] = h[2];\n \n-\t\tif ((this.centerBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(((width - (w[2])) - \n-\t\t\t(w[3])), null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.NONE);\n-\t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c4);\n-\t\t\tw[4] = size.width;\n-\t\t\th[4] = size.height;\n-\t\t}\n-\t\tdouble height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));\n-\t\treturn arrange(container, g2, new org.jfree.chart.block.RectangleConstraint(width, height));\n-\t}\n \n \n \n@@ -334,81 +197,11 @@\n \n \n \n-\tprotected org.jfree.chart.util.Size2D arrangeRR(org.jfree.chart.block.BlockContainer container, \n-\torg.jfree.data.Range widthRange, org.jfree.data.Range heightRange, \n-\tjava.awt.Graphics2D g2) {\n-\t\tdouble[] w = new double[5];\n-\t\tdouble[] h = new double[5];\n-\t\tif ((this.topBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(widthRange, \n-\t\t\theightRange);\n-\t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);\n-\t\t\tw[0] = size.width;\n-\t\t\th[0] = size.height;\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\torg.jfree.data.Range heightRange2 = org.jfree.data.Range.shift(heightRange, (-(h[0])), false);\n-\t\t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(widthRange, \n-\t\t\theightRange2);\n-\t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);\n-\t\t\tw[1] = size.width;\n-\t\t\th[1] = size.height;\n-\t\t}\n-\t\torg.jfree.data.Range heightRange3 = org.jfree.data.Range.shift(heightRange, (-((h[0]) + (h[1]))));\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(widthRange, \n-\t\t\theightRange3);\n-\t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);\n-\t\t\tw[2] = size.width;\n-\t\t\th[2] = size.height;\n-\t\t}\n-\t\torg.jfree.data.Range widthRange2 = org.jfree.data.Range.shift(widthRange, (-(w[2])), false);\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(widthRange2, \n-\t\t\theightRange3);\n-\t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);\n-\t\t\tw[3] = size.width;\n-\t\t\th[3] = size.height;\n-\t\t}\n \n-\t\th[2] = java.lang.Math.max(h[2], h[3]);\n-\t\th[3] = h[2];\n-\t\torg.jfree.data.Range widthRange3 = org.jfree.data.Range.shift(widthRange, (-((w[2]) + (w[3]))), false);\n-\t\tif ((this.centerBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(widthRange3, \n-\t\t\theightRange3);\n \n \n \n-\t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c5);\n-\t\t\tw[4] = size.width;\n-\t\t\th[4] = size.height;\n-\t\t}\n-\t\tdouble width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));\n-\t\tdouble height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));\n-\t\tif ((this.topBlock) != null) {\n-\t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, \n-\t\t\th[0]));\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, \n-\t\t\t(height - (h[1])), width, h[1]));\n-\t\t}\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], \n-\t\t\th[2]));\n-\t\t}\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), \n-\t\t\th[0], w[3], h[3]));\n-\t\t}\n \n-\t\tif ((this.centerBlock) != null) {\n-\t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], \n-\t\t\t((width - (w[2])) - (w[3])), ((height - (h[0])) - (h[1]))));\n-\t\t}\n-\t\treturn new org.jfree.chart.util.Size2D(width, height);\n-\t}\n \n \n \n@@ -419,73 +212,280 @@\n \n \n \n-\tprotected org.jfree.chart.util.Size2D arrangeFF(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, \n-\torg.jfree.chart.block.RectangleConstraint constraint) {\n-\t\tdouble[] w = new double[5];\n-\t\tdouble[] h = new double[5];\n-\t\tw[0] = constraint.getWidth();\n-\t\tif ((this.topBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(w[0], null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.FIXED, 0.0, \n-\t\t\tnew org.jfree.data.Range(0.0, constraint.getHeight()), \n-\t\t\torg.jfree.chart.block.LengthConstraintType.RANGE);\n-\t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);\n-\t\t\th[0] = size.height;\n-\t\t}\n-\t\tw[1] = w[0];\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(w[0], null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, \n-\t\t\t((constraint.getHeight()) - (h[0]))), org.jfree.chart.block.LengthConstraintType.RANGE);\n-\t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);\n-\t\t\th[1] = size.height;\n-\t\t}\n-\t\th[2] = ((constraint.getHeight()) - (h[1])) - (h[0]);\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, \n-\t\t\tnew org.jfree.data.Range(0.0, constraint.getWidth()), \n-\t\t\torg.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.FIXED);\n-\t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);\n-\t\t\tw[2] = size.width;\n-\t\t}\n-\t\th[3] = h[2];\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(0.0, \n-\t\t\tnew org.jfree.data.Range(0.0, ((constraint.getWidth()) - (w[2]))), \n-\t\t\torg.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.FIXED);\n-\t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);\n-\t\t\tw[3] = size.width;\n-\t\t}\n-\t\th[4] = h[2];\n-\t\tw[4] = ((constraint.getWidth()) - (w[3])) - (w[2]);\n-\t\torg.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(w[4], h[4]);\n-\t\tif ((this.centerBlock) != null) {\n-\t\t\tthis.centerBlock.arrange(g2, c5);\n-\t\t}\n \n-\t\tif ((this.topBlock) != null) {\n-\t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, w[0], \n-\t\t\th[0]));\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, ((h[0]) + (h[2])), \n-\t\t\tw[1], h[1]));\n-\t\t}\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], \n-\t\t\th[2]));\n-\t\t}\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double(((w[2]) + (w[4])), h[0], \n-\t\t\tw[3], h[3]));\n-\t\t}\n-\t\tif ((this.centerBlock) != null) {\n-\t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], w[4], \n-\t\t\th[4]));\n-\t\t}\n-\t\treturn new org.jfree.chart.util.Size2D(constraint.getWidth(), constraint.getHeight());\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\t\t\t\t\t\tnew org.jfree.chart.util.Size2D(constraint.getWidth(), constraint.getHeight());}else \t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) { \t\t\t\t\t\t\tcontentSize = arrangeFR(container, g2, constraint);}}else \t\t\t\tif (w == (org.jfree.chart.block.LengthConstraintType.RANGE)) { \t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.NONE)) { \t\t\t\t\t\tthrow new java.lang.RuntimeException(\"Not implemented.\");}else \t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) { \t\t\t\t\t\t\tthrow new java.lang.RuntimeException(\"Not implemented.\");}else \t\t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) { \t\t\t\t\t\t\t\tcontentSize = arrangeRR(container, constraint.getWidthRange(), constraint.getHeightRange(), g2);}} \t\treturn new org.jfree.chart.util.Size2D(container.calculateTotalWidth(contentSize.getWidth()), container.calculateTotalHeight(contentSize.getHeight()));} \tprotected org.jfree.chart.util.Size2D arrangeNN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2) { \t\tdouble[] w = new double[5]; \t\tdouble[] h = new double[5]; \t\tif ((this.topBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE); \t\t\tw[0] = size.width; \t\t\th[0] = size.height;} \t\tif ((this.bottomBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE); \t\t\tw[1] = size.width; \t\t\th[1] = size.height;} \t\tif ((this.leftBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE); \t\t\tw[2] = size.width; \t\t\th[2] = size.height;} \t\tif ((this.rightBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE); \t\t\tw[3] = size.width; \t\t\th[3] = size.height;} \t\th[2] = java.lang.Math.max(h[2], h[3]); \t\th[3] = h[2]; \t\tif ((this.centerBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE); \t\t\tw[4] = size.width; \t\t\th[4] = size.height;} \t\tdouble width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3])))); \t\tdouble centerHeight = java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])); \t\tdouble height = ((h[0]) + (h[1])) + centerHeight; \t\tif ((this.topBlock) != null) { \t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));} \t\tif ((this.bottomBlock) != null) { \t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));} \t\tif ((this.leftBlock) != null) { \t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], centerHeight));} \t\tif ((this.rightBlock) != null) { \t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], centerHeight));} \t\tif ((this.centerBlock) != null) { \t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), centerHeight));} \t\treturn new org.jfree.chart.util.Size2D(width, height);} \tprotected org.jfree.chart.util.Size2D arrangeFR(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) { \t\torg.jfree.chart.util.Size2D size1 = arrangeFN(container, g2, constraint.getWidth()); \t\tif (constraint.getHeightRange().contains(size1.getHeight())) { \t\t\treturn size1;}else { \t\t\tdouble h = constraint.getHeightRange().constrain(size1.getHeight()); \t\t\torg.jfree.chart.block.RectangleConstraint c2 = constraint.toFixedHeight(h); \t\t\treturn arrange(container, g2, c2);}} \tprotected org.jfree.chart.util.Size2D arrangeFN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, double width) { \t\tdouble[] w = new double[5]; \t\tdouble[] h = new double[5]; \t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(width, null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE); \t\tif ((this.topBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1); \t\t\tw[0] = size.width; \t\t\th[0] = size.height;} \t\tif ((this.bottomBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c1); \t\t\tw[1] = size.width; \t\t\th[1] = size.height;} \t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, width), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE); \t\tif ((this.leftBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c2); \t\t\tw[2] = size.width; \t\t\th[2] = size.height;} \t\tif ((this.rightBlock) != null) { \t\t\tdouble maxW = java.lang.Math.max((width - (w[2])), 0.0); \t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(java.lang.Math.min(w[2], maxW), maxW), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE); \t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c3); \t\t\tw[3] = size.width; \t\t\th[3] = size.height;} \t\th[2] = java.lang.Math.max(h[2], h[3]); \t\th[3] = h[2]; \t\tif ((this.centerBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(((width - (w[2])) - (w[3])), null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE); \t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c4); \t\t\tw[4] = size.width; \t\t\th[4] = size.height;} \t\tdouble height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4]))); \t\treturn arrange(container, g2, new org.jfree.chart.block.RectangleConstraint(width, height));} \tprotected org.jfree.chart.util.Size2D arrangeRR(org.jfree.chart.block.BlockContainer container, org.jfree.data.Range widthRange, org.jfree.data.Range heightRange, java.awt.Graphics2D g2) { \t\tdouble[] w = new double[5]; \t\tdouble[] h = new double[5]; \t\tif ((this.topBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange); \t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1); \t\t\tw[0] = size.width; \t\t\th[0] = size.height;} \t\tif ((this.bottomBlock) != null) { \t\t\torg.jfree.data.Range heightRange2 = org.jfree.data.Range.shift(heightRange, (-(h[0])), false); \t\t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange2); \t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2); \t\t\tw[1] = size.width; \t\t\th[1] = size.height;} \t\torg.jfree.data.Range heightRange3 = org.jfree.data.Range.shift(heightRange, (-((h[0]) + (h[1])))); \t\tif ((this.leftBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange3); \t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3); \t\t\tw[2] = size.width; \t\t\th[2] = size.height;} \t\torg.jfree.data.Range widthRange2 = org.jfree.data.Range.shift(widthRange, (-(w[2])), false); \t\tif ((this.rightBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(widthRange2, heightRange3); \t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4); \t\t\tw[3] = size.width; \t\t\th[3] = size.height;} \t\th[2] = java.lang.Math.max(h[2], h[3]); \t\th[3] = h[2]; \t\torg.jfree.data.Range widthRange3 = org.jfree.data.Range.shift(widthRange, (-((w[2]) + (w[3]))), false); \t\tif ((this.centerBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(widthRange3, heightRange3); \t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c5); \t\t\tw[4] = size.width; \t\t\th[4] = size.height;} \t\tdouble width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3])))); \t\tdouble height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4]))); \t\tif ((this.topBlock) != null) { \t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));} \t\tif ((this.bottomBlock) != null) { \t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));} \t\tif ((this.leftBlock) != null) { \t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));} \t\tif ((this.rightBlock) != null) { \t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], h[3]));} \t\tif ((this.centerBlock) != null) { \t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), ((height - (h[0])) - (h[1]))));} \t\treturn new org.jfree.chart.util.Size2D(width, height);} \tprotected org.jfree.chart.util.Size2D arrangeFF(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) { \t\tdouble[] w = new double[5]; \t\tdouble[] h = new double[5]; \t\tw[0] = constraint.getWidth(); \t\tif ((this.topBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, constraint.getHeight()), org.jfree.chart.block.LengthConstraintType.RANGE); \t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1); \t\t\th[0] = size.height;} \t\tw[1] = w[0]; \t\tif ((this.bottomBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, ((constraint.getHeight()) - (h[0]))), org.jfree.chart.block.LengthConstraintType.RANGE); \t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2); \t\t\th[1] = size.height;} \t\th[2] = ((constraint.getHeight()) - (h[1])) - (h[0]); \t\tif ((this.leftBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, constraint.getWidth()), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED); \t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3); \t\t\tw[2] = size.width;} \t\th[3] = h[2]; \t\tif ((this.rightBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, ((constraint.getWidth()) - (w[2]))), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED); \t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4); \t\t\tw[3] = size.width;} \t\th[4] = h[2]; \t\tw[4] = ((constraint.getWidth()) - (w[3])) - (w[2]); \t\torg.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(w[4], h[4]); \t\tif ((this.centerBlock) != null) { \t\t\tthis.centerBlock.arrange(g2, c5);} \t\tif ((this.topBlock) != null) { \t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, w[0], h[0]));} \t\tif ((this.bottomBlock) != null) { \t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, ((h[0]) + (h[2])), w[1], h[1]));} \t\tif ((this.leftBlock) != null) { \t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));} \t\tif ((this.rightBlock) != null) { \t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double(((w[2]) + (w[4])), h[0], w[3], h[3]));} \t\tif ((this.centerBlock) != null) { \t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], w[4], h[4]));} \t\treturn new org.jfree.chart.util.Size2D(constraint.getWidth(), constraint.getHeight());\n \t}\n \n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -443,9 +443,11 @@\n         h[2] = constraint.getHeight() - h[1] - h[0];\n-        if (this.leftBlock != null) {\n-            RectangleConstraint c3 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth()),\n-                    LengthConstraintType.RANGE, h[2], null,\n-                    LengthConstraintType.FIXED);\n-            Size2D size = this.leftBlock.arrange(g2, c3);\n-            w[2] = size.width;\n+        if (false) {\n+            if (this.leftBlock != null) {\n+                RectangleConstraint c3 = new RectangleConstraint(0.0,\n+                new Range(0.0, constraint.getWidth()),\n+                LengthConstraintType.RANGE, h[2], null,\n+                LengthConstraintType.FIXED);\n+                Size2D size = this.leftBlock.arrange(g2, c3);\n+                w[2] = size.width;\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_4_4",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_13/source/org/jfree/chart/block/BorderArrangement.java\t2019-07-19 06:02:19.029868519 -0400\n+++ /tmp/Arja_Defects4J_Chart_13/patches_et25/Patch_4/patched/org/jfree/chart/block/BorderArrangement.java\t2019-07-19 06:10:31.193867404 -0400\n@@ -319,7 +319,8 @@\n             w[4] = size.width;\n             h[4] = size.height;\n         }\n-        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n+        this.rightBlock = null;\n+\t\tdouble height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n         return arrange(container, g2, new RectangleConstraint(width, height));\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_9_7",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/data/Range.java b/source/org/jfree/data/Range.java\nindex 6983ecf..55d5f4d 100644\n--- a/source/org/jfree/data/Range.java\n+++ b/source/org/jfree/data/Range.java\n@@ -82,9 +82,7 @@ public strictfp class Range implements Serializable {\n      */\n     public Range(double lower, double upper) {\n         if (lower > upper) {\n-            String msg = \"Range(double, double): require lower (\" + lower \n-                + \") <= upper (\" + upper + \").\";\n-            throw new IllegalArgumentException(msg);\n+            \n         }\n         this.lower = lower;\n         this.upper = upper;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_49_48",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Chart_13/source/org/jfree/chart/block/BorderArrangementjava\n+++ /tmp/jKali_Defects4J_Chart_13/source/org/jfree/chart/block/BorderArrangementjava\n@@ -441,7 +441,7 @@\n \t\t\th[1] = size.height;\n \t\t}\n \t\th[2] = ((constraint.getHeight()) - (h[1])) - (h[0]);\n-\t\tif ((this.leftBlock) != null) {\n+\t\tif (false) {\n \t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, \n \t\t\tnew org.jfree.data.Range(0.0, constraint.getWidth()), \n \t\t\torg.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_2461_1666",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Chart_13/source/org/jfree/chart/block/BorderArrangementjava\n+++ /tmp/jGenProg_Defects4J_Chart_13/source/org/jfree/chart/block/BorderArrangementjava\n@@ -148,28 +148,287 @@\n \t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.NONE)) {\n \t\t\t\t\tcontentSize = arrangeFN(container, g2, constraint.getWidth());\n \t\t\t\t}else \n-\t\t\t\t{ \t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {\n-\t\t\t\t\t\tcontentSize = arrangeFF(container, g2, constraint);\n-\t\t\t\t\t}else\n-\t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {\n-\t\t\t\t\t\t\tcontentSize = arrangeFR(container, g2, constraint);\n-\t\t\t\t\t\t}}\n-\t\t\t}else\n-\t\t\t\tif (w == (org.jfree.chart.block.LengthConstraintType.RANGE)) {\n-\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.NONE)) {\n-\t\t\t\t\t\tthrow new java.lang.RuntimeException(\"Not implemented.\");\n-\t\t\t\t\t}else\n-\t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {\n-\t\t\t\t\t\t\tthrow new java.lang.RuntimeException(\"Not implemented.\");\n-\t\t\t\t\t\t}else\n-\t\t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {\n-\t\t\t\t\t\t\t\tcontentSize = arrangeRR(container, constraint.getWidthRange(), \n-\t\t\t\t\t\t\t\tconstraint.getHeightRange(), g2);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t}\n-\t\treturn new org.jfree.chart.util.Size2D(container.calculateTotalWidth(contentSize.getWidth()), \n-\t\tcontainer.calculateTotalHeight(contentSize.getHeight()));\n-\t}\n+\t\t\t\t{\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n \n \n \n@@ -179,66 +438,9 @@\n \n \n \n-\tprotected org.jfree.chart.util.Size2D arrangeNN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2) {\n-\t\tdouble[] w = new double[5];\n-\t\tdouble[] h = new double[5];\n-\t\tif ((this.topBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);\n-\t\t\tw[0] = size.width;\n-\t\t\th[0] = size.height;\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, \n-\t\t\torg.jfree.chart.block.RectangleConstraint.NONE);\n-\t\t\tw[1] = size.width;\n-\t\t\th[1] = size.height;\n-\t\t}\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);\n-\t\t\tw[2] = size.width;\n-\t\t\th[2] = size.height;\n-\t\t}\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);\n-\t\t\tw[3] = size.width;\n-\t\t\th[3] = size.height;\n-\t\t}\n \n-\t\th[2] = java.lang.Math.max(h[2], h[3]);\n-\t\th[3] = h[2];\n \n-\t\tif ((this.centerBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, \n-\t\t\torg.jfree.chart.block.RectangleConstraint.NONE);\n-\t\t\tw[4] = size.width;\n-\t\t\th[4] = size.height;\n-\t\t}\n-\t\tdouble width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));\n-\t\tdouble centerHeight = java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4]));\n-\t\tdouble height = ((h[0]) + (h[1])) + centerHeight;\n-\t\tif ((this.topBlock) != null) {\n-\t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, \n-\t\t\th[0]));\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, \n-\t\t\t(height - (h[1])), width, h[1]));\n-\t\t}\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], \n-\t\t\tcenterHeight));\n-\t\t}\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), \n-\t\t\th[0], w[3], centerHeight));\n-\t\t}\n \n-\t\tif ((this.centerBlock) != null) {\n-\t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], \n-\t\t\t((width - (w[2])) - (w[3])), centerHeight));\n-\t\t}\n-\t\treturn new org.jfree.chart.util.Size2D(width, height);\n-\t}\n \n \n \n@@ -249,18 +451,6 @@\n \n \n \n-\tprotected org.jfree.chart.util.Size2D arrangeFR(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, \n-\torg.jfree.chart.block.RectangleConstraint constraint) {\n-\t\torg.jfree.chart.util.Size2D size1 = arrangeFN(container, g2, constraint.getWidth());\n-\t\tif (constraint.getHeightRange().contains(size1.getHeight())) {\n-\t\t\treturn size1;\n-\t\t}else \n-\t\t{\n-\t\t\tdouble h = constraint.getHeightRange().constrain(size1.getHeight());\n-\t\t\torg.jfree.chart.block.RectangleConstraint c2 = constraint.toFixedHeight(h);\n-\t\t\treturn arrange(container, g2, c2);\n-\t\t}\n-\t}\n \n \n \n@@ -272,56 +462,8 @@\n \n \n \n-\tprotected org.jfree.chart.util.Size2D arrangeFN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, \n-\tdouble width) {\n-\t\tdouble[] w = new double[5];\n-\t\tdouble[] h = new double[5];\n-\t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(width, null, \n-\t\torg.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, \n-\t\torg.jfree.chart.block.LengthConstraintType.NONE);\n-\t\tif ((this.topBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);\n-\t\t\tw[0] = size.width;\n-\t\t\th[0] = size.height;\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c1);\n-\t\t\tw[1] = size.width;\n-\t\t\th[1] = size.height;\n-\t\t}\n-\t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(0.0, \n-\t\tnew org.jfree.data.Range(0.0, width), org.jfree.chart.block.LengthConstraintType.RANGE, \n-\t\t0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c2);\n-\t\t\tw[2] = size.width;\n-\t\t\th[2] = size.height;\n-\t\t}\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\tdouble maxW = java.lang.Math.max((width - (w[2])), 0.0);\n-\t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, \n-\t\t\tnew org.jfree.data.Range(java.lang.Math.min(w[2], maxW), maxW), \n-\t\t\torg.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.NONE);\n-\t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c3);\n-\t\t\tw[3] = size.width;\n-\t\t\th[3] = size.height;\n-\t\t}\n \n-\t\th[2] = java.lang.Math.max(h[2], h[3]);\n-\t\th[3] = h[2];\n \n-\t\tif ((this.centerBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(((width - (w[2])) - \n-\t\t\t(w[3])), null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.NONE);\n-\t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c4);\n-\t\t\tw[4] = size.width;\n-\t\t\th[4] = size.height;\n-\t\t}\n-\t\tdouble height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));\n-\t\treturn arrange(container, g2, new org.jfree.chart.block.RectangleConstraint(width, height));\n-\t}\n \n \n \n@@ -334,81 +476,11 @@\n \n \n \n-\tprotected org.jfree.chart.util.Size2D arrangeRR(org.jfree.chart.block.BlockContainer container, \n-\torg.jfree.data.Range widthRange, org.jfree.data.Range heightRange, \n-\tjava.awt.Graphics2D g2) {\n-\t\tdouble[] w = new double[5];\n-\t\tdouble[] h = new double[5];\n-\t\tif ((this.topBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(widthRange, \n-\t\t\theightRange);\n-\t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);\n-\t\t\tw[0] = size.width;\n-\t\t\th[0] = size.height;\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\torg.jfree.data.Range heightRange2 = org.jfree.data.Range.shift(heightRange, (-(h[0])), false);\n-\t\t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(widthRange, \n-\t\t\theightRange2);\n-\t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);\n-\t\t\tw[1] = size.width;\n-\t\t\th[1] = size.height;\n-\t\t}\n-\t\torg.jfree.data.Range heightRange3 = org.jfree.data.Range.shift(heightRange, (-((h[0]) + (h[1]))));\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(widthRange, \n-\t\t\theightRange3);\n-\t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);\n-\t\t\tw[2] = size.width;\n-\t\t\th[2] = size.height;\n-\t\t}\n-\t\torg.jfree.data.Range widthRange2 = org.jfree.data.Range.shift(widthRange, (-(w[2])), false);\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(widthRange2, \n-\t\t\theightRange3);\n-\t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);\n-\t\t\tw[3] = size.width;\n-\t\t\th[3] = size.height;\n-\t\t}\n \n-\t\th[2] = java.lang.Math.max(h[2], h[3]);\n-\t\th[3] = h[2];\n-\t\torg.jfree.data.Range widthRange3 = org.jfree.data.Range.shift(widthRange, (-((w[2]) + (w[3]))), false);\n-\t\tif ((this.centerBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(widthRange3, \n-\t\t\theightRange3);\n \n \n \n-\t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c5);\n-\t\t\tw[4] = size.width;\n-\t\t\th[4] = size.height;\n-\t\t}\n-\t\tdouble width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));\n-\t\tdouble height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));\n-\t\tif ((this.topBlock) != null) {\n-\t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, \n-\t\t\th[0]));\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, \n-\t\t\t(height - (h[1])), width, h[1]));\n-\t\t}\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], \n-\t\t\th[2]));\n-\t\t}\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), \n-\t\t\th[0], w[3], h[3]));\n-\t\t}\n \n-\t\tif ((this.centerBlock) != null) {\n-\t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], \n-\t\t\t((width - (w[2])) - (w[3])), ((height - (h[0])) - (h[1]))));\n-\t\t}\n-\t\treturn new org.jfree.chart.util.Size2D(width, height);\n-\t}\n \n \n \n@@ -419,84 +491,12 @@\n \n \n \n-\tprotected org.jfree.chart.util.Size2D arrangeFF(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, \n-\torg.jfree.chart.block.RectangleConstraint constraint) {\n-\t\tdouble[] w = new double[5];\n-\t\tdouble[] h = new double[5];\n-\t\tw[0] = constraint.getWidth();\n-\t\tif ((this.topBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(w[0], null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.FIXED, 0.0, \n-\t\t\tnew org.jfree.data.Range(0.0, constraint.getHeight()), \n-\t\t\torg.jfree.chart.block.LengthConstraintType.RANGE);\n-\t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);\n-\t\t\th[0] = size.height;\n-\t\t}\n-\t\tw[1] = w[0];\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(w[0], null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, \n-\t\t\t((constraint.getHeight()) - (h[0]))), org.jfree.chart.block.LengthConstraintType.RANGE);\n-\t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);\n-\t\t\th[1] = size.height;\n-\t\t}\n-\t\th[2] = ((constraint.getHeight()) - (h[1])) - (h[0]);\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, \n-\t\t\tnew org.jfree.data.Range(0.0, constraint.getWidth()), \n-\t\t\torg.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.FIXED);\n-\t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);\n-\t\t\tw[2] = size.width;\n-\t\t}\n-\t\th[3] = h[2];\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(0.0, \n-\t\t\tnew org.jfree.data.Range(0.0, ((constraint.getWidth()) - (w[2]))), \n-\t\t\torg.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, \n-\t\t\torg.jfree.chart.block.LengthConstraintType.FIXED);\n-\t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);\n-\t\t\tw[3] = size.width;\n-\t\t}\n-\t\th[4] = h[2];\n-\t\tw[4] = ((constraint.getWidth()) - (w[3])) - (w[2]);\n-\t\torg.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(w[4], h[4]);\n-\t\tif ((this.centerBlock) != null) {\n-\t\t\tthis.centerBlock.arrange(g2, c5);\n-\t\t}\n \n-\t\tif ((this.topBlock) != null) {\n-\t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, w[0], \n-\t\t\th[0]));\n-\t\t}\n-\t\tif ((this.bottomBlock) != null) {\n-\t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, ((h[0]) + (h[2])), \n-\t\t\tw[1], h[1]));\n-\t\t}\n-\t\tif ((this.leftBlock) != null) {\n-\t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], \n-\t\t\th[2]));\n-\t\t}\n-\t\tif ((this.rightBlock) != null) {\n-\t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double(((w[2]) + (w[4])), h[0], \n-\t\t\tw[3], h[3]));\n-\t\t}\n-\t\tif ((this.centerBlock) != null) {\n-\t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], w[4], \n-\t\t\th[4]));\n-\t\t}\n-\t\treturn new org.jfree.chart.util.Size2D(constraint.getWidth(), constraint.getHeight());\n-\t}\n \n \n \n \n-\tpublic void clear() {\n-\t\tthis.centerBlock = null;\n-\t\tthis.topBlock = null;\n-\t\tthis.bottomBlock = null;\n-\t\tthis.leftBlock = null;\n-\t\tthis.rightBlock = null;\n+\t\t\t\t\tthis.rightBlock = null; \t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) { \t\t\t\t\t\tcontentSize = arrangeFF(container, g2, constraint);}else \t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) { \t\t\t\t\t\t\tcontentSize = arrangeFR(container, g2, constraint);}}}else \t\t\t\tif (w == (org.jfree.chart.block.LengthConstraintType.RANGE)) { \t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.NONE)) { \t\t\t\t\t\tthrow new java.lang.RuntimeException(\"Not implemented.\");}else \t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) { \t\t\t\t\t\t\tthrow new java.lang.RuntimeException(\"Not implemented.\");}else \t\t\t\t\t\t\tif (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) { \t\t\t\t\t\t\t\tcontentSize = arrangeRR(container, constraint.getWidthRange(), constraint.getHeightRange(), g2);}} \t\treturn new org.jfree.chart.util.Size2D(container.calculateTotalWidth(contentSize.getWidth()), container.calculateTotalHeight(contentSize.getHeight()));} \tprotected org.jfree.chart.util.Size2D arrangeNN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2) { \t\tdouble[] w = new double[5]; \t\tdouble[] h = new double[5]; \t\tif ((this.topBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE); \t\t\tw[0] = size.width; \t\t\th[0] = size.height;} \t\tif ((this.bottomBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE); \t\t\tw[1] = size.width; \t\t\th[1] = size.height;} \t\tif ((this.leftBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE); \t\t\tw[2] = size.width; \t\t\th[2] = size.height;} \t\tif ((this.rightBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE); \t\t\tw[3] = size.width; \t\t\th[3] = size.height;} \t\th[2] = java.lang.Math.max(h[2], h[3]); \t\th[3] = h[2]; \t\tif ((this.centerBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE); \t\t\tw[4] = size.width; \t\t\th[4] = size.height;} \t\tdouble width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3])))); \t\tdouble centerHeight = java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])); \t\tdouble height = ((h[0]) + (h[1])) + centerHeight; \t\tif ((this.topBlock) != null) { \t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));} \t\tif ((this.bottomBlock) != null) { \t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));} \t\tif ((this.leftBlock) != null) { \t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], centerHeight));} \t\tif ((this.rightBlock) != null) { \t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], centerHeight));} \t\tif ((this.centerBlock) != null) { \t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), centerHeight));} \t\treturn new org.jfree.chart.util.Size2D(width, height);} \tprotected org.jfree.chart.util.Size2D arrangeFR(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) { \t\torg.jfree.chart.util.Size2D size1 = arrangeFN(container, g2, constraint.getWidth()); \t\tif (constraint.getHeightRange().contains(size1.getHeight())) { \t\t\treturn size1;}else { \t\t\tdouble h = constraint.getHeightRange().constrain(size1.getHeight()); \t\t\torg.jfree.chart.block.RectangleConstraint c2 = constraint.toFixedHeight(h); \t\t\treturn arrange(container, g2, c2);}} \tprotected org.jfree.chart.util.Size2D arrangeFN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, double width) { \t\tdouble[] w = new double[5]; \t\tdouble[] h = new double[5]; \t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(width, null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE); \t\tif ((this.topBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1); \t\t\tw[0] = size.width; \t\t\th[0] = size.height;} \t\tif ((this.bottomBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c1); \t\t\tw[1] = size.width; \t\t\th[1] = size.height;} \t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, width), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE); \t\tif ((this.leftBlock) != null) { \t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c2); \t\t\tw[2] = size.width; \t\t\th[2] = size.height;} \t\tif ((this.rightBlock) != null) { \t\t\tdouble maxW = java.lang.Math.max((width - (w[2])), 0.0); \t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(java.lang.Math.min(w[2], maxW), maxW), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE); \t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c3); \t\t\tw[3] = size.width; \t\t\th[3] = size.height;} \t\th[2] = java.lang.Math.max(h[2], h[3]); \t\th[3] = h[2]; \t\tif ((this.centerBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(((width - (w[2])) - (w[3])), null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE); \t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c4); \t\t\tw[4] = size.width; \t\t\th[4] = size.height;} \t\tdouble height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4]))); \t\treturn arrange(container, g2, new org.jfree.chart.block.RectangleConstraint(width, height));} \tprotected org.jfree.chart.util.Size2D arrangeRR(org.jfree.chart.block.BlockContainer container, org.jfree.data.Range widthRange, org.jfree.data.Range heightRange, java.awt.Graphics2D g2) { \t\tdouble[] w = new double[5]; \t\tdouble[] h = new double[5]; \t\tif ((this.topBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange); \t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1); \t\t\tw[0] = size.width; \t\t\th[0] = size.height;} \t\tif ((this.bottomBlock) != null) { \t\t\torg.jfree.data.Range heightRange2 = org.jfree.data.Range.shift(heightRange, (-(h[0])), false); \t\t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange2); \t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2); \t\t\tw[1] = size.width; \t\t\th[1] = size.height;} \t\torg.jfree.data.Range heightRange3 = org.jfree.data.Range.shift(heightRange, (-((h[0]) + (h[1])))); \t\tif ((this.leftBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange3); \t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3); \t\t\tw[2] = size.width; \t\t\th[2] = size.height;} \t\torg.jfree.data.Range widthRange2 = org.jfree.data.Range.shift(widthRange, (-(w[2])), false); \t\tif ((this.rightBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(widthRange2, heightRange3); \t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4); \t\t\tw[3] = size.width; \t\t\th[3] = size.height;} \t\th[2] = java.lang.Math.max(h[2], h[3]); \t\th[3] = h[2]; \t\torg.jfree.data.Range widthRange3 = org.jfree.data.Range.shift(widthRange, (-((w[2]) + (w[3]))), false); \t\tif ((this.centerBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(widthRange3, heightRange3); \t\t\torg.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c5); \t\t\tw[4] = size.width; \t\t\th[4] = size.height;} \t\tdouble width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3])))); \t\tdouble height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4]))); \t\tif ((this.topBlock) != null) { \t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));} \t\tif ((this.bottomBlock) != null) { \t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));} \t\tif ((this.leftBlock) != null) { \t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));} \t\tif ((this.rightBlock) != null) { \t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], h[3]));} \t\tif ((this.centerBlock) != null) { \t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), ((height - (h[0])) - (h[1]))));} \t\treturn new org.jfree.chart.util.Size2D(width, height);} \tprotected org.jfree.chart.util.Size2D arrangeFF(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) { \t\tdouble[] w = new double[5]; \t\tdouble[] h = new double[5]; \t\tw[0] = constraint.getWidth(); \t\tif ((this.topBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, constraint.getHeight()), org.jfree.chart.block.LengthConstraintType.RANGE); \t\t\torg.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1); \t\t\th[0] = size.height;} \t\tw[1] = w[0]; \t\tif ((this.bottomBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, ((constraint.getHeight()) - (h[0]))), org.jfree.chart.block.LengthConstraintType.RANGE); \t\t\torg.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2); \t\t\th[1] = size.height;} \t\th[2] = ((constraint.getHeight()) - (h[1])) - (h[0]); \t\tif ((this.leftBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, constraint.getWidth()), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED); \t\t\torg.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3); \t\t\tw[2] = size.width;} \t\th[3] = h[2]; \t\tif ((this.rightBlock) != null) { \t\t\torg.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, ((constraint.getWidth()) - (w[2]))), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED); \t\t\torg.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4); \t\t\tw[3] = size.width;} \t\th[4] = h[2]; \t\tw[4] = ((constraint.getWidth()) - (w[3])) - (w[2]); \t\torg.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(w[4], h[4]); \t\tif ((this.centerBlock) != null) { \t\t\tthis.centerBlock.arrange(g2, c5);} \t\tif ((this.topBlock) != null) { \t\t\tthis.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, w[0], h[0]));} \t\tif ((this.bottomBlock) != null) { \t\t\tthis.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, ((h[0]) + (h[2])), w[1], h[1]));} \t\tif ((this.leftBlock) != null) { \t\t\tthis.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));} \t\tif ((this.rightBlock) != null) { \t\t\tthis.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double(((w[2]) + (w[4])), h[0], w[3], h[3]));} \t\tif ((this.centerBlock) != null) { \t\t\tthis.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], w[4], h[4]));} \t\treturn new org.jfree.chart.util.Size2D(constraint.getWidth(), constraint.getHeight());} \tpublic void clear() { \t\tthis.centerBlock = null; \t\tthis.topBlock = null; \t\tthis.bottomBlock = null; \t\tthis.leftBlock = null; \t\tthis.rightBlock = null;\n \t}\n \n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_1091_503",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/block/BorderArrangement.java b/source/org/jfree/chart/block/BorderArrangement.java\nindex 730aeb3..4655821 100644\n--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -441,7 +441,7 @@ public class BorderArrangement implements Arrangement, Serializable {\n             h[1] = size.height;\n         }\n         h[2] = constraint.getHeight() - h[1] - h[0];\n-        if (this.leftBlock != null) {\n+        if ((this.leftBlock != null) && !(this.rightBlock != null)) {\n             RectangleConstraint c3 = new RectangleConstraint(0.0,\n                     new Range(0.0, constraint.getWidth()),\n                     LengthConstraintType.RANGE, h[2], null,",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -443,9 +443,11 @@\n         h[2] = constraint.getHeight() - h[1] - h[0];\n-        if (this.leftBlock != null) {\n-            RectangleConstraint c3 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth()),\n-                    LengthConstraintType.RANGE, h[2], null,\n-                    LengthConstraintType.FIXED);\n-            Size2D size = this.leftBlock.arrange(g2, c3);\n-            w[2] = size.width;\n+        if (null!=null) {\n+            if (this.leftBlock != null) {\n+                RectangleConstraint c3 = new RectangleConstraint(0.0,\n+                new Range(0.0, constraint.getWidth()),\n+                LengthConstraintType.RANGE, h[2], null,\n+                LengthConstraintType.FIXED);\n+                Size2D size = this.leftBlock.arrange(g2, c3);\n+                w[2] = size.width;\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_1091_503",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/block/BorderArrangement.java b/source/org/jfree/chart/block/BorderArrangement.java\nindex 730aeb3..4655821 100644\n--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -441,7 +441,7 @@ public class BorderArrangement implements Arrangement, Serializable {\n             h[1] = size.height;\n         }\n         h[2] = constraint.getHeight() - h[1] - h[0];\n-        if (this.leftBlock != null) {\n+        if ((this.leftBlock != null) && !(this.rightBlock != null)) {\n             RectangleConstraint c3 = new RectangleConstraint(0.0,\n                     new Range(0.0, constraint.getWidth()),\n                     LengthConstraintType.RANGE, h[2], null,",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_29_18",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/data/Range.java b/source/org/jfree/data/Range.java\nindex 6983ecf..d3ef45b 100644\n--- a/source/org/jfree/data/Range.java\n+++ b/source/org/jfree/data/Range.java\n@@ -84,7 +84,7 @@ public strictfp class Range implements Serializable {\n         if (lower > upper) {\n             String msg = \"Range(double, double): require lower (\" + lower \n                 + \") <= upper (\" + upper + \").\";\n-            throw new IllegalArgumentException(msg);\n+            \n         }\n         this.lower = lower;\n         this.upper = upper;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_146_30",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Chart_13/source/org/jfree/chart/block/BorderArrangement.java\t2019-07-30 04:26:17.723750566 -0400\n+++ /tmp/RSRepair_Defects4J_Chart_13/patches_wk3b/Patch_30/patched/org/jfree/chart/block/BorderArrangement.java\t2019-07-30 04:34:39.883135142 -0400\n@@ -304,7 +304,6 @@\n                     LengthConstraintType.RANGE, 0.0, null,\n                     LengthConstraintType.NONE);\n             Size2D size = this.rightBlock.arrange(g2, c3);\n-            w[3] = size.width;\n             h[3] = size.height;\n         }\n \n\n\n--- /tmp/RSRepair_Defects4J_Chart_13/source/org/jfree/data/Range.java\t2019-07-30 04:26:14.091726965 -0400\n+++ /tmp/RSRepair_Defects4J_Chart_13/patches_wk3b/Patch_30/patched/org/jfree/data/Range.java\t2019-07-30 04:34:40.183137216 -0400\n@@ -84,7 +84,7 @@\n         if (lower > upper) {\n             String msg = \"Range(double, double): require lower (\" + lower \n                 + \") <= upper (\" + upper + \").\";\n-            throw new IllegalArgumentException(msg);\n+            Comparable result = null;\n         }\n         this.lower = lower;\n         this.upper = upper;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 11,
    "bugId": 13,
    "name": "Patch_126_29",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Chart_13/source/org/jfree/chart/block/BorderArrangement.java\t2019-07-23 18:48:16.829384384 -0400\n+++ /tmp/GenProg_Defects4J_Chart_13/patches_8l5v/Patch_29/patched/org/jfree/chart/block/BorderArrangement.java\t2019-07-23 18:57:06.195906292 -0400\n@@ -295,7 +295,8 @@\n         if (this.leftBlock != null) {\n             Size2D size = this.leftBlock.arrange(g2, c2);\n             w[2] = size.width;\n-            h[2] = size.height;\n+            this.topBlock = null;\n+\t\t\th[2] = size.height;\n         }\n         if (this.rightBlock != null) {\n             double maxW = Math.max(width - w[2], 0.0);\n@@ -433,14 +434,9 @@\n             h[0] = size.height;\n         }\n         w[1] = w[0];\n-        if (this.bottomBlock != null) {\n-            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n-                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n-                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n-            Size2D size = this.bottomBlock.arrange(g2, c2);\n-            h[1] = size.height;\n-        }\n-        h[2] = constraint.getHeight() - h[1] - h[0];\n+        Size2D s1 = arrangeNN(container, g2);\n+        this.rightBlock = null;\n+\t\th[2] = constraint.getHeight() - h[1] - h[0];\n         if (this.leftBlock != null) {\n             RectangleConstraint c3 = new RectangleConstraint(0.0,\n                     new Range(0.0, constraint.getWidth()),\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 12,
    "bugId": 228,
    "name": "Patch_966_966",
    "tool": "Cardumem",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/Cardumen_Defects4J_Math_5/src/main/java/org/apache/commons/math3/complex/Complexjava\n+++ /tmp/Cardumen_Defects4J_Math_5/src/main/java/org/apache/commons/math3/complex/Complexjava\n@@ -337,7 +337,7 @@\n \n \t@java.lang.Override\n \tpublic boolean equals(java.lang.Object other) {\n-\t\tif ((this) == other) {\n+\t\tif ((java.lang.Double.isNaN(imaginary)) || (java.lang.Double.isNaN(real))) {\n \t\t\treturn true;\n \t\t}\n \t\tif (other instanceof org.apache.commons.math3.complex.Complex) {\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 12,
    "bugId": 228,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/complex/Complex.java b/src/main/java/org/apache/commons/math3/complex/Complex.java\nindex 22b23f24e..cfe532bba 100644\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -301,9 +301,16 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n             return NaN;\n         }\n \n+// start of generated patch\n+if(real==0.0&&imaginary==0.0){\n+return INF;\n+}\n+// end of generated patch\n+/* start of original code\n         if (real == 0.0 && imaginary == 0.0) {\n             return NaN;\n         }\n+ end of original code*/\n \n         if (isInfinite) {\n             return ZERO;",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 12,
    "bugId": 228,
    "name": "Patch_2_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math3/complex/Complex.java b/src/main/java/org/apache/commons/math3/complex/Complex.java\nindex 22b23f2..4524eed 100644\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -302,7 +302,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+if (this.equals(new Complex(0,0))){return INF;}            return NaN;\n         }\n \n         if (isInfinite) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 12,
    "bugId": 228,
    "name": "Patch_127_74",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Math_5/src/main/java/org/apache/commons/math3/complex/Complexjava\n+++ /tmp/jGenProg_Defects4J_Math_5/src/main/java/org/apache/commons/math3/complex/Complexjava\n@@ -302,23 +302,8 @@\n \t\t}\n \n \t\tif (((real) == 0.0) && ((imaginary) == 0.0)) {\n-\t\t\treturn org.apache.commons.math3.complex.Complex.NaN;\n-\t\t}\n \n-\t\tif (isInfinite) {\n-\t\t\treturn org.apache.commons.math3.complex.Complex.ZERO;\n-\t\t}\n \n-\t\tif ((org.apache.commons.math3.util.FastMath.abs(real)) < (org.apache.commons.math3.util.FastMath.abs(imaginary))) {\n-\t\t\tdouble q = (real) / (imaginary);\n-\t\t\tdouble scale = 1.0 / (((real) * q) + (imaginary));\n-\t\t\treturn createComplex((scale * q), (-scale));\n-\t\t}else {\n-\t\t\tdouble q = (imaginary) / (real);\n-\t\t\tdouble scale = 1.0 / (((imaginary) * q) + (real));\n-\t\t\treturn createComplex(scale, ((-scale) * q));\n-\t\t}\n-\t}\n \n \n \n@@ -335,21 +320,6 @@\n \n \n \n-\t@java.lang.Override\n-\tpublic boolean equals(java.lang.Object other) {\n-\t\tif ((this) == other) {\n-\t\t\treturn true;\n-\t\t}\n-\t\tif (other instanceof org.apache.commons.math3.complex.Complex) {\n-\t\t\torg.apache.commons.math3.complex.Complex c = ((org.apache.commons.math3.complex.Complex) (other));\n-\t\t\tif (c.isNaN) {\n-\t\t\t\treturn isNaN;\n-\t\t\t}else {\n-\t\t\t\treturn ((real) == (c.real)) && ((imaginary) == (c.imaginary));\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n \n \n \n@@ -358,32 +328,18 @@\n \n \n \n-\t@java.lang.Override\n-\tpublic int hashCode() {\n-\t\tif (isNaN) {\n-\t\t\treturn 7;\n-\t\t}\n-\t\treturn 37 * ((17 * (org.apache.commons.math3.util.MathUtils.hash(imaginary))) + \n-\t\t(org.apache.commons.math3.util.MathUtils.hash(real)));\n-\t}\n \n \n \n \n \n \n-\tpublic double getImaginary() {\n-\t\treturn imaginary;\n-\t}\n \n \n \n \n \n \n-\tpublic double getReal() {\n-\t\treturn real;\n-\t}\n \n \n \n@@ -392,9 +348,6 @@\n \n \n \n-\tpublic boolean isNaN() {\n-\t\treturn isNaN;\n-\t}\n \n \n \n@@ -405,9 +358,6 @@\n \n \n \n-\tpublic boolean isInfinite() {\n-\t\treturn isInfinite;\n-\t}\n \n \n \n@@ -433,18 +383,68 @@\n \n \n \n-\tpublic org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex factor) throws \n-\torg.apache.commons.math3.exception.NullArgumentException {\n-\t\torg.apache.commons.math3.util.MathUtils.checkNotNull(factor);\n-\t\tif ((isNaN) || (factor.isNaN)) {\n-\t\t\treturn org.apache.commons.math3.complex.Complex.NaN;\n-\t\t}\n-\t\tif ((((java.lang.Double.isInfinite(real)) || \n-\t\t(java.lang.Double.isInfinite(imaginary))) || \n-\t\t(java.lang.Double.isInfinite(factor.real))) || \n-\t\t(java.lang.Double.isInfinite(factor.imaginary))) {\n \n-\t\t\treturn org.apache.commons.math3.complex.Complex.INF;\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\t\t\treturn org.apache.commons.math3.complex.Complex.INF;} \t\tif (isInfinite) { \t\t\treturn org.apache.commons.math3.complex.Complex.ZERO;} \t\tif ((org.apache.commons.math3.util.FastMath.abs(real)) < (org.apache.commons.math3.util.FastMath.abs(imaginary))) { \t\t\tdouble q = (real) / (imaginary); \t\t\tdouble scale = 1.0 / (((real) * q) + (imaginary)); \t\t\treturn createComplex((scale * q), (-scale));}else { \t\t\tdouble q = (imaginary) / (real); \t\t\tdouble scale = 1.0 / (((imaginary) * q) + (real)); \t\t\treturn createComplex(scale, ((-scale) * q));}} \t@java.lang.Override \tpublic boolean equals(java.lang.Object other) { \t\tif ((this) == other) { \t\t\treturn true;} \t\tif (other instanceof org.apache.commons.math3.complex.Complex) { \t\t\torg.apache.commons.math3.complex.Complex c = ((org.apache.commons.math3.complex.Complex) (other)); \t\t\tif (c.isNaN) { \t\t\t\treturn isNaN;}else { \t\t\t\treturn ((real) == (c.real)) && ((imaginary) == (c.imaginary));}} \t\treturn false;} \t@java.lang.Override \tpublic int hashCode() { \t\tif (isNaN) { \t\t\treturn 7;} \t\treturn 37 * ((17 * (org.apache.commons.math3.util.MathUtils.hash(imaginary))) + (org.apache.commons.math3.util.MathUtils.hash(real)));} \tpublic double getImaginary() { \t\treturn imaginary;} \tpublic double getReal() { \t\treturn real;} \tpublic boolean isNaN() { \t\treturn isNaN;} \tpublic boolean isInfinite() { \t\treturn isInfinite;} \tpublic org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex factor) throws org.apache.commons.math3.exception.NullArgumentException { \t\torg.apache.commons.math3.util.MathUtils.checkNotNull(factor); \t\tif ((isNaN) || (factor.isNaN)) { \t\t\treturn org.apache.commons.math3.complex.Complex.NaN;} \t\tif ((((java.lang.Double.isInfinite(real)) || (java.lang.Double.isInfinite(imaginary))) || (java.lang.Double.isInfinite(factor.real))) || (java.lang.Double.isInfinite(factor.imaginary))) { \t\t\treturn org.apache.commons.math3.complex.Complex.INF;\n \t\t}\n \t\treturn createComplex((((real) * (factor.real)) - ((imaginary) * (factor.imaginary))), \n \t\t(((real) * (factor.imaginary)) + ((imaginary) * (factor.real))));\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 12,
    "bugId": 228,
    "name": "Patch_2_2",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/complex/Complex.java b/src/main/java/org/apache/commons/math3/complex/Complex.java\nindex 22b23f2..ac8185b 100644\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -302,7 +302,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return INF;\n         }\n \n         if (isInfinite) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 13,
    "bugId": 301,
    "name": "Patch_2356_2356",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b40..456952c4c 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -59,10 +59,18 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n+// start of generated patch\n+if(MathUtils.compareTo(tableau.getEntry(0,i),0,epsilon)<0){\n+minValue=tableau.getEntry(0,i);\n+minPos=i;\n+}\n+// end of generated patch\n+/* start of original code\n             if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n                 minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n+ end of original code*/\n         }\n         return minPos;\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 13,
    "bugId": 301,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -62,3 +62,5 @@\n             if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n+                if (false) {\n+                    minValue = tableau.getEntry(0, i);\n+                }\n                 minPos = i;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 13,
    "bugId": 301,
    "name": "Patch_125_18",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b..c1b02f9 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -79,8 +79,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n-                final double ratio = rhs / entry;\n+if (MathUtils.compareTo(entry, 0, epsilon) >= 0&&!(MathUtils.compareTo(entry, 0, epsilon)==0.0)) {                final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; ",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 13,
    "bugId": 301,
    "name": "Patch_83_49",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_82/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2019-07-31 06:24:23.950122892 -0400\n+++ /tmp/Arja_Defects4J_Math_82/patches_im6f/Patch_49/patched/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2019-07-31 06:32:54.588625922 -0400\n@@ -349,7 +349,11 @@\n               coefficients[i] = 0;\n           } else {\n               basicRows.add(basicRow);\n-              coefficients[i] =\n+              for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) {\n+\t\t\t\tint row = getBasicRow(getArtificialVariableOffset() + artificialVar);\n+\t\t\t\tsubtractRow(0, row, 1.0);\n+\t\t\t}\n+\t\t\tcoefficients[i] =\n                   (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                   (restrictToNonNegative ? 0 : mostNegative);\n           }\n\n\n--- /tmp/Arja_Defects4J_Math_82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2019-07-31 06:24:27.822129291 -0400\n+++ /tmp/Arja_Defects4J_Math_82/patches_im6f/Patch_49/patched/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2019-07-31 06:32:54.600626593 -0400\n@@ -60,7 +60,6 @@\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n             if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n         }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 13,
    "bugId": 301,
    "name": "Patch_600_284",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b..d920e77 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -59,7 +59,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+            if (MathUtils.compareTo(tableau.getEntry(0, i), this.epsilon, epsilon) < 0) {\n                 minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 13,
    "bugId": 301,
    "name": "Patch_28_28",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Math_82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolverjava\n+++ /tmp/jMutRepair_Defects4J_Math_82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolverjava\n@@ -79,7 +79,7 @@\n \t\tfor (int i = tableau.getNumObjectiveFunctions(); i < (tableau.getHeight()); i++) {\n \t\t\tfinal double rhs = tableau.getEntry(i, ((tableau.getWidth()) - 1));\n \t\t\tfinal double entry = tableau.getEntry(i, col);\n-\t\t\tif ((org.apache.commons.math.util.MathUtils.compareTo(entry, 0, epsilon)) >= 0) {\n+\t\t\tif ((org.apache.commons.math.util.MathUtils.compareTo(entry, 0, this.epsilon)) > 0) {\n \t\t\t\tfinal double ratio = rhs / entry;\n \t\t\t\tif (ratio < minRatio) {\n \t\t\t\t\tminRatio = ratio;\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 13,
    "bugId": 301,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -62,3 +62,5 @@\n             if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n+                if (org.apache.commons.math.optimization.linear.SimplexSolver.DEFAULT_EPSILON == minValue) {\n+                    minValue = tableau.getEntry(0, i);\n+                }\n                 minPos = i;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 13,
    "bugId": 301,
    "name": "Patch_646_317",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b..3a4424f 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -59,7 +59,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+            if (MathUtils.compareTo(tableau.getEntry(0, i), DEFAULT_EPSILON, epsilon) < 0) {\n                 minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 13,
    "bugId": 301,
    "name": "Patch_1326_709",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b..37c28ca 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -59,7 +59,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+            if ((MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) || (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0)) {\n                 minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 13,
    "bugId": 301,
    "name": "Patch_10_4",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2019-08-03 00:10:06.332843764 -0400\n+++ /tmp/RSRepair_Defects4J_Math_82/patches_us5t/Patch_4/patched/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2019-08-03 00:19:37.394889984 -0400\n@@ -60,7 +60,6 @@\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n             if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n         }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 13,
    "bugId": 301,
    "name": "Patch_36_12",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2019-08-01 09:03:37.262647302 -0400\n+++ /tmp/GenProg_Defects4J_Math_82/patches_2wue/Patch_12/patched/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2019-08-01 09:09:54.025077073 -0400\n@@ -60,7 +60,6 @@\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n             if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n         }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 14,
    "bugId": 266,
    "name": "Patch_797_797",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\nindex e5518e31a..fe49cd7f4 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n@@ -517,9 +517,16 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se\n                 }\n \n                 double sumWts = 0;\n+// start of generated patch\n+for(int i=begin;i<begin+length;i++){\n+sumWts+=weights[i];\n+}\n+// end of generated patch\n+/* start of original code\n                 for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n+ end of original code*/\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 14,
    "bugId": 266,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n@@ -317,10 +317,12 @@\n \n-        if (test(values, weights,begin, length)) {\n-            clear();\n-            if (length == 1) {\n-                var = 0.0;\n-            } else if (length > 1) {\n-                Mean mean = new Mean();\n-                double m = mean.evaluate(values, weights, begin, length);\n-                var = evaluate(values, weights, m, begin, length);\n+        if (values[0] <= length) {\n+            if (test(values, weights,begin, length)) {\n+                clear();\n+                if (length == 1) {\n+                    var = 0.0;\n+                } else if (length > 1) {\n+                    Mean mean = new Mean();\n+                    double m = mean.evaluate(values, weights, begin, length);\n+                    var = evaluate(values, weights, m, begin, length);\n+                }\n             }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 14,
    "bugId": 266,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n@@ -216,3 +216,5 @@\n             }\n-            return xbarw + (correction/sumw);\n+            if (xbarw < length) {\n+                return xbarw + (correction/sumw);\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 15,
    "bugId": 222,
    "name": "Patch_4407_4407",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 0e889892..243cf9bd 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1775,6 +1775,17 @@ public class StrBuilder implements Cloneable {\n         char[] thisBuf = buffer;\n         int len = thisBuf.length - strLen;\n         outer:\n+// start of generated patch\n+for(int i=startIndex;i<size;i++){\n+for(int j=0;j<strLen;j++){\n+if(str.charAt(j)!=thisBuf[i+j]){\n+continue outer;\n+}\n+}\n+return i;\n+}\n+// end of generated patch\n+/* start of original code\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n@@ -1783,6 +1794,7 @@ public class StrBuilder implements Cloneable {\n             }\n             return i;\n         }\n+ end of original code*/\n         return -1;\n     }\n ",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 16,
    "bugId": 294,
    "name": "Patch_899_899",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 0840ac1cc..966384584 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -291,6 +291,19 @@ public abstract class EmbeddedRungeKuttaIntegrator\n           interpolator.storeTime(stepStart + stepSize);\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n+// start of generated patch\n+if(Math.abs(dt)<=Math.ulp(stepStart)){\n+interpolator.storeTime(stepStart);\n+System.arraycopy(y,0,yTmp,0,y0.length);\n+hNew=0;\n+stepSize=0;\n+\n+loop=false;\n+}else {\n+hNew=dt;\n+}\n+// end of generated patch\n+/* start of original code\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                   // we cannot simply truncate the step, reject the current computation\n                   // and let the loop compute another state with the truncated step.\n@@ -302,6 +315,7 @@ public abstract class EmbeddedRungeKuttaIntegrator\n                   // reject the step to match exactly the next switch time\n                   hNew = dt;\n               }\n+ end of original code*/\n           } else {\n             // accept the step\n             loop = false;\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\nindex 255b1f42b..b6b592ee7 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -171,6 +171,16 @@ public abstract class RungeKuttaIntegrator extends AbstractIntegrator {\n         interpolator.storeTime(stepStart + stepSize);\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n+// start of generated patch\n+if(Math.abs(dt)<=Math.ulp(stepStart)){\n+System.arraycopy(y,0,yTmp,0,y0.length);\n+stepSize=0;\n+loop=false;\n+}else {\n+stepSize=dt;\n+}\n+// end of generated patch\n+/* start of original code\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                 // we cannot simply truncate the step, reject the current computation\n                 // and let the loop compute another state with the truncated step.\n@@ -182,6 +192,7 @@ public abstract class RungeKuttaIntegrator extends AbstractIntegrator {\n                 // reject the step to match exactly the next switch time\n                 stepSize = dt;\n             }\n+ end of original code*/\n         } else {\n           loop = false;\n         }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 16,
    "bugId": 294,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n@@ -149,6 +149,8 @@\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n+    if (false) {\n+      if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+        initialStep = -1.0;\n+      } else {\n+        initialStep = initialStepSize;\n+      }\n     }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 16,
    "bugId": 294,
    "name": "Patch_331_302",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Math_71/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpljava\n+++ /tmp/jKali_Defects4J_Math_71/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpljava\n@@ -60,7 +60,7 @@\n \tprotected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount, final \n \tdouble defaultAbsoluteAccuracy) {\n \t\tthis.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n-\t\tthis.defaultRelativeAccuracy = 1.0E-14;\n+\n \t\tthis.absoluteAccuracy = defaultAbsoluteAccuracy;\n \t\tthis.relativeAccuracy = defaultRelativeAccuracy;\n \t\tthis.defaultMaximalIterationCount = defaultMaximalIterationCount;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 17,
    "bugId": 226,
    "name": "Patch_60_60",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/fraction/BigFraction.java b/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\nindex ed4108df8..ceb48d8f9 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\n@@ -300,11 +300,18 @@ public class BigFraction\n             final long a1 = (long) FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n+// start of generated patch\n+if((n<maxIterations)&&(FastMath.abs(value-value)>epsilon)){\n+throw new FractionConversionException(value,p2,q2);\n+}\n+// end of generated patch\n+/* start of original code\n             if ((p2 > overflow) || (q2 > overflow)) {\n                 // in maxDenominator mode, if the last fraction was very close to the actual value\n                 // q2 may overflow in the next iteration; in this case return the last one.\n                 throw new FractionConversionException(value, p2, q2);\n             }\n+ end of original code*/\n \n             final double convergent = (double) p2 / (double) q2;\n             if ((n < maxIterations) &&",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 18,
    "bugId": 20,
    "name": "Patch_4_4",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/chart/plot/ValueMarker.java b/source/org/jfree/chart/plot/ValueMarker.java\nindex 075683d..64ce8b2 100644\n--- a/source/org/jfree/chart/plot/ValueMarker.java\n+++ b/source/org/jfree/chart/plot/ValueMarker.java\n@@ -92,8 +92,14 @@ public class ValueMarker extends Marker {\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n+// start of generated patch\n+super(paint,stroke,outlinePaint,outlineStroke,alpha);\n+this.value=value;\n+// end of generated patch\n+/* start of original code\n         super(paint, stroke, paint, stroke, alpha);\n         this.value = value;\n+ end of original code*/\n     }\n     \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 18,
    "bugId": 20,
    "name": "Patch_153_49",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/ValueMarker.java b/source/org/jfree/chart/plot/ValueMarker.java\nindex 075683d..58d5289 100644\n--- a/source/org/jfree/chart/plot/ValueMarker.java\n+++ b/source/org/jfree/chart/plot/ValueMarker.java\n@@ -92,7 +92,7 @@ public class ValueMarker extends Marker {\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+        super(paint, stroke, outlinePaint, outlineStroke, alpha);\n         this.value = value;\n     }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 19,
    "bugId": 172,
    "name": "Patch_128_128",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\nindex b200223d..f1e2c58a 100644\n--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n@@ -228,6 +228,19 @@ public class RandomStringUtils {\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n \n+// start of generated patch\n+if(chars==null&&end==0){\n+if(!letters&&!numbers){\n+end=Integer.MAX_VALUE;\n+}else {\n+end='z'+1;\n+start=' ';\n+}\n+}\n+char[] buffer=new char[count];\n+int gap=end-start;\n+// end of generated patch\n+/* start of original code\n         if (start == 0 && end == 0) {\n                 if (!letters && !numbers) {\n                     end = Integer.MAX_VALUE;\n@@ -239,6 +252,7 @@ public class RandomStringUtils {\n \n         char[] buffer = new char[count];\n         int gap = end - start;\n+ end of original code*/\n \n         while (count-- != 0) {\n             char ch;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 20,
    "bugId": 66,
    "name": "Patch_1376_1376",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 4381487c..e6ec35d1 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -242,9 +242,16 @@ abstract class CodeConsumer {\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n+// start of generated patch\n+if(prev=='-'){\n+add(\" \");\n+}\n+// end of generated patch\n+/* start of original code\n     if (x < 0 && prev == '-') {\n       add(\" \");\n     }\n+ end of original code*/\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 20,
    "bugId": 66,
    "name": "Patch_1174_242",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 4381487..6d637e8 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -242,7 +242,7 @@ abstract class CodeConsumer {\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if (x <= 0 && prev == '-') {\n       add(\" \");\n     }\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 21,
    "bugId": 5,
    "name": "Patch_447_447",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..3e2a8b2 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -296,6 +296,19 @@ public class TimePeriodValues extends Series implements Serializable {\n             this.minMiddleIndex = index;\n         }\n         \n+// start of generated patch\n+if(this.maxMiddleIndex>=0){\n+long s=getDataItem(this.maxMiddleIndex).getPeriod().getStart().getTime();\n+long e=getDataItem(this.maxMiddleIndex).getPeriod().getEnd().getTime();\n+long maxMiddle=s+(e-s)/2;\n+if(middle>maxMiddle){\n+this.maxMiddleIndex=index;\n+}\n+}else {\n+this.maxMiddleIndex=index;\n+}\n+// end of generated patch\n+/* start of original code\n         if (this.maxMiddleIndex >= 0) {\n             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                 .getTime();\n@@ -309,6 +322,7 @@ public class TimePeriodValues extends Series implements Serializable {\n         else {\n             this.maxMiddleIndex = index;\n         }\n+end of original code*/\n         \n         if (this.minEndIndex >= 0) {\n             long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 21,
    "bugId": 5,
    "name": "Patch_362_357",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_7/source/org/jfree/data/time/TimePeriodValues.java\t2019-07-19 04:00:43.397885052 -0400\n+++ /tmp/Arja_Defects4J_Chart_7/patches_cz2a/Patch_357/patched/org/jfree/data/time/TimePeriodValues.java\t2019-07-19 04:12:25.673883461 -0400\n@@ -314,7 +314,8 @@\n             long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                 .getTime();\n             if (end < minEnd) {\n-                this.minEndIndex = index;           \n+                this.data.remove(index);\n+\t\t\t\tthis.minEndIndex = index;           \n             }\n         }\n         else {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 21,
    "bugId": 5,
    "name": "Patch_6_2",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..ef115a1 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -549,7 +549,7 @@ public class TimePeriodValues extends Series implements Serializable {\n      * @return The index.\n      */\n     public int getMaxMiddleIndex() {\n-        return this.maxMiddleIndex;\n+        return this.maxStartIndex;\n     }\n \n     /**\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 21,
    "bugId": 5,
    "name": "Patch_31_27",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Chart_7/source/org/jfree/data/time/TimePeriodValuesjava\n+++ /tmp/jMutRepair_Defects4J_Chart_7/source/org/jfree/data/time/TimePeriodValuesjava\n@@ -282,7 +282,7 @@\n \t\t\tthis.maxStartIndex = index;\n \t\t}\n \n-\t\tif ((this.minMiddleIndex) >= 0) {\n+\t\tif ((this.minMiddleIndex) == 0) {\n \t\t\tlong s = getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime();\n \n \t\t\tlong e = getDataItem(this.minMiddleIndex).getPeriod().getEnd().getTime();\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 21,
    "bugId": 5,
    "name": "Patch_36_28",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Chart_7/source/org/jfree/data/time/TimePeriodValuesjava\n+++ /tmp/jGenProg_Defects4J_Chart_7/source/org/jfree/data/time/TimePeriodValuesjava\n@@ -549,23 +549,23 @@\n \n \n \tpublic int getMaxMiddleIndex() {\n-\t\treturn this.maxMiddleIndex;\n-\t}\n \n \n \n \n \n \n-\tpublic int getMinEndIndex() {\n-\t\treturn this.minEndIndex;\n-\t}\n \n \n \n \n \n \n-\tpublic int getMaxEndIndex() {\n-\t\treturn this.maxEndIndex;\n+\n+\n+\n+\n+\n+\n+\t\treturn this.maxEndIndex;} \tpublic int getMinEndIndex() { \t\treturn this.minEndIndex;} \tpublic int getMaxEndIndex() { \t\treturn this.maxEndIndex;\n \t}}\n\\ No newline at end of file\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 21,
    "bugId": 5,
    "name": "Patch_467_238",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..2b34249 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -285,7 +285,7 @@ public class TimePeriodValues extends Series implements Serializable {\n         if (this.minMiddleIndex >= 0) {\n             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                 .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd()\n                 .getTime();\n             long minMiddle = s + (e - s) / 2;\n             if (middle < minMiddle) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 21,
    "bugId": 5,
    "name": "Patch_467_238",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..2b34249 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -285,7 +285,7 @@ public class TimePeriodValues extends Series implements Serializable {\n         if (this.minMiddleIndex >= 0) {\n             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                 .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd()\n                 .getTime();\n             long minMiddle = s + (e - s) / 2;\n             if (middle < minMiddle) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 21,
    "bugId": 5,
    "name": "Patch_2_2",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..3701427 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -549,7 +549,8 @@ public class TimePeriodValues extends Series implements Serializable {\n      * @return The index.\n      */\n     public int getMaxMiddleIndex() {\n-        return this.maxMiddleIndex;\n+        return this.maxStartIndex;\n+\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 22,
    "bugId": 231,
    "name": "Patch_2_2",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\nindex 75c9757ae..f6a819f1c 100644\n--- a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n@@ -90,7 +90,12 @@ public abstract class BaseOptimizer<PAIR> {\n      * @return the number of evaluations of the objective function.\n      */\n     public int getIterations() {\n+// start of generated patch\n+return evaluations.getCount();\n+// end of generated patch\n+/* start of original code\n         return iterations.getCount();\n+ end of original code*/\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 22,
    "bugId": 231,
    "name": "Patch_1_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\nindex 75c9757..0d2c484 100644\n--- a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n@@ -90,7 +90,7 @@ public abstract class BaseOptimizer<PAIR> {\n      * @return the number of evaluations of the objective function.\n      */\n     public int getIterations() {\n-        return iterations.getCount();\n+        return this.evaluations.getCount();\n     }\n \n     /**\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 22,
    "bugId": 231,
    "name": "Patch_5_2",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\nindex 75c9757..0d2c484 100644\n--- a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n@@ -90,7 +90,7 @@ public abstract class BaseOptimizer<PAIR> {\n      * @return the number of evaluations of the objective function.\n      */\n     public int getIterations() {\n-        return iterations.getCount();\n+        return this.evaluations.getCount();\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 23,
    "bugId": 221,
    "name": "Patch_1290_1290",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex c7cbfb3e..0bb192cc 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1670,11 +1670,20 @@ public class StrBuilder implements Cloneable {\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n+// start of generated patch\n+for(int i=0;i<size;i++){\n+if(thisBuf[i]==ch){\n+return true;\n+}\n+}\n+// end of generated patch\n+/* start of original code\n         for (int i = 0; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }\n         }\n+ end of original code*/\n         return false;\n     }\n \n@@ -1727,11 +1736,20 @@ public class StrBuilder implements Cloneable {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n+// start of generated patch\n+for(int i=startIndex;i<size;i++){\n+if(thisBuf[i]==ch){\n+return i;\n+}\n+}\n+// end of generated patch\n+/* start of original code\n         for (int i = startIndex; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n             }\n         }\n+ end of original code*/\n         return -1;\n     }\n ",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 23,
    "bugId": 221,
    "name": "Patch_3262_1865",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex c7cbfb3..652b36f 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1111,7 +1111,7 @@ public class StrBuilder implements Cloneable {\n      * @throws IndexOutOfBoundsException if any index is invalid\n      */\n     private void deleteImpl(int startIndex, int endIndex, int len) {\n-        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n+        System.arraycopy(buffer, endIndex, buffer, startIndex, capacity() - endIndex);\n         size -= len;\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 24,
    "bugId": 22,
    "name": "Patch_1504_1504",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/data/KeyedObjects2D.java b/source/org/jfree/data/KeyedObjects2D.java\nindex d0e832f..9262565 100644\n--- a/source/org/jfree/data/KeyedObjects2D.java\n+++ b/source/org/jfree/data/KeyedObjects2D.java\n@@ -228,6 +228,15 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \n                     + \") not recognised.\");\n         }\n+// start of generated patch\n+if(row>=column){\n+KeyedObjects rowData=(KeyedObjects)this.rows.get(row);\n+return rowData.getObject(columnKey);\n+}else {\n+return null;\n+}\n+// end of generated patch\n+/* start of original code\n         if (row >= 0) {\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\n             return rowData.getObject(columnKey);\n@@ -235,6 +244,7 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n         else {\n             return null;\n         }\n+end of original code*/\n     }\n \n     /**\n@@ -341,8 +351,17 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n      * @see #removeColumn(Comparable)\n      */\n     public void removeRow(Comparable rowKey) {\n+// start of generated patch\n+int index=getRowIndex(rowKey);\n+if(index<0){\n+throw new UnknownKeyException(\"The key (\"+rowKey.toString());\n+}\n+removeRow(index);\n+// end of generated patch\n+/* start of original code\n         int index = getRowIndex(rowKey);\n         removeRow(index);\n+end of original code*/\n     }\n \n     /**\n@@ -367,6 +386,20 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n      * @see #removeRow(Comparable)\n      */\n     public void removeColumn(Comparable columnKey) {\n+// start of generated patch\n+int index=getColumnIndex(columnKey);\n+if(index<0){\n+throw new UnknownKeyException(\"Column key (\"+columnKey);\n+}\n+Iterator iterator=this.rows.iterator();\n+while(iterator.hasNext()){\n+KeyedObjects rowData=(KeyedObjects)iterator.next();\n+this.rows.remove(index);\n+rowData.removeValue(columnKey);\n+}\n+this.columnKeys.remove(columnKey);\n+// end of generated patch\n+/* start of original code\n         int index = getColumnIndex(columnKey);\n         if (index < 0) {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \n@@ -378,6 +411,7 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n                 rowData.removeValue(columnKey);\n         }\n         this.columnKeys.remove(columnKey);\n+ end of original code*/\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 25,
    "bugId": 295,
    "name": "Patch_2_2",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..640d9b459 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -111,10 +111,18 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n+// start of generated patch\n+if(Math.abs(yMin)<=functionValueAccuracy){\n+setResult(min,0);\n+return result;\n+}\n+// end of generated patch\n+/* start of original code\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n+ end of original code*/\n \n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 26,
    "bugId": 267,
    "name": "Patch_4783_4783",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/ode/events/EventState.java b/src/main/java/org/apache/commons/math/ode/events/EventState.java\nindex 8e9ff46a5..e14c58aff 100644\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n@@ -187,9 +187,17 @@ public class EventState {\n     public boolean evaluateStep(final StepInterpolator interpolator)\n         throws ConvergenceException {\n \n+// start of generated patch\n+forward=interpolator.isForward();\n+t0=interpolator.getPreviousTime();\n+ final double t1=interpolator.getCurrentTime();\n+ final double dt=t1-t0;\n+// end of generated patch\n+/* start of original code\n             forward = interpolator.isForward();\n             final double t1 = interpolator.getCurrentTime();\n             final double dt = t1 - t0;\n+ end of original code*/\n             if (FastMath.abs(dt) < convergence) {\n                 // we cannot do anything on such a small step, don't trigger any events\n                 return false;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 27,
    "bugId": 198,
    "name": "Patch_3801_3801",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\nindex 404be490..1ed86aad 100644\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n@@ -416,11 +416,21 @@ public class ExtendedMessageFormat extends MessageFormat {\n      */\n     private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n             StringBuffer appendTo, boolean escapingOn) {\n+// start of generated patch\n+int start=pos.getIndex();\n+char[] c=pattern.toCharArray();\n+if(escapingOn&&c[start]==QUOTE){\n+next(pos);\n+return appendTo==null?null:appendTo.append(QUOTE);\n+}\n+// end of generated patch\n+/* start of original code\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n+ end of original code*/\n         int lastHold = start;\n         for (int i = pos.getIndex(); i < pattern.length(); i++) {\n             if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 27,
    "bugId": 198,
    "name": "Patch_416_120",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\nindex 404be49..8b305c0 100644\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n@@ -155,7 +155,7 @@ public class ExtendedMessageFormat extends MessageFormat {\n         while (pos.getIndex() < pattern.length()) {\n             switch (c[pos.getIndex()]) {\n             case QUOTE:\n-                appendQuotedString(pattern, pos, stripCustom, true);\n+                appendQuotedString(pattern, pos, stripCustom, false);\n                 break;\n             case START_FE:\n                 fmtCount++;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 27,
    "bugId": 198,
    "name": "Patch_368_183",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\nindex 404be49..8b305c0 100644\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n@@ -155,7 +155,7 @@ public class ExtendedMessageFormat extends MessageFormat {\n         while (pos.getIndex() < pattern.length()) {\n             switch (c[pos.getIndex()]) {\n             case QUOTE:\n-                appendQuotedString(pattern, pos, stripCustom, true);\n+                appendQuotedString(pattern, pos, stripCustom, false);\n                 break;\n             case START_FE:\n                 fmtCount++;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 28,
    "bugId": 204,
    "name": "Patch_855_855",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang/WordUtils.java b/src/java/org/apache/commons/lang/WordUtils.java\nindex 42bd883e..d365d952 100644\n--- a/src/java/org/apache/commons/lang/WordUtils.java\n+++ b/src/java/org/apache/commons/lang/WordUtils.java\n@@ -619,12 +619,21 @@ public class WordUtils {\n             upper = str.length();\n         }\n         // if upper is less than lower, raise it to lower\n+// start of generated patch\n+if((lower+(upper-3))<lower){\n+upper=lower;\n+}\n+StringBuffer result=new StringBuffer();\n+int index=StringUtils.indexOf(str,\" \",lower);\n+// end of generated patch\n+/* start of original code\n         if (upper < lower) {\n             upper = lower;\n         }\n \n         StringBuffer result = new StringBuffer();\n         int index = StringUtils.indexOf(str, \" \", lower);\n+ end of original code*/\n         if (index == -1) {\n             result.append(str.substring(0, upper));\n             // only if abbreviation has occured do we append the appendToEnd value",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 28,
    "bugId": 204,
    "name": "Patch_342_158",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/WordUtils.java b/src/java/org/apache/commons/lang/WordUtils.java\nindex 42bd883..e1b2a21 100644\n--- a/src/java/org/apache/commons/lang/WordUtils.java\n+++ b/src/java/org/apache/commons/lang/WordUtils.java\n@@ -619,7 +619,7 @@ public class WordUtils {\n             upper = str.length();\n         }\n         // if upper is less than lower, raise it to lower\n-        if (upper < lower) {\n+        if ((upper < lower) && (upper != str.length())) {\n             upper = lower;\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 28,
    "bugId": 204,
    "name": "Patch_310_221",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/WordUtils.java b/src/java/org/apache/commons/lang/WordUtils.java\nindex 42bd883..e1b2a21 100644\n--- a/src/java/org/apache/commons/lang/WordUtils.java\n+++ b/src/java/org/apache/commons/lang/WordUtils.java\n@@ -619,7 +619,7 @@ public class WordUtils {\n             upper = str.length();\n         }\n         // if upper is less than lower, raise it to lower\n-        if (upper < lower) {\n+        if ((upper < lower) && (upper != str.length())) {\n             upper = lower;\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 29,
    "bugId": 30,
    "name": "Patch_1874_1874",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeValidator.java b/src/com/google/javascript/jscomp/TypeValidator.java\nindex 8cdb02a4..41248cf5 100644\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n@@ -402,11 +402,20 @@ class TypeValidator {\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n+// start of generated patch\n+if(!shouldReport&&(shouldReport||!NodeUtil.mayHaveSideEffects(n,t.getCompiler()))){\n+registerMismatch(rightType,leftType,null);\n+}else {\n+mismatch(t,n,msg,rightType,leftType);\n+}\n+// end of generated patch\n+/* start of original code\n       if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n         registerMismatch(rightType, leftType, null);\n       } else {\n       mismatch(t, n, msg, rightType, leftType);\n       }\n+ end of original code*/\n       return false;\n     }\n     return true;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 30,
    "bugId": 200,
    "name": "Patch_2275_2275",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang3/StringUtils.java b/src/java/org/apache/commons/lang3/StringUtils.java\nindex 14563aa6..3ffd996b 100644\n--- a/src/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/java/org/apache/commons/lang3/StringUtils.java\n@@ -3672,12 +3672,25 @@ public class StringUtils {\n         int increase = 0;\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n+// start of generated patch\n+for(int i=0;i<searchList.length;i++){\n+if(noMoreMatchesForReplIndex[i]||searchList[i]==null||searchList[i].length()==0||replacementList[i]==null){\n+continue;\n+}\n+int greater=replacementList[i].length()-searchList[i].length();\n+if(greater>0){\n+increase+=3*greater;\n+}\n+}\n+// end of generated patch\n+/* start of original code\n         for (int i = 0; i < searchList.length; i++) {\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n             }\n         }\n+ end of original code*/\n         // have upper-bound at 20% increase, then let Java take over\n         increase = Math.min(increase, text.length() / 5);\n ",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 30,
    "bugId": 200,
    "name": "Patch_525_180",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang3/StringUtils.java b/src/java/org/apache/commons/lang3/StringUtils.java\nindex 14563aa..54b2a0c 100644\n--- a/src/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/java/org/apache/commons/lang3/StringUtils.java\n@@ -3673,7 +3673,7 @@ public class StringUtils {\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n         for (int i = 0; i < searchList.length; i++) {\n-            int greater = replacementList[i].length() - searchList[i].length();\n+            int greater = searchList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n             }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 30,
    "bugId": 200,
    "name": "Patch_2239_1901",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Lang_39/src/java/org/apache/commons/lang3/StringUtilsjava\n+++ /tmp/jGenProg_Defects4J_Lang_39/src/java/org/apache/commons/lang3/StringUtilsjava\n@@ -3672,12 +3672,12 @@\n \t\tint increase = 0;\n \n \n-\t\tfor (int i = 0; i < (searchList.length); i++) {\n-\t\t\tint greater = (replacementList[i].length()) - (searchList[i].length());\n-\t\t\tif (greater > 0) {\n-\t\t\t\tincrease += 3 * greater;\n-\t\t\t}\n-\t\t}\n+\n+\n+\n+\n+\n+\n \n \t\tincrease = java.lang.Math.min(increase, ((text.length()) / 5));\n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 30,
    "bugId": 200,
    "name": "Patch_1350_1039",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang3/StringUtils.java b/src/java/org/apache/commons/lang3/StringUtils.java\nindex 14563aa..3b0c243 100644\n--- a/src/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/java/org/apache/commons/lang3/StringUtils.java\n@@ -3672,7 +3672,7 @@ public class StringUtils {\n         int increase = 0;\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n-        for (int i = 0; i < searchList.length; i++) {\n+        for (int i = 0; i==searchList.length; i++) {\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 31,
    "bugId": 278,
    "name": "Patch_169_169",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d3e..0522f6f44 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,6 +172,17 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n+// start of generated patch\n+double sum=0;\n+for(int i=0;i<pointSet.size();i++){\n+ final T p=pointSet.get(i);\n+ final Cluster<T> nearest=getNearestCluster(resultSet,p);\n+ final double d=p.distanceFrom(nearest.getCenter());\n+sum+=d*d;\n+dx2[i]=sum;\n+}\n+// end of generated patch\n+/* start of original code\n             int sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n@@ -180,6 +191,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n                 sum += d * d;\n                 dx2[i] = sum;\n             }\n+ end of original code*/\n \n             // Add one new data point as a center. Each point x is chosen with\n             // probability proportional to D(x)2",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 31,
    "bugId": 278,
    "name": "Patch_447_97",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d..2a21c46 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -96,7 +96,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         assignPointsToClusters(clusters, points);\n \n         // iterate through updating the centers until we're done\n-        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;\n+        final int max = (maxIterations <= 0) ? Integer.MAX_VALUE : maxIterations;\n         for (int count = 0; count < max; count++) {\n             boolean clusteringChanged = false;\n             List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 31,
    "bugId": 278,
    "name": "Patch_22_22",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Math_57/src/main/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPointjava\n+++ /tmp/jMutRepair_Defects4J_Math_57/src/main/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPointjava\n@@ -82,7 +82,7 @@\n \t\t\treturn false;\n \t\t}\n \t\tfor (int i = 0; i < (point.length); i++) {\n-\t\t\tif ((point[i]) != (otherPoint[i])) {\n+\t\t\tif ((this.point[i]) > (otherPoint[i])) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 31,
    "bugId": 278,
    "name": "Patch_10_4",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d..e09bbc3 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,7 +172,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 31,
    "bugId": 278,
    "name": "Patch_16_7",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d..e09bbc3 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,7 +172,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 32,
    "bugId": 271,
    "name": "Patch_18_18",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d98204..fa4d85e34 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -184,10 +184,18 @@ public abstract class BaseSecantSolver\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n+// start of generated patch\n+if(x==x0){\n+x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol));\n+f0=computeObjectiveValue(x0);\n+}\n+// end of generated patch\n+/* start of original code\n                     if (x == x1) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n+ end of original code*/\n                     break;\n                 default:\n                     // Should never happen.",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 32,
    "bugId": 271,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -187,3 +187,5 @@\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        if (false) {\n+                            x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        }\n                         f0 = computeObjectiveValue(x0);\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 32,
    "bugId": 271,
    "name": "Patch_7_6",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2019-07-29 16:42:56.656911522 -0400\n+++ /tmp/Arja_Defects4J_Math_50/patches_jy1t/Patch_6/patched/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2019-07-29 17:17:40.359255523 -0400\n@@ -183,11 +183,7 @@\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n-                    // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+                    ;\n                     break;\n                 default:\n                     // Should never happen.\n\n\n--- /tmp/Arja_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-07-29 16:42:52.956964181 -0400\n+++ /tmp/Arja_Defects4J_Math_50/patches_jy1t/Patch_6/patched/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2019-07-29 17:17:40.391255068 -0400\n@@ -368,9 +368,6 @@\n     public static void verifyBracketing(UnivariateRealFunction function,\n                                         final double lower,\n                                         final double upper) {\n-        if (function == null) {\n-            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n-        }\n         verifyInterval(lower, upper);\n         if (!isBracketing(function, lower, upper)) {\n             throw new NoBracketingException(lower, upper,\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 32,
    "bugId": 271,
    "name": "Patch_8_7",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d982..0a0a7b6 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -185,7 +185,7 @@ public abstract class BaseSecantSolver\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = 0.5 * (f0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 32,
    "bugId": 271,
    "name": "Patch_3_3",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n+++ /tmp/jMutRepair_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n@@ -184,7 +184,7 @@\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REGULA_FALSI :\n \n-\t\t\t\t\t\tif (x == x1) {\n+\t\t\t\t\t\tif (x > x1) {\n \t\t\t\t\t\t\tx0 = 0.5 * ((x0 + x1) - (org.apache.commons.math.util.FastMath.max((rtol * (org.apache.commons.math.util.FastMath.abs(x1))), atol)));\n \t\t\t\t\t\t\tf0 = computeObjectiveValue(x0);\n \t\t\t\t\t\t}\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 32,
    "bugId": 271,
    "name": "Patch_1_1",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n+++ /tmp/jKali_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n@@ -184,10 +184,10 @@\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tcase REGULA_FALSI :\n \n-\t\t\t\t\t\tif (x == x1) {\n-\t\t\t\t\t\t\tx0 = 0.5 * ((x0 + x1) - (org.apache.commons.math.util.FastMath.max((rtol * (org.apache.commons.math.util.FastMath.abs(x1))), atol)));\n+\t\t\t\t\t\tif (x == x1)\n+\n \t\t\t\t\t\t\tf0 = computeObjectiveValue(x0);\n-\t\t\t\t\t\t}\n+\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault :\n \n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 32,
    "bugId": 271,
    "name": "Patch_5_4",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n+++ /tmp/jGenProg_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverjava\n@@ -185,8 +185,8 @@\n \t\t\t\t\tcase REGULA_FALSI :\n \n \t\t\t\t\t\tif (x == x1) {\n-\t\t\t\t\t\t\tx0 = 0.5 * ((x0 + x1) - (org.apache.commons.math.util.FastMath.max((rtol * (org.apache.commons.math.util.FastMath.abs(x1))), atol)));\n-\t\t\t\t\t\t\tf0 = computeObjectiveValue(x0);\n+\n+\t\t\t\t\t\t\tf0 = computeObjectiveValue(x0); \t\t\t\t\t\t\tx0 = 0.5 * ((x0 + x1) - (org.apache.commons.math.util.FastMath.max((rtol * (org.apache.commons.math.util.FastMath.abs(x1))), atol))); \t\t\t\t\t\t\tf0 = computeObjectiveValue(x0);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault :\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 32,
    "bugId": 271,
    "name": "Patch_26_20",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d982..3c1a599 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -185,7 +185,7 @@ public abstract class BaseSecantSolver\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), fx));\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 32,
    "bugId": 271,
    "name": "Patch_26_20",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d982..3c1a599 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -185,7 +185,7 @@ public abstract class BaseSecantSolver\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), fx));\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 32,
    "bugId": 271,
    "name": "Patch_1_1",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d982..417875a 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -185,7 +185,7 @@ public abstract class BaseSecantSolver\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 += 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 32,
    "bugId": 271,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2018-12-01 17:08:08.863378056 -0500\n+++ /tmp/Kali_Defects4J_Math_50/patches_tjun/Patch_2/patched/tmp/Kali_Defects4J_Math_50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2018-12-01 17:18:51.905209748 -0500\n@@ -184,7 +184,7 @@\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n+                    if (false) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 33,
    "bugId": 277,
    "name": "Patch_9_9",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/FastMath.java b/src/main/java/org/apache/commons/math/util/FastMath.java\nindex 8cba4d484..ead4e946a 100644\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -904,7 +904,7 @@ public class FastMath {\n      *  For x between 0 and 1, returns exp(x), uses extended precision\n      *  @param x argument of exponential\n      *  @param result placeholder where to place exp(x) split in two terms\n-     *  for extra precision (i.e. exp(x) = result[0] \u00b0 result[1]\n+     *  for extra precision (i.e. exp(x) = result[0] ?? result[1]\n      *  @return exp(x)\n      */\n     private static double slowexp(final double x, final double result[]) {\n@@ -3479,7 +3479,12 @@ public class FastMath {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n+// start of generated patch\n+return (a<=b)?b:(Float.isNaN(a+b)?Float.NaN:a);\n+// end of generated patch\n+/* start of original code\n         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+ end of original code*/\n     }\n \n     /** Compute the maximum of two values",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 33,
    "bugId": 277,
    "name": "Patch_38_34",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/FastMath.java b/src/main/java/org/apache/commons/math/util/FastMath.java\nindex 8cba4d4..eca1fff 100644\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -904,7 +904,7 @@ public class FastMath {\n      *  For x between 0 and 1, returns exp(x), uses extended precision\n      *  @param x argument of exponential\n      *  @param result placeholder where to place exp(x) split in two terms\n-     *  for extra precision (i.e. exp(x) = result[0] ?? result[1]\n+     *  for extra precision (i.e. exp(x) = result[0] ?? result[1]\n      *  @return exp(x)\n      */\n     private static double slowexp(final double x, final double result[]) {\n@@ -3479,7 +3479,7 @@ public class FastMath {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n     }\n \n     /** Compute the maximum of two values\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 34,
    "bugId": 50,
    "name": "Patch_1709_1709",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex b9aa412c..80a021ee 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -109,6 +109,14 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n+// start of generated patch\n+for(Node an : parent.getAncestors()){\n+int ancestorType=parent.getParent().getType();\n+if(ancestorType==Token.COMMA)continue;\n+if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;\n+}\n+// end of generated patch\n+/* start of original code\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)\n@@ -118,6 +126,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n           else\n             break;\n         }\n+ end of original code*/\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 34,
    "bugId": 50,
    "name": "Patch_2_2",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-11 18:02:28.318245911 -0400\n+++ /tmp/Arja_Defects4J_Closure_22/patches_iu5x/Patch_2/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-11 18:24:36.561350230 -0400\n@@ -100,13 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n@@ -114,8 +108,8 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+\t\t\t;\n+\t\telse\n             break;\n         }\n       }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 34,
    "bugId": 50,
    "name": "Patch_77_31",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex b9aa412..376e39f 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -108,7 +108,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n+      if (gramps == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 34,
    "bugId": 50,
    "name": "Patch_17_9",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffectsjava\n+++ /tmp/jMutRepair_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffectsjava\n@@ -111,7 +111,7 @@\n \t\t\tif (n == (parent.getLastChild())) {\n \t\t\t\tfor (com.google.javascript.rhino.Node an : parent.getAncestors()) {\n \t\t\t\t\tint ancestorType = an.getType();\n-\t\t\t\t\tif (ancestorType == (com.google.javascript.rhino.Token.COMMA))\n+\t\t\t\t\tif (ancestorType >= (com.google.javascript.rhino.Token.COMMA))\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tif ((ancestorType != (com.google.javascript.rhino.Token.EXPR_RESULT)) && (ancestorType != (com.google.javascript.rhino.Token.BLOCK)))\n \t\t\t\t\t\treturn;else\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 34,
    "bugId": 50,
    "name": "Patch_14_14",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffectsjava\n+++ /tmp/jKali_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffectsjava\n@@ -113,10 +113,10 @@\n \t\t\t\t\tint ancestorType = an.getType();\n \t\t\t\t\tif (ancestorType == (com.google.javascript.rhino.Token.COMMA))\n \t\t\t\t\t\tcontinue;\n-\t\t\t\t\tif ((ancestorType != (com.google.javascript.rhino.Token.EXPR_RESULT)) && (ancestorType != (com.google.javascript.rhino.Token.BLOCK)))\n-\t\t\t\t\t\treturn;else\n \n-\t\t\t\t\t\tbreak;\n+\n+\n+\n \t\t\t\t}\n \t\t\t}\n \t\t}else \t\t\tif (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) {\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 34,
    "bugId": 50,
    "name": "Patch_64_46",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffectsjava\n+++ /tmp/jGenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffectsjava\n@@ -109,15 +109,15 @@\n \n \n \t\t\tif (n == (parent.getLastChild())) {\n-\t\t\t\tfor (com.google.javascript.rhino.Node an : parent.getAncestors()) {\n-\t\t\t\t\tint ancestorType = an.getType();\n-\t\t\t\t\tif (ancestorType == (com.google.javascript.rhino.Token.COMMA)) \n-\t\t\t\t\t{ \t\t\t\t\t\tcontinue;}\n-\t\t\t\t\tif ((ancestorType != (com.google.javascript.rhino.Token.EXPR_RESULT)) && (ancestorType != (com.google.javascript.rhino.Token.BLOCK)))\n-\t\t\t\t\t\treturn;else\n \n-\t\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\n+\n+\n+\n+\n+\n+\n+\n \t\t\t}\n \t\t}else \t\t\tif (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) {\n \t\t\t\tif ((((parent.getType()) == (com.google.javascript.rhino.Token.FOR)) && ((parent.getChildCount()) == 4)) && ((n == (parent.getFirstChild())) || \n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 34,
    "bugId": 50,
    "name": "Patch_5_5",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex b9aa412..be5a6f5 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -111,7 +111,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n+          if (ancestorType>=Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n             return;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 34,
    "bugId": 50,
    "name": "Patch_15_7",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-12 09:46:59.317993059 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_22/patches_geao/Patch_7/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-12 10:08:41.680445130 -0400\n@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 34,
    "bugId": 50,
    "name": "Patch_24_7",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-11 13:57:59.465714477 -0400\n+++ /tmp/GenProg_Defects4J_Closure_22/patches_m6gq/Patch_7/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-11 14:19:41.237554108 -0400\n@@ -113,10 +113,6 @@\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)\n             continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 34,
    "bugId": 50,
    "name": "Patch_4_4",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-01 20:16:47.277193162 -0500\n+++ /tmp/Kali_Defects4J_Closure_22/patches_2bcl/Patch_4/patched/tmp/Kali_Defects4J_Closure_22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-01 20:20:56.170828245 -0500\n@@ -108,7 +108,7 @@\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n+      if (false) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 35,
    "bugId": 85,
    "name": "Patch_26_26",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/ClosureCodingConvention.java b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\nindex c507c924..558d01b8 100644\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n@@ -194,9 +194,16 @@ public class ClosureCodingConvention extends DefaultCodingConvention {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n+// start of generated patch\n+if(target!=null&&target.getType()==Token.STRING){\n+className=target.getString();\n+}\n+// end of generated patch\n+/* start of original code\n           if (target != null) {\n             className = target.getString();\n           }\n+ end of original code*/\n         }\n       }\n     }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 36,
    "bugId": 192,
    "name": "Patch_43_43",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex 615e4a9a..6c297d6e 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -906,9 +906,16 @@ public class ClassUtils {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n+// start of generated patch\n+for(int i=0;i<array.length;i++){\n+classes[i]=array[i]==null?null:array[i].getClass();\n+}\n+// end of generated patch\n+/* start of original code\n         for (int i = 0; i < array.length; i++) {\n             classes[i] = array[i].getClass();\n         }\n+ end of original code*/\n         return classes;\n     }\n ",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 36,
    "bugId": 192,
    "name": "Patch_47_28",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex 615e4a9..baadf72 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -907,7 +907,9 @@ public class ClassUtils {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+            if (classes == null) continue;\n+\tif (array[i] == null) continue;\n+\tclasses[i] = array[i].getClass();\n         }\n         return classes;\n     }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_1091_1091",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d8b..81fc381e4 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1134,11 +1134,20 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n             // flip array\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n+// start of generated patch\n+for(int k=0;k<0;k+=step){\n+ final double tmp=work[i+k];\n+work[i+k]=work[j-k];\n+work[j-k]=tmp;\n+}\n+// end of generated patch\n+/* start of original code\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n                 }\n+ end of original code*/\n                 j -= 4;\n             }\n             return true;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1135,9 +1135,11 @@\n             int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n+            if (false) {\n+                for (int i = 0; i < j; i += 4) {\n+                    for (int k = 0; k < 4; k += step) {\n+                        final double tmp = work[i + k];\n+                        work[i + k] = work[j - k];\n+                        work[j - k] = tmp;\n+                    }\n+                    j -= 4;\n                 }\n-                j -= 4;\n             }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_12_11",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-07-31 06:07:50.009399204 -0400\n+++ /tmp/Arja_Defects4J_Math_80/patches_kh1g/Patch_11/patched/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-07-31 06:15:58.138141948 -0400\n@@ -1059,7 +1059,7 @@\n                 work[l - 2 * pingPong] =\n                     Math.min(work[l - 2 * pingPong],\n                              Math.min(work[6 + pingPong], work[6 + pingPong]));\n-                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\n+                dMin = 0.0;\n                 dMin  = -0.0;\n             }\n         }\n@@ -1103,7 +1103,7 @@\n                     } else {\n                         // early failure. Divide by 4.\n                         tau *= 0.25;\n-                        tType -= 12;\n+                        tType = -8;\n                     }\n                 } else if (Double.isNaN(dMin)) {\n                     tau = 0.0;\n@@ -1134,11 +1134,6 @@\n             // flip array\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n                 j -= 4;\n             }\n             return true;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_1243_193",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d..e316bf1 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * this.pingPong - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_305_301",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n+++ /tmp/jMutRepair_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n@@ -1130,7 +1130,7 @@\n \n \n \tprivate boolean flipIfWarranted(final int n, final int step) {\n-\t\tif ((1.5 * (work[pingPong])) < (work[((4 * (n - 1)) + (pingPong))])) {\n+\t\tif ((1.5 * (this.work[this.pingPong])) == (this.work[((4 * (n - 1)) + (this.pingPong))])) {\n \n \t\t\tint j = (4 * n) - 1;\n \t\t\tfor (int i = 0; i < j; i += 4) {\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_14_14",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n+++ /tmp/jKali_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n@@ -1133,14 +1133,14 @@\n \t\tif ((1.5 * (work[pingPong])) < (work[((4 * (n - 1)) + (pingPong))])) {\n \n \t\t\tint j = (4 * n) - 1;\n-\t\t\tfor (int i = 0; i < j; i += 4) {\n-\t\t\t\tfor (int k = 0; k < 4; k += step) {\n-\t\t\t\t\tfinal double tmp = work[(i + k)];\n-\t\t\t\t\twork[(i + k)] = work[(j - k)];\n-\t\t\t\t\twork[(j - k)] = tmp;\n-\t\t\t\t}\n-\t\t\t\tj -= 4;\n-\t\t\t}\n+\n+\n+\n+\n+\n+\n+\n+\n \t\t\treturn true;\n \t\t}\n \t\treturn false;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_4341_2826",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d..c45289c 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -837,7 +837,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n         }\n \n         // initial checks for splits (see Parlett & Marques section 3.3)\n-        flipIfWarranted(n, 2);\n+        goodStep(n, 2);\n \n         // two iterations with Li's test for initial splits\n         initialSplits(n);",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1136,6 +1136,8 @@\n             for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n+                if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) {\n+                    for (int k = 0; k < 4; k += step) {\n+                        final double tmp = work[i + k];\n+                        work[i + k] = work[j - k];\n+                        work[j - k] = tmp;\n+                    }\n                 }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_4341_2826",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d..c45289c 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -837,7 +837,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n         }\n \n         // initial checks for splits (see Parlett & Marques section 3.3)\n-        flipIfWarranted(n, 2);\n+        goodStep(n, 2);\n \n         // two iterations with Li's test for initial splits\n         initialSplits(n);",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_931_596",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d..e316bf1 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * this.pingPong - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_9_7",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-02 23:51:16.192878213 -0400\n+++ /tmp/RSRepair_Defects4J_Math_80/patches_p656/Patch_7/patched/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-03 00:00:49.290945988 -0400\n@@ -1133,14 +1133,7 @@\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n             int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n-                j -= 4;\n-            }\n+            int mBlockIndex = 0;\n             return true;\n         }\n         return false;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_9_2",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-01 08:48:56.072067282 -0400\n+++ /tmp/GenProg_Defects4J_Math_80/patches_hsqy/Patch_2/patched/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-01 08:56:45.109393141 -0400\n@@ -869,7 +869,6 @@\n             for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                 if (work[i + 2] <= 0) {\n                     i0 = 1 + i / 4;\n-                    break;\n                 }\n                 if (diagMin >= 4 * offDiagMax) {\n                     diagMin    = Math.min(diagMin, work[i + 4]);\n@@ -1090,7 +1089,8 @@\n                     work[4 * deflatedEnd - 3 - pingPong] = 0.0;\n                     dMin = 0.0;\n                     updateSigma(tau);\n-                    return deflatedEnd;\n+                    final int upperStart = 5 * main.length;\n+\t\t\t\t\treturn deflatedEnd;\n                 } else if (dMin < 0.0) {\n                     // tau too big. Select new tau and try again.\n                     if (tType < -22) {\n@@ -1134,11 +1134,15 @@\n             // flip array\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n+                if (tType < -22) {\n+\t\t\t\t\ttau = 0.0;\n+\t\t\t\t} else if (dMin1 > 0.0) {\n+\t\t\t\t\ttau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\n+\t\t\t\t\ttType -= 11;\n+\t\t\t\t} else {\n+\t\t\t\t\ttau *= 0.25;\n+\t\t\t\t\ttType -= 12;\n+\t\t\t\t}\n                 j -= 4;\n             }\n             return true;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 37,
    "bugId": 305,
    "name": "Patch_13_13",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2018-12-01 16:43:04.613721010 -0500\n+++ /tmp/Kali_Defects4J_Math_80/patches_8w5w/Patch_5/patched/tmp/Kali_Defects4J_Math_80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2018-12-01 16:44:54.681989926 -0500\n@@ -1135,7 +1135,9 @@\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n+                    if (true)\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\tfinal double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n                 }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 38,
    "bugId": 268,
    "name": "Patch_17_17",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\nindex 1203d516c..547bc8dc2 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n@@ -574,8 +574,15 @@ public class SummaryStatistics implements StatisticalSummary, Serializable {\n      * @since 1.2\n      */\n     public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {\n+// start of generated patch\n+this.sumImpl=geoMeanImpl;\n+checkEmpty();\n+this.geoMeanImpl=geoMeanImpl;\n+// end of generated patch\n+/* start of original code\n         checkEmpty();\n         this.geoMeanImpl = geoMeanImpl;\n+ end of original code*/\n     }\n \n     /**\n@@ -632,8 +639,15 @@ public class SummaryStatistics implements StatisticalSummary, Serializable {\n      * @since 1.2\n      */\n     public void setVarianceImpl(StorelessUnivariateStatistic varianceImpl) {\n+// start of generated patch\n+this.sumImpl=varianceImpl;\n+checkEmpty();\n+this.varianceImpl=varianceImpl;\n+// end of generated patch\n+/* start of original code\n         checkEmpty();\n         this.varianceImpl = varianceImpl;\n+ end of original code*/\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 38,
    "bugId": 268,
    "name": "Patch_115_106",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\nindex 1203d51..a167454 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n@@ -155,7 +155,7 @@ public class SummaryStatistics implements StatisticalSummary, Serializable {\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n+        if ((!(meanImpl instanceof Mean)) || !(!(varianceImpl instanceof Variance))) {\n             meanImpl.increment(value);\n         }\n         if (!(varianceImpl instanceof Variance)) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 38,
    "bugId": 268,
    "name": "Patch_125_116",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\nindex 1203d51..6f8ae74 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n@@ -161,7 +161,7 @@ public class SummaryStatistics implements StatisticalSummary, Serializable {\n         if (!(varianceImpl instanceof Variance)) {\n             varianceImpl.increment(value);\n         }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+        if ((!(geoMeanImpl instanceof GeometricMean)) || !(!(meanImpl instanceof Mean))) {\n             geoMeanImpl.increment(value);\n         }\n         n++;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 38,
    "bugId": 268,
    "name": "Patch_120_111",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\nindex 1203d51..356808f 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n@@ -158,7 +158,7 @@ public class SummaryStatistics implements StatisticalSummary, Serializable {\n         if (!(meanImpl instanceof Mean)) {\n             meanImpl.increment(value);\n         }\n-        if (!(varianceImpl instanceof Variance)) {\n+        if ((!(varianceImpl instanceof Variance)) || !(!(meanImpl instanceof Mean))) {\n             varianceImpl.increment(value);\n         }\n         if (!(geoMeanImpl instanceof GeometricMean)) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 39,
    "bugId": 215,
    "name": "Patch_1138_1138",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex c0f06a47..1e37c4ac 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -449,6 +449,17 @@ public class NumberUtils {\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n+// start of generated patch\n+if(dec==null&&exp==null&&(numeric.charAt(0)=='-'&&isDigits(numeric.substring(1))||isDigits(numeric))){\n+try{\n+return createLong(numeric);\n+}catch (NumberFormatException nfe) {\n+}\n+\n+return createBigInteger(numeric);\n+}\n+// end of generated patch\n+/* start of original code\n                     if (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n@@ -461,6 +472,7 @@ public class NumberUtils {\n                         return createBigInteger(numeric);\n \n                     }\n+ end of original code*/\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 39,
    "bugId": 215,
    "name": "Patch_999_513",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex c0f06a4..cd862e8 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -451,7 +451,6 @@ public class NumberUtils {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 39,
    "bugId": 215,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -463,3 +463,5 @@\n                     }\n-                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                    if ((numeric.length()) != (org.apache.commons.lang.math.NumberUtils.SHORT_ONE)) {\n+                        throw new NumberFormatException(str + \" is not a valid number.\");\n+                    }\n                 case 'f' :\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 39,
    "bugId": 215,
    "name": "Patch_1889_735",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex c0f06a4..b5e17ed 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -449,8 +449,7 @@ public class NumberUtils {\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n-                    if (dec == null\n-                        && exp == null\n+                    if (dec == null || exp == null\n                         && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 39,
    "bugId": 215,
    "name": "Patch_1789_1078",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex c0f06a4..ef99ac1 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -449,10 +449,10 @@ public class NumberUtils {\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n-                    if (dec == null\n+                    if (dec != numeric || (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 40,
    "bugId": 293,
    "name": "Patch_63_63",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\nindex 83b4c4130..42702674c 100644\n--- a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n@@ -163,6 +163,16 @@ public class PearsonsCorrelation {\n         double[][] out = new double[nVars][nVars];\n         for (int i = 0; i < nVars; i++) {\n             for (int j = 0; j < nVars; j++) {\n+// start of generated patch\n+if(i==j&&i<nVars){\n+out[i][j]=0.0;\n+}else {\n+double r=correlationMatrix.getEntry(i,j);\n+double t=Math.abs(r*Math.sqrt((nObs-2)/(1-r*r)));\n+out[i][j]=2*(1-tDistribution.cumulativeProbability(t));\n+}\n+// end of generated patch\n+/* start of original code\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n@@ -170,6 +180,7 @@ public class PearsonsCorrelation {\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                 }\n+ end of original code*/\n             }\n         }\n         return new BlockRealMatrix(out);",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 40,
    "bugId": 293,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n@@ -188,9 +188,11 @@\n         RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n-        for (int i = 0; i < nVars; i++) {\n-            for (int j = 0; j < i; j++) {\n-              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n-              outMatrix.setEntry(i, j, corr);\n-              outMatrix.setEntry(j, i, corr);\n+        if ((nVars) != (2)) {\n+            for (int i = 0; i < nVars; i++) {\n+                for (int j = 0; j < i; j++) {\n+                    double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n+                    outMatrix.setEntry(i, j, corr);\n+                    outMatrix.setEntry(j, i, corr);\n+                }\n+                outMatrix.setEntry(i, i, 1d);\n             }\n-            outMatrix.setEntry(i, i, 1d);\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 41,
    "bugId": 42,
    "name": "Patch_15_15",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 0d1e95a0..122ae73b 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -115,12 +115,21 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n         return;\n       }\n       if (n == parent.getLastChild()) {\n+// start of generated patch\n+for(Node an : parent.getAncestors()){\n+int ancestorType=parent.getParent().getType();\n+if(ancestorType==Token.COMMA)continue;\n+if(ancestorType!=Token.EXPR_RESULT&&ancestorType!=Token.BLOCK)return ;else break;\n+}\n+// end of generated patch\n+/* start of original code\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n         }\n+ end of original code*/\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 41,
    "bugId": 42,
    "name": "Patch_18_5",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-11 17:40:25.438992596 -0400\n+++ /tmp/Arja_Defects4J_Closure_21/patches_yxa3/Patch_5/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-11 18:02:24.366355686 -0400\n@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          break;\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 41,
    "bugId": 42,
    "name": "Patch_15_4",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 0d1e95a..e3b17ca 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -116,7 +116,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n       }\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n+          int ancestorType = parent.getType();\n           if (ancestorType == Token.COMMA) continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 41,
    "bugId": 42,
    "name": "Patch_2_2",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffectsjava\n+++ /tmp/jMutRepair_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffectsjava\n@@ -117,7 +117,7 @@\n \t\t\tif (n == (parent.getLastChild())) {\n \t\t\t\tfor (com.google.javascript.rhino.Node an : parent.getAncestors()) {\n \t\t\t\t\tint ancestorType = an.getType();\n-\t\t\t\t\tif (ancestorType == (com.google.javascript.rhino.Token.COMMA)) \t\t\t\t\t\tcontinue;\n+\t\t\t\t\tif (ancestorType >= (com.google.javascript.rhino.Token.COMMA)) \t\t\t\t\t\tcontinue;\n \t\t\t\t\tif ((ancestorType != (com.google.javascript.rhino.Token.EXPR_RESULT)) && (ancestorType != (com.google.javascript.rhino.Token.BLOCK))) \t\t\t\t\t\treturn;else\n \t\t\t\t\t\tbreak;\n \t\t\t\t}\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 41,
    "bugId": 42,
    "name": "Patch_2_2",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffectsjava\n+++ /tmp/jKali_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffectsjava\n@@ -115,12 +115,12 @@\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (n == (parent.getLastChild())) {\n-\t\t\t\tfor (com.google.javascript.rhino.Node an : parent.getAncestors()) {\n-\t\t\t\t\tint ancestorType = an.getType();\n-\t\t\t\t\tif (ancestorType == (com.google.javascript.rhino.Token.COMMA)) \t\t\t\t\t\tcontinue;\n-\t\t\t\t\tif ((ancestorType != (com.google.javascript.rhino.Token.EXPR_RESULT)) && (ancestorType != (com.google.javascript.rhino.Token.BLOCK))) \t\t\t\t\t\treturn;else\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\n+\n+\n+\n+\n+\n \t\t\t}\n \t\t}else \t\t\tif (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) {\n \t\t\t\tif (!((((parent.getType()) == (com.google.javascript.rhino.Token.FOR)) && ((parent.getChildCount()) == 4)) && ((n == (parent.getFirstChild())) || (n == (parent.getFirstChild().getNext().getNext()))))) {\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 41,
    "bugId": 42,
    "name": "Patch_7_6",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffectsjava\n+++ /tmp/jGenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffectsjava\n@@ -115,12 +115,12 @@\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tif (n == (parent.getLastChild())) {\n-\t\t\t\tfor (com.google.javascript.rhino.Node an : parent.getAncestors()) {\n-\t\t\t\t\tint ancestorType = an.getType();\n-\t\t\t\t\tif (ancestorType == (com.google.javascript.rhino.Token.COMMA)) { \t\t\t\t\t\tcontinue;}\n-\t\t\t\t\tif ((ancestorType != (com.google.javascript.rhino.Token.EXPR_RESULT)) && (ancestorType != (com.google.javascript.rhino.Token.BLOCK))) \t\t\t\t\t\treturn;else\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\n+\n+\n+\n+\n+\n \t\t\t}\n \t\t}else \t\t\tif (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) {\n \t\t\t\tif (!((((parent.getType()) == (com.google.javascript.rhino.Token.FOR)) && ((parent.getChildCount()) == 4)) && ((n == (parent.getFirstChild())) || (n == (parent.getFirstChild().getNext().getNext()))))) {\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 41,
    "bugId": 42,
    "name": "Patch_260_40",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 0d1e95a..da286bc 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -117,7 +117,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n+          if ((ancestorType == Token.COMMA) || (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK)) continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 41,
    "bugId": 42,
    "name": "Patch_1_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-12 09:24:44.821515365 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_21/patches_voof/Patch_1/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-12 09:46:56.146036324 -0400\n@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 41,
    "bugId": 42,
    "name": "Patch_61_20",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-11 13:34:13.361328529 -0400\n+++ /tmp/GenProg_Defects4J_Closure_21/patches_kg96/Patch_20/patched/com/google/javascript/jscomp/CheckSideEffects.java\t2019-08-11 13:57:56.089808252 -0400\n@@ -114,14 +114,7 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n+      int start = 0;\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 41,
    "bugId": 42,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-01 20:17:04.425243768 -0500\n+++ /tmp/Kali_Defects4J_Closure_21/patches_k7vg/Patch_1/patched/tmp/Kali_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java\t2018-12-01 20:23:23.810602242 -0500\n@@ -117,7 +117,7 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n+          if (true) continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n         }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 42,
    "bugId": 10,
    "name": "Patch_914_914",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..b695a6b 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1792,11 +1792,20 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         if (this.plot == null) {\n             return result;\n         }\n+// start of generated patch\n+int index=this.plot.getIndexOf(this);\n+CategoryDataset dataset=this.plot.getDataset(index);\n+if(dataset==null){\n+return result;\n+}\n+// end of generated patch\n+/* start of original code\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n         if (dataset != null) {\n             return result;\n         }\n+end of original code*/\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 42,
    "bugId": 10,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1796,4 +1796,6 @@\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n-            return result;\n+        if (false) {\n+            if (dataset != null) {\n+                return result;\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 42,
    "bugId": 10,
    "name": "Patch_12_12",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2019-07-18 22:49:49.801927325 -0400\n+++ /tmp/Arja_Defects4J_Chart_1/patches_hz0m/Patch_12/patched/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2019-07-18 23:00:47.997925833 -0400\n@@ -1794,9 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n-            return result;\n-        }\n+        setPlot(plot);\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 42,
    "bugId": 10,
    "name": "Patch_1504_481",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..4a54655 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (dataset == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 42,
    "bugId": 10,
    "name": "Patch_33_13",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n+++ /tmp/jMutRepair_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n@@ -1794,7 +1794,7 @@\n \t\t}\n \t\tint index = this.plot.getIndexOf(this);\n \t\torg.jfree.data.category.CategoryDataset dataset = this.plot.getDataset(index);\n-\t\tif (dataset != null) {\n+\t\tif (dataset == null) {\n \t\t\treturn result;\n \t\t}\n \t\tint seriesCount = dataset.getRowCount();\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 42,
    "bugId": 10,
    "name": "Patch_36_35",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n+++ /tmp/jKali_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRendererjava\n@@ -1794,7 +1794,7 @@\n \t\t}\n \t\tint index = this.plot.getIndexOf(this);\n \t\torg.jfree.data.category.CategoryDataset dataset = this.plot.getDataset(index);\n-\t\tif (dataset != null) {\n+\t\tif (false) {\n \t\t\treturn result;\n \t\t}\n \t\tint seriesCount = dataset.getRowCount();\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 42,
    "bugId": 10,
    "name": "Patch_1169_297",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..4a54655 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (dataset == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 42,
    "bugId": 10,
    "name": "Patch_1169_297",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..4a54655 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (dataset == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 42,
    "bugId": 10,
    "name": "Patch_2781_1214",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..4a54655 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (dataset == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 42,
    "bugId": 10,
    "name": "Patch_104_70",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Chart_1/source/org/jfree/chart/plot/CategoryPlot.java\t2019-07-23 12:00:22.892790297 -0400\n+++ /tmp/GenProg_Defects4J_Chart_1/patches_9l9w/Patch_70/patched/org/jfree/chart/plot/CategoryPlot.java\t2019-07-23 12:15:52.721220004 -0400\n@@ -1042,7 +1042,8 @@\n             result = (ValueAxis) this.rangeAxes.get(index);\n         }\n         if (result == null) {\n-            Plot parent = getParent();\n+            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n+\t\t\tPlot parent = getParent();\n             if (parent instanceof CategoryPlot) {\n                 CategoryPlot cp = (CategoryPlot) parent;\n                 result = cp.getRangeAxis(index);\n@@ -1349,7 +1350,8 @@\n      */\n     public void setDataset(int index, CategoryDataset dataset) {\n \n-        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n+        Object result = null;\n+\t\tCategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n         if (existing != null) {\n             existing.removeChangeListener(this);\n         }\n\n\n--- /tmp/GenProg_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2019-07-23 12:00:27.364811602 -0400\n+++ /tmp/GenProg_Defects4J_Chart_1/patches_9l9w/Patch_70/patched/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2019-07-23 12:15:52.745220118 -0400\n@@ -1795,7 +1795,7 @@\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n         if (dataset != null) {\n-            return result;\n+            Paint outlinePaint = plot.getOutlinePaint();\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 42,
    "bugId": 10,
    "name": "Patch_16_16",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2018-12-01 19:01:39.066799642 -0500\n+++ /tmp/Kali_Defects4J_Chart_1/patches_1bmm/Patch_16/patched/tmp/Kali_Defects4J_Chart_1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2018-12-01 19:05:24.712543098 -0500\n@@ -1794,7 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (false) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 43,
    "bugId": 39,
    "name": "Patch_2251_2251",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..16fe8ad6 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -763,9 +763,16 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n+// start of generated patch\n+for(Node finallyNode : cfa.finallyMap.get(parent)){\n+cfa.createEdge(fromNode,Branch.ON_EX,finallyNode);\n+}\n+// end of generated patch\n+/* start of original code\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n+ end of original code*/\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 44,
    "bugId": 11,
    "name": "Patch_107_107",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/chart/plot/MultiplePiePlot.java b/source/org/jfree/chart/plot/MultiplePiePlot.java\nindex fedc205..f1e2164 100644\n--- a/source/org/jfree/chart/plot/MultiplePiePlot.java\n+++ b/source/org/jfree/chart/plot/MultiplePiePlot.java\n@@ -142,9 +142,19 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n+// start of generated patch\n+if(dataset!=null){\n+dataset.addChangeListener(this);\n+}\n+this.dataset=dataset;\n+PiePlot piePlot=new PiePlot(null);\n+this.pieChart=new JFreeChart(piePlot);\n+// end of generated patch\n+/* start of original code\n         this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n+end of original code*/\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 44,
    "bugId": 11,
    "name": "Patch_87_84",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2019-07-19 05:49:53.733870208 -0400\n+++ /tmp/Arja_Defects4J_Chart_12/patches_p20q/Patch_84/patched/org/jfree/chart/plot/MultiplePiePlot.java\t2019-07-19 06:02:12.613868534 -0400\n@@ -145,7 +145,8 @@\n         this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n-        this.pieChart.removeLegend();\n+        setDataset(dataset);\n+\t\tthis.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n         TextTitle seriesTitle = new TextTitle(\"Series Title\",\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 44,
    "bugId": 11,
    "name": "Patch_8_5",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/data/general/AbstractDataset.java b/source/org/jfree/data/general/AbstractDataset.java\nindex c77a8bc..b01688b 100644\n--- a/source/org/jfree/data/general/AbstractDataset.java\n+++ b/source/org/jfree/data/general/AbstractDataset.java\n@@ -157,7 +157,7 @@ public abstract class AbstractDataset implements Dataset,\n      * @see #removeChangeListener(DatasetChangeListener)\n      */\n     public boolean hasListener(EventListener listener) {\n-        List list = Arrays.asList(this.listenerList.getListenerList());\n+        List list = Arrays.asList(listener);\n         return list.contains(listener);\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 44,
    "bugId": 11,
    "name": "Patch_8_5",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/data/general/AbstractDataset.java b/source/org/jfree/data/general/AbstractDataset.java\nindex c77a8bc..b01688b 100644\n--- a/source/org/jfree/data/general/AbstractDataset.java\n+++ b/source/org/jfree/data/general/AbstractDataset.java\n@@ -157,7 +157,7 @@ public abstract class AbstractDataset implements Dataset,\n      * @see #removeChangeListener(DatasetChangeListener)\n      */\n     public boolean hasListener(EventListener listener) {\n-        List list = Arrays.asList(this.listenerList.getListenerList());\n+        List list = Arrays.asList(listener);\n         return list.contains(listener);\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 44,
    "bugId": 11,
    "name": "Patch_39_22",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/data/general/AbstractDataset.java b/source/org/jfree/data/general/AbstractDataset.java\nindex c77a8bc..b5650b0 100644\n--- a/source/org/jfree/data/general/AbstractDataset.java\n+++ b/source/org/jfree/data/general/AbstractDataset.java\n@@ -158,7 +158,7 @@ public abstract class AbstractDataset implements Dataset,\n      */\n     public boolean hasListener(EventListener listener) {\n         List list = Arrays.asList(this.listenerList.getListenerList());\n-        return list.contains(listener);\n+        return list != null || list.contains(listener);\n     }\n     \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 44,
    "bugId": 11,
    "name": "Patch_95_28",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Chart_12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2019-07-30 04:17:48.396679468 -0400\n+++ /tmp/RSRepair_Defects4J_Chart_12/patches_4a74/Patch_28/patched/org/jfree/chart/plot/MultiplePiePlot.java\t2019-07-30 04:26:12.447716287 -0400\n@@ -152,7 +152,10 @@\n                 new Font(\"SansSerif\", Font.BOLD, 12));\n         seriesTitle.setPosition(RectangleEdge.BOTTOM);\n         this.pieChart.setTitle(seriesTitle);\n-        this.aggregatedItemsKey = \"Other\";\n+        if (dataset != null) {\n+\t\t\tdataset.addChangeListener(this);\n+\t\t}\n+\t\tthis.aggregatedItemsKey = \"Other\";\n         this.aggregatedItemsPaint = Color.lightGray;\n         this.sectionPaints = new HashMap();\n     }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 44,
    "bugId": 11,
    "name": "Patch_130_65",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Chart_12/source/org/jfree/chart/JFreeChart.java\t2019-07-23 18:37:04.906183335 -0400\n+++ /tmp/GenProg_Defects4J_Chart_12/patches_d944/Patch_65/patched/org/jfree/chart/JFreeChart.java\t2019-07-23 18:48:09.585349874 -0400\n@@ -661,7 +661,6 @@\n      * @see #getLegend()\n      */\n     public void removeLegend() {\n-        removeSubtitle(getLegend());\n     }\n     \n     /**\n@@ -793,7 +792,6 @@\n      */\n     public void removeSubtitle(Title title) {\n         this.subtitles.remove(title);\n-        fireChartChanged();\n     }\n     \n     /**\n\n\n--- /tmp/GenProg_Defects4J_Chart_12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2019-07-23 18:37:08.886202296 -0400\n+++ /tmp/GenProg_Defects4J_Chart_12/patches_d944/Patch_65/patched/org/jfree/chart/plot/MultiplePiePlot.java\t2019-07-23 18:48:09.605349969 -0400\n@@ -150,11 +150,12 @@\n         this.pieChart.setBackgroundPaint(null);\n         TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                 new Font(\"SansSerif\", Font.BOLD, 12));\n-        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n-        this.pieChart.setTitle(seriesTitle);\n+        if (dataset != null) {\n+\t\t\tsetDatasetGroup(dataset.getGroup());\n+\t\t\tdataset.addChangeListener(this);\n+\t\t}\n         this.aggregatedItemsKey = \"Other\";\n-        this.aggregatedItemsPaint = Color.lightGray;\n-        this.sectionPaints = new HashMap();\n+        Plot p = getParent();\n     }\n \n     /**\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 44,
    "bugId": 11,
    "name": "Patch_17_17",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Chart_12/source/org/jfree/data/general/AbstractDataset.java\t2018-12-01 18:54:08.475122910 -0500\n+++ /tmp/Kali_Defects4J_Chart_12/patches_kb09/Patch_19/patched/tmp/Kali_Defects4J_Chart_12/source/org/jfree/data/general/AbstractDataset.java\t2018-12-01 18:57:13.067493125 -0500\n@@ -157,7 +157,9 @@\n      * @see #removeChangeListener(DatasetChangeListener)\n      */\n     public boolean hasListener(EventListener listener) {\n-        List list = Arrays.asList(this.listenerList.getListenerList());\n+        if (true)\n+\t\t\treturn true;\n+\t\tList list = Arrays.asList(this.listenerList.getListenerList());\n         return list.contains(listener);\n     }\n     \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 45,
    "bugId": 135,
    "name": "Patch_6_6",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex e30c3509..9420b046 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1945,9 +1945,16 @@ public final class JsDocInfoParser {\n    * TypeApplication := '.<' TypeExpressionList '>'\n    */\n   private Node parseTypeName(JsDocToken token) {\n+// start of generated patch\n+if(token==null){\n+return reportGenericTypeSyntaxWarning();\n+}\n+// end of generated patch\n+/* start of original code\n     if (token != JsDocToken.STRING) {\n       return reportGenericTypeSyntaxWarning();\n     }\n+ end of original code*/\n \n     String typeName = stream.getString();\n     int lineno = stream.getLineno();",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 45,
    "bugId": 135,
    "name": "Patch_172_38",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex e30c350..cb61d8c 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1905,7 +1905,7 @@ public final class JsDocInfoParser {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+          return parseAndRecordTypeNode(token);\n   }\n \n   /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 45,
    "bugId": 135,
    "name": "Patch_270_73",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex e30c350..cb61d8c 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1905,7 +1905,7 @@ public final class JsDocInfoParser {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+          return parseAndRecordTypeNode(token);\n   }\n \n   /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_642_642",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f22..2e84912cc 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1532,11 +1532,20 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 // compute contribution to norm squared from i > nn-2.\n                 final int np = nn - 2 * pingPong;\n                 double b1 = work[np - 2];\n+// start of generated patch\n+double b2=work[np-6];\n+ final double gam=dN2;\n+if(b2>0.0&&b2>b2*b1/(1+b2*b2)){\n+return ;\n+}\n+// end of generated patch\n+/* start of original code\n                 double b2 = work[np - 6];\n                 final double gam = dN2;\n                 if (work[np - 8] > b2 || work[np - 4] > b1) {\n                     return;\n                 }\n+ end of original code*/\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1536,3 +1536,3 @@\n                 final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (true) {\n                     return;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_11_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f..31c8133 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1540,8 +1540,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n+if (end - start > 2&&!(end - start>=(double)0.0)) {                    b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                         if (b2 == 0.0) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_6_5",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-07-31 06:16:03.738128873 -0400\n+++ /tmp/Arja_Defects4J_Math_81/patches_tja6/Patch_5/patched/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-07-31 06:24:21.638119105 -0400\n@@ -1525,8 +1525,6 @@\n                 }\n             } else if (dMin == dN2) {\n \n-                // case 5.\n-                tType = -5;\n                 double s = 0.25 * dMin;\n \n                 // compute contribution to norm squared from i > nn-2.\n@@ -1541,7 +1539,6 @@\n \n                 // approximate contribution to norm squared from i < nn-2.\n                 if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                         if (b2 == 0.0) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_108_32",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f..1bb5637 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1530,7 +1530,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double s = 0.25 * dMin;\n \n                 // compute contribution to norm squared from i > nn-2.\n-                final int np = nn - 2 * pingPong;\n+                final int np = nn - 2 * start;\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n                 final double gam = dN2;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_3_3",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n+++ /tmp/jMutRepair_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n@@ -1534,7 +1534,7 @@\n \t\t\t\t\t\tdouble b1 = work[(np - 2)];\n \t\t\t\t\t\tdouble b2 = work[(np - 6)];\n \t\t\t\t\t\tfinal double gam = dN2;\n-\t\t\t\t\t\tif (((work[(np - 8)]) > b2) || ((work[(np - 4)]) > b1)) {\n+\t\t\t\t\t\tif (((this.work[(np - 8)]) != b2) || ((this.work[(np - 4)]) > b1)) {\n \t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tdouble a2 = ((work[(np - 8)]) / b2) * (1 + ((work[(np - 4)]) / b1));\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_16_12",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n+++ /tmp/jGenProg_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpljava\n@@ -1540,25 +1540,25 @@\n \t\t\t\t\t\tdouble a2 = ((work[(np - 8)]) / b2) * (1 + ((work[(np - 4)]) / b1));\n \n \n-\t\t\t\t\t\tif ((end - start) > 2) {\n-\t\t\t\t\t\t\tb2 = (work[(nn - 13)]) / (work[(nn - 15)]);\n-\t\t\t\t\t\t\ta2 = a2 + b2;\n-\t\t\t\t\t\t\tfor (int i4 = nn - 17; i4 >= (((4 * start) + 2) + (pingPong)); i4 -= 4) {\n-\t\t\t\t\t\t\t\tif (b2 == 0.0) {\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tb1 = b2;\n-\t\t\t\t\t\t\t\tif ((work[i4]) > (work[(i4 - 2)])) {\n-\t\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tb2 = b2 * ((work[i4]) / (work[(i4 - 2)]));\n-\t\t\t\t\t\t\t\ta2 = a2 + b2;\n-\t\t\t\t\t\t\t\tif (((100 * (java.lang.Math.max(b2, b1))) < a2) || (cnst1 < a2)) {\n-\t\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\ta2 = cnst3 * a2;\n-\t\t\t\t\t\t}\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n \n \t\t\t\t\t\tif (a2 < cnst1) {\n \t\t\t\t\t\t\ttau = (gam * (1 - (java.lang.Math.sqrt(a2)))) / (1 + a2);\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_19_8",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f..c764dd0 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1534,7 +1534,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n                 final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (work[np - 8] <= b2 || work[np - 4] > b1) {\n                     return;\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1479,3 +1479,5 @@\n                         gam = dN;\n-                        a2 = 0.0;\n+                        if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) {\n+                            a2 = 0.0;\n+                        }\n                         if (work[nn - 5]  >  work[nn - 7]) {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_19_8",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f..c764dd0 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1534,7 +1534,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n                 final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (work[np - 8] <= b2 || work[np - 4] > b1) {\n                     return;\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_75_45",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 2d0d72f..40765b9 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1530,7 +1530,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double s = 0.25 * dMin;\n \n                 // compute contribution to norm squared from i > nn-2.\n-                final int np = nn - 2 * pingPong;\n+                final int np = nn - 2 * this.tType;\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n                 final double gam = dN2;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_2_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-03 00:00:55.331009939 -0400\n+++ /tmp/RSRepair_Defects4J_Math_81/patches_73am/Patch_1/patched/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-03 00:10:00.516782187 -0400\n@@ -1533,7 +1533,8 @@\n                 final int np = nn - 2 * pingPong;\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n-                final double gam = dN2;\n+                b2 = work[nn - 5] / work[nn - 7];\n+\t\t\t\tfinal double gam = dN2;\n                 if (work[np - 8] > b2 || work[np - 4] > b1) {\n                     return;\n                 }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_1_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-01 08:56:51.073394425 -0400\n+++ /tmp/GenProg_Defects4J_Math_81/patches_dbia/Patch_1/patched/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2019-08-01 09:03:31.602617726 -0400\n@@ -1539,27 +1539,6 @@\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n-                // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n-                    a2 = a2 + b2;\n-                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n-                        if (b2 == 0.0) {\n-                            break;\n-                        }\n-                        b1 = b2;\n-                        if (work[i4]  >  work[i4 - 2]) {\n-                            return;\n-                        }\n-                        b2 = b2 * (work[i4] / work[i4 - 2]);\n-                        a2 = a2 + b2;\n-                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n-                            break;\n-                        }\n-                    }\n-                    a2 = cnst3 * a2;\n-                }\n-\n                 if (a2 < cnst1) {\n                     tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                 } else {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 46,
    "bugId": 304,
    "name": "Patch_3_3",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2018-12-01 16:40:19.601381786 -0500\n+++ /tmp/Kali_Defects4J_Math_81/patches_jirz/Patch_1/patched/tmp/Kali_Defects4J_Math_81/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2018-12-01 16:41:41.081385555 -0500\n@@ -1534,7 +1534,7 @@\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n                 final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (true) {\n                     return;\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 47,
    "bugId": 201,
    "name": "Patch_8416_8416",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang/ClassUtils.java b/src/java/org/apache/commons/lang/ClassUtils.java\nindex d5de42b2..32b58879 100644\n--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n@@ -166,10 +166,18 @@ public class ClassUtils {\n      * @return the class name without the package name or an empty string\n      */\n     public static String getShortClassName(Class<?> cls) {\n+// start of generated patch\n+if(cls==null){\n+return StringUtils.EMPTY;\n+}\n+return getShortCanonicalName(cls.getName());\n+// end of generated patch\n+/* start of original code\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n         return getShortClassName(cls.getName());\n+ end of original code*/\n     }\n \n     /**\n@@ -226,10 +234,18 @@ public class ClassUtils {\n      * @return the package name or an empty string\n      */\n     public static String getPackageName(Class<?> cls) {\n+// start of generated patch\n+if(cls==null){\n+return StringUtils.EMPTY;\n+}\n+return getPackageCanonicalName(cls.getName());\n+// end of generated patch\n+/* start of original code\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n         return getPackageName(cls.getName());\n+ end of original code*/\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 47,
    "bugId": 201,
    "name": "Patch_223_61",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/ClassUtils.java b/src/java/org/apache/commons/lang/ClassUtils.java\nindex d5de42b..b1ba7d9 100644\n--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n@@ -229,7 +229,7 @@ public class ClassUtils {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n-        return getPackageName(cls.getName());\n+        return getPackageCanonicalName(cls.getName());\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 47,
    "bugId": 201,
    "name": "Patch_2305_990",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/ClassUtils.java b/src/java/org/apache/commons/lang/ClassUtils.java\nindex d5de42b..00ff1c4 100644\n--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n@@ -169,7 +169,7 @@ public class ClassUtils {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n-        return getShortClassName(cls.getName());\n+        return getShortCanonicalName(cls.getName());\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 47,
    "bugId": 201,
    "name": "Patch_2958_1870",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/ClassUtils.java b/src/java/org/apache/commons/lang/ClassUtils.java\nindex d5de42b..00ff1c4 100644\n--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n@@ -169,7 +169,7 @@ public class ClassUtils {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n-        return getShortClassName(cls.getName());\n+        return getShortCanonicalName(cls.getName());\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 47,
    "bugId": 201,
    "name": "Patch_289_206",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/ClassUtils.java b/src/java/org/apache/commons/lang/ClassUtils.java\nindex d5de42b..b1ba7d9 100644\n--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n@@ -229,7 +229,7 @@ public class ClassUtils {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n-        return getPackageName(cls.getName());\n+        return getPackageCanonicalName(cls.getName());\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 48,
    "bugId": 308,
    "name": "Patch_1320_1320",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 46368dc9f..2f417f819 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -1621,12 +1621,22 @@ public final class MathUtils {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n+// start of generated patch\n+double sum=0;\n+for(int i=0;i<p1.length;i++){\n+ final double dp=p1[i]-p2[i];\n+sum+=dp*dp;\n+}\n+return Math.sqrt(sum);\n+// end of generated patch\n+/* start of original code\n       int sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n           final int dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n+ end of original code*/\n     }\n \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 48,
    "bugId": 308,
    "name": "Patch_357_100",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 46368dc..ad77a56 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -1621,9 +1621,9 @@ public final class MathUtils {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n+      double sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+          final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 48,
    "bugId": 308,
    "name": "Patch_293_124",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 46368dc..ad77a56 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -1621,9 +1621,9 @@ public final class MathUtils {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n+      double sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+          final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 49,
    "bugId": 14,
    "name": "Patch_38_38",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/data/DefaultKeyedValues.java b/source/org/jfree/data/DefaultKeyedValues.java\nindex 707eb0a..bb214d1 100644\n--- a/source/org/jfree/data/DefaultKeyedValues.java\n+++ b/source/org/jfree/data/DefaultKeyedValues.java\n@@ -315,10 +315,17 @@ public class DefaultKeyedValues implements KeyedValues,\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n+// start of generated patch\n+if(index<=this.keys.size()){\n+rebuildIndex();\n+}\n+// end of generated patch\n+/* start of original code\n         if (index < this.keys.size()) {\n         rebuildIndex();\n         }\n+ end of original code*/\n     }\n \n     /**\n      * Removes a value from the collection.",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 49,
    "bugId": 14,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/source/org/jfree/data/category/DefaultCategoryDataset.java\n+++ b/source/org/jfree/data/category/DefaultCategoryDataset.java\n@@ -349,3 +349,5 @@\n     public void removeColumn(Comparable columnKey) {\n-        this.data.removeColumn(columnKey);\n+        if (false) {\n+            this.data.removeColumn(columnKey);\n+        }\n         fireDatasetChanged();\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\nindex ab65ba3..ed3acea 100644\n--- a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n@@ -204,14 +204,23 @@ public class StatisticalBarRenderer extends BarRenderer\n         StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\n \n         PlotOrientation orientation = plot.getOrientation();\n+// start of generated patch\n+if(orientation==PlotOrientation.VERTICAL){\n+drawHorizontalItem(g2,state,dataArea,plot,domainAxis,rangeAxis,statData,row,column);\n+}else if(orientation==PlotOrientation.VERTICAL){\n+drawVerticalItem(g2,state,dataArea,plot,domainAxis,rangeAxis,statData,row,column);\n+}\n+// end of generated patch\n+/* start of original code\n         if (orientation == PlotOrientation.HORIZONTAL) {\n             drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n                     rangeAxis, statData, row, column);\n         }\n         else if (orientation == PlotOrientation.VERTICAL) {\n             drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n                     statData, row, column);\n         }\n+ end of original code*/\n     }\n                 \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n@@ -206,10 +206,12 @@\n         PlotOrientation orientation = plot.getOrientation();\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n+        if (false) {\n+            if (orientation == PlotOrientation.HORIZONTAL) {\n+                drawHorizontalItem(g2, state, dataArea, plot, domainAxis,\n+                rangeAxis, statData, row, column);\n+            }\n+            else if (orientation == PlotOrientation.VERTICAL) {\n+                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis,\n+                statData, row, column);\n+            }\n         }\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n     }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_4_3",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_25/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\t2019-07-19 18:01:52.145770682 -0400\n+++ /tmp/Arja_Defects4J_Chart_25/patches_bz2o/Patch_3/patched/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\t2019-07-19 18:12:04.969769293 -0400\n@@ -237,7 +237,12 @@\n                                       int row,\n                                       int column) {\n                                      \n-        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n+        if (this.errorIndicatorPaint != null) {\n+\t\t\t\t\t\t\t\t\t\t\tg2.setPaint(this.errorIndicatorPaint);\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\tg2.setPaint(getItemPaint(row, column));\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\tRectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n         \n         // BAR Y\n         double rectY = domainAxis.getCategoryStart(column, getColumnCount(), \n@@ -270,26 +275,26 @@\n             if (value <= lclip) {\n                 value = lclip;\n             }\n-        }\n-        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n-            if (value >= uclip) {\n-                value = uclip;\n-            }\n-            else {\n-                if (value <= lclip) {\n-                    value = lclip;\n-                }\n-            }\n-        }\n-        else { // cases 9, 10, 11 and 12\n-            if (value <= lclip) {\n-                return; // bar is not visible\n-            }\n-            base = getLowerClip();\n-            if (value >= uclip) {\n-               value = uclip;\n-            }\n-        }\n+        } else {\n+\t\t\trectY = rectY + row * state.getBarWidth();\n+\t\t\tif (lclip <= 0.0) {\n+\t\t\t\tif (value >= uclip) {\n+\t\t\t\t\tvalue = uclip;\n+\t\t\t\t} else {\n+\t\t\t\t\tif (value <= lclip) {\n+\t\t\t\t\t\tvalue = lclip;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (value <= lclip) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tbase = getLowerClip();\n+\t\t\t\tif (value >= uclip) {\n+\t\t\t\t\tvalue = uclip;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n         RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n         double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n\n\n--- /tmp/Arja_Defects4J_Chart_25/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\t2019-07-19 18:01:47.429770692 -0400\n+++ /tmp/Arja_Defects4J_Chart_25/patches_bz2o/Patch_3/patched/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\t2019-07-19 18:12:04.977769293 -0400\n@@ -108,7 +108,6 @@\n         MeanAndStandardDeviation masd \n             = (MeanAndStandardDeviation) this.data.getObject(row, column);\n         if (masd != null) {\n-            result = masd.getMean();\n         }\n         return result;\n     }\n@@ -169,9 +168,7 @@\n         Number result = null;\n         MeanAndStandardDeviation masd \n             = (MeanAndStandardDeviation) this.data.getObject(row, column);\n-        if (masd != null) {\n-            result = masd.getStandardDeviation();\n-        }\n+        result = masd.getStandardDeviation();\n         return result;\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_18_12",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\nindex ab65ba3..a544330 100644\n--- a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n@@ -170,49 +170,7 @@ public class StatisticalBarRenderer extends BarRenderer\n         notifyListeners(new RendererChangeEvent(this));\n     }\n     \n-    /**\n-     * Draws the bar with its standard deviation line range for a single \n-     * (series, category) data item.\n-     *\n-     * @param g2  the graphics device.\n-     * @param state  the renderer state.\n-     * @param dataArea  the data area.\n-     * @param plot  the plot.\n-     * @param domainAxis  the domain axis.\n-     * @param rangeAxis  the range axis.\n-     * @param data  the data.\n-     * @param row  the row index (zero-based).\n-     * @param column  the column index (zero-based).\n-     * @param pass  the pass index.\n-     */\n-    public void drawItem(Graphics2D g2,\n-                         CategoryItemRendererState state,\n-                         Rectangle2D dataArea,\n-                         CategoryPlot plot,\n-                         CategoryAxis domainAxis,\n-                         ValueAxis rangeAxis,\n-                         CategoryDataset data,\n-                         int row,\n-                         int column,\n-                         int pass) {\n-\n-        // defensive check\n-        if (!(data instanceof StatisticalCategoryDataset)) {\n-            throw new IllegalArgumentException(\n-                \"Requires StatisticalCategoryDataset.\");\n-        }\n-        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\n-\n-        PlotOrientation orientation = plot.getOrientation();\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n-        }\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n-    }\n+    \n                 \n     /**\n      * Draws an item for a plot with a horizontal orientation.\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_8_4",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Chart_25/source/org/jfree/data/statistics/DefaultStatisticalCategoryDatasetjava\n+++ /tmp/jMutRepair_Defects4J_Chart_25/source/org/jfree/data/statistics/DefaultStatisticalCategoryDatasetjava\n@@ -107,7 +107,7 @@\n \t\tjava.lang.Number result = null;\n \t\torg.jfree.data.statistics.MeanAndStandardDeviation masd = \n \t\t((org.jfree.data.statistics.MeanAndStandardDeviation) (this.data.getObject(row, column)));\n-\t\tif (masd != null) {\n+\t\tif (masd == null) {\n \t\t\tresult = masd.getMean();\n \t\t}\n \t\treturn result;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_6_6",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Chart_25/source/org/jfree/chart/renderer/category/StatisticalBarRendererjava\n+++ /tmp/jKali_Defects4J_Chart_25/source/org/jfree/chart/renderer/category/StatisticalBarRendererjava\n@@ -204,14 +204,14 @@\n \t\torg.jfree.data.statistics.StatisticalCategoryDataset statData = ((org.jfree.data.statistics.StatisticalCategoryDataset) (data));\n \n \t\torg.jfree.chart.plot.PlotOrientation orientation = plot.getOrientation();\n-\t\tif (orientation == (org.jfree.chart.plot.PlotOrientation.HORIZONTAL)) {\n-\t\t\tdrawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-\t\t\trangeAxis, statData, row, column);\n-\t\t}else\n-\t\t\tif (orientation == (org.jfree.chart.plot.PlotOrientation.VERTICAL)) {\n-\t\t\t\tdrawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-\t\t\t\tstatData, row, column);\n-\t\t\t}\n+\n+\n+\n+\n+\n+\n+\n+\n \t}\n \n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_5_3",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Chart_25/source/org/jfree/chart/renderer/category/StatisticalBarRendererjava\n+++ /tmp/jGenProg_Defects4J_Chart_25/source/org/jfree/chart/renderer/category/StatisticalBarRendererjava\n@@ -204,14 +204,14 @@\n \t\torg.jfree.data.statistics.StatisticalCategoryDataset statData = ((org.jfree.data.statistics.StatisticalCategoryDataset) (data));\n \n \t\torg.jfree.chart.plot.PlotOrientation orientation = plot.getOrientation();\n-\t\tif (orientation == (org.jfree.chart.plot.PlotOrientation.HORIZONTAL)) {\n-\t\t\tdrawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-\t\t\trangeAxis, statData, row, column);\n-\t\t}else\n-\t\t\tif (orientation == (org.jfree.chart.plot.PlotOrientation.VERTICAL)) {\n-\t\t\t\tdrawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-\t\t\t\tstatData, row, column);\n-\t\t\t}\n+\n+\n+\n+\n+\n+\n+\n+\n \t}\n \n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_76_13",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java b/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\nindex 7e408a3..ff12062 100644\n--- a/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\n+++ b/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\n@@ -106,7 +106,7 @@ public class DefaultStatisticalCategoryDataset extends AbstractDataset\n     public Number getMeanValue(int row, int column) {\n         Number result = null;\n         MeanAndStandardDeviation masd \n-            = (MeanAndStandardDeviation) this.data.getObject(row, column);\n+            = (MeanAndStandardDeviation) this.data.getObject(this.minimumRangeValue, column);\n         if (masd != null) {\n             result = masd.getMean();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n@@ -206,10 +206,12 @@\n         PlotOrientation orientation = plot.getOrientation();\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n+        if (3 == 0) {\n+            if (orientation == PlotOrientation.HORIZONTAL) {\n+                drawHorizontalItem(g2, state, dataArea, plot, domainAxis,\n+                rangeAxis, statData, row, column);\n+            }\n+            else if (orientation == PlotOrientation.VERTICAL) {\n+                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis,\n+                statData, row, column);\n+            }\n         }\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n     }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_76_13",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java b/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\nindex 7e408a3..ff12062 100644\n--- a/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\n+++ b/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\n@@ -106,7 +106,7 @@ public class DefaultStatisticalCategoryDataset extends AbstractDataset\n     public Number getMeanValue(int row, int column) {\n         Number result = null;\n         MeanAndStandardDeviation masd \n-            = (MeanAndStandardDeviation) this.data.getObject(row, column);\n+            = (MeanAndStandardDeviation) this.data.getObject(this.minimumRangeValue, column);\n         if (masd != null) {\n             result = masd.getMean();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_12_9",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\nindex ab65ba3..a544330 100644\n--- a/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\n@@ -170,49 +170,7 @@ public class StatisticalBarRenderer extends BarRenderer\n         notifyListeners(new RendererChangeEvent(this));\n     }\n     \n-    /**\n-     * Draws the bar with its standard deviation line range for a single \n-     * (series, category) data item.\n-     *\n-     * @param g2  the graphics device.\n-     * @param state  the renderer state.\n-     * @param dataArea  the data area.\n-     * @param plot  the plot.\n-     * @param domainAxis  the domain axis.\n-     * @param rangeAxis  the range axis.\n-     * @param data  the data.\n-     * @param row  the row index (zero-based).\n-     * @param column  the column index (zero-based).\n-     * @param pass  the pass index.\n-     */\n-    public void drawItem(Graphics2D g2,\n-                         CategoryItemRendererState state,\n-                         Rectangle2D dataArea,\n-                         CategoryPlot plot,\n-                         CategoryAxis domainAxis,\n-                         ValueAxis rangeAxis,\n-                         CategoryDataset data,\n-                         int row,\n-                         int column,\n-                         int pass) {\n-\n-        // defensive check\n-        if (!(data instanceof StatisticalCategoryDataset)) {\n-            throw new IllegalArgumentException(\n-                \"Requires StatisticalCategoryDataset.\");\n-        }\n-        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\n-\n-        PlotOrientation orientation = plot.getOrientation();\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n-        }\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n-    }\n+    \n                 \n     /**\n      * Draws an item for a plot with a horizontal orientation.",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_44_6",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Chart_25/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\t2019-07-30 13:08:03.632585687 -0400\n+++ /tmp/RSRepair_Defects4J_Chart_25/patches_f34f/Patch_6/patched/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\t2019-07-30 13:15:42.921814008 -0400\n@@ -107,9 +107,6 @@\n         Number result = null;\n         MeanAndStandardDeviation masd \n             = (MeanAndStandardDeviation) this.data.getObject(row, column);\n-        if (masd != null) {\n-            result = masd.getMean();\n-        }\n         return result;\n     }\n \n\n\n--- /tmp/RSRepair_Defects4J_Chart_25/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\t2019-07-30 13:08:09.364700860 -0400\n+++ /tmp/RSRepair_Defects4J_Chart_25/patches_f34f/Patch_6/patched/org/jfree/chart/renderer/category/StatisticalBarRenderer.java\t2019-07-30 13:15:43.137818349 -0400\n@@ -251,7 +251,8 @@\n             rectY = rectY + row * (state.getBarWidth() + seriesGap);\n         }\n         else {\n-            rectY = rectY + row * state.getBarWidth();\n+            RectangleEdge rangeAxisLocation = plot.getRangeAxisEdge();\n+\t\t\trectY = rectY + row * state.getBarWidth();\n         }\n \n         // BAR X\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_8_2",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Chart_25/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\t2019-07-24 02:14:37.020416696 -0400\n+++ /tmp/GenProg_Defects4J_Chart_25/patches_8aax/Patch_2/patched/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\t2019-07-24 02:18:25.257381239 -0400\n@@ -107,9 +107,6 @@\n         Number result = null;\n         MeanAndStandardDeviation masd \n             = (MeanAndStandardDeviation) this.data.getObject(row, column);\n-        if (masd != null) {\n-            result = masd.getMean();\n-        }\n         return result;\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 50,
    "bugId": 24,
    "name": "Patch_6_6",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Chart_25/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\t2018-12-01 18:44:07.845782445 -0500\n+++ /tmp/Kali_Defects4J_Chart_25/patches_d9xc/Patch_8/patched/tmp/Kali_Defects4J_Chart_25/source/org/jfree/data/statistics/DefaultStatisticalCategoryDataset.java\t2018-12-01 18:45:41.289786767 -0500\n@@ -107,7 +107,7 @@\n         Number result = null;\n         MeanAndStandardDeviation masd \n             = (MeanAndStandardDeviation) this.data.getObject(row, column);\n-        if (masd != null) {\n+        if (false) {\n             result = masd.getMean();\n         }\n         return result;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 51,
    "bugId": 72,
    "name": "Patch_21_21",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nindex 7289803e..c4ff612d 100755\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -139,6 +139,19 @@ class RecordType extends PrototypeObjectType {\n \n   @Override\n   public JSType getLeastSupertype(JSType that) {\n+// start of generated patch\n+if(!that.isRecordType()){\n+return super.getLeastSupertype(that);\n+}\n+RecordTypeBuilder builder=new RecordTypeBuilder(registry);\n+for(String property : properties.keySet()){\n+if(that.toMaybeRecordType().hasProperty(property)&&that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(getPropertyType(property))){\n+builder.addProperty(property,getPropertyType(property),getPropertyNode(property));\n+}\n+}\n+return getLeastSupertype(this,that);\n+// end of generated patch\n+/* start of original code\n     if (!that.isRecordType()) {\n       return super.getLeastSupertype(that);\n     }\n@@ -152,6 +165,7 @@ class RecordType extends PrototypeObjectType {\n       }\n     }\n     return builder.build();\n+ end of original code*/\n   }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 51,
    "bugId": 72,
    "name": "Patch_1110_1110",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_46/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2019-08-11 20:16:31.320250775 -0400\n+++ /tmp/Arja_Defects4J_Closure_46/patches_euvt/Patch_1110/patched/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2019-08-11 20:46:57.186951511 -0400\n@@ -380,10 +380,6 @@\n         sb.append(getPropertyType(property).toString());\n \n         ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n       }\n \n       sb.append(\"}\");\n\n\n--- /tmp/Arja_Defects4J_Closure_46/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\t2019-08-11 20:16:31.320250775 -0400\n+++ /tmp/Arja_Defects4J_Closure_46/patches_euvt/Patch_1110/patched/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\t2019-08-11 20:46:57.194951499 -0400\n@@ -83,7 +83,6 @@\n   public JSType build() {\n      // If we have an empty record, simply return the object type.\n     if (isEmpty) {\n-       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n     }\n \n     return registry.createRecordType(Collections.unmodifiableMap(properties));\n\n\n--- /tmp/Arja_Defects4J_Closure_46/src/com/google/javascript/rhino/jstype/RecordType.java\t2019-08-11 20:16:33.344207874 -0400\n+++ /tmp/Arja_Defects4J_Closure_46/patches_euvt/Patch_1110/patched/com/google/javascript/rhino/jstype/RecordType.java\t2019-08-11 20:46:57.202951487 -0400\n@@ -107,7 +107,7 @@\n     Set<String> keySet = properties.keySet();\n     Map<String, JSType> otherProps = otherRecord.properties;\n     if (!otherProps.keySet().equals(keySet)) {\n-      return false;\n+      return true;\n     }\n     for (String key : keySet) {\n       if (!otherProps.get(key).isEquivalentTo(properties.get(key))) {\n@@ -172,13 +172,6 @@\n             getPropertyNode(property));\n       }\n \n-      for (String property : thatRecord.properties.keySet()) {\n-        if (!hasProperty(property)) {\n-          builder.addProperty(property, thatRecord.getPropertyType(property),\n-              thatRecord.getPropertyNode(property));\n-        }\n-      }\n-\n       return builder.build();\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 51,
    "bugId": 72,
    "name": "Patch_11_4",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nold mode 100755\nnew mode 100644\nindex 7289803..9c61b02\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -137,22 +137,7 @@ class RecordType extends PrototypeObjectType {\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+  \n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 51,
    "bugId": 72,
    "name": "Patch_5_5",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Closure_46/src/com/google/javascript/rhino/jstype/RecordTypejava\n+++ /tmp/jKali_Defects4J_Closure_46/src/com/google/javascript/rhino/jstype/RecordTypejava\n@@ -139,7 +139,7 @@\n \n \t@java.lang.Override\n \tpublic com.google.javascript.rhino.jstype.JSType getLeastSupertype(com.google.javascript.rhino.jstype.JSType that) {\n-\t\tif (!(that.isRecordType())) {\n+\t\tif (true) {\n \t\t\treturn super.getLeastSupertype(that);\n \t\t}\n \t\tcom.google.javascript.rhino.jstype.RecordTypeBuilder builder = new com.google.javascript.rhino.jstype.RecordTypeBuilder(registry);\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 51,
    "bugId": 72,
    "name": "Patch_223_30",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/rhino/jstype/RecordType.java b/src/com/google/javascript/rhino/jstype/RecordType.java\nold mode 100755\nnew mode 100644\nindex 7289803..5cc8b64\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n@@ -139,7 +139,7 @@ class RecordType extends PrototypeObjectType {\n \n   @Override\n   public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n+    if (!that.isNumberObjectType()) {\n       return super.getLeastSupertype(that);\n     }\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 51,
    "bugId": 72,
    "name": "Patch_3_3",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_46/src/com/google/javascript/rhino/jstype/RecordType.java\t2018-12-01 20:09:32.367087967 -0500\n+++ /tmp/Kali_Defects4J_Closure_46/patches_6jfz/Patch_3/patched/tmp/Kali_Defects4J_Closure_46/src/com/google/javascript/rhino/jstype/RecordType.java\t2018-12-01 20:13:57.468306249 -0500\n@@ -139,7 +139,7 @@\n \n   @Override\n   public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n+    if (true) {\n       return super.getLeastSupertype(that);\n     }\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 52,
    "bugId": 150,
    "name": "Patch_32_32",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..817547ad 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,10 +138,21 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n+// start of generated patch\n+if(!n.isName()){\n+return ;\n+}\n+if(NodeUtil.hasFinally(n)){\n+Node finallyBlock=n.getLastChild();\n+tryMinimizeExits(finallyBlock,exitType,labelName);\n+}\n+// end of generated patch\n+/* start of original code\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n+ end of original code*/\n     }\n \n     // Just a 'label'.",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 52,
    "bugId": 150,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-12 04:31:48.456331233 -0400\n+++ /tmp/Arja_Defects4J_Closure_126/patches_8j47/Patch_1/patched/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-12 04:53:19.985935082 -0400\n@@ -134,14 +134,6 @@\n         Node catchCodeBlock = catchNode.getLastChild();\n         tryMinimizeExits(catchCodeBlock, exitType, labelName);\n       }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n     }\n \n     // Just a 'label'.\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 52,
    "bugId": 150,
    "name": "Patch_4_3",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f17..70e3b1d 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -140,7 +140,7 @@ class MinimizeExitPoints\n        */\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+        tryMinimizeExits(allCatchNodes, exitType, labelName);\n       }\n     }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 52,
    "bugId": 150,
    "name": "Patch_2_2",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPointsjava\n+++ /tmp/jMutRepair_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPointsjava\n@@ -138,7 +138,7 @@\n \n \n \n-\t\t\tif (com.google.javascript.jscomp.NodeUtil.hasFinally(n)) {\n+\t\t\tif (!(com.google.javascript.jscomp.NodeUtil.hasFinally(n))) {\n \t\t\t\tcom.google.javascript.rhino.Node finallyBlock = n.getLastChild();\n \t\t\t\ttryMinimizeExits(finallyBlock, exitType, labelName);\n \t\t\t}\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 52,
    "bugId": 150,
    "name": "Patch_7_6",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPointsjava\n+++ /tmp/jKali_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPointsjava\n@@ -138,7 +138,7 @@\n \n \n \n-\t\t\tif (com.google.javascript.jscomp.NodeUtil.hasFinally(n)) {\n+\t\t\tif (false) {\n \t\t\t\tcom.google.javascript.rhino.Node finallyBlock = n.getLastChild();\n \t\t\t\ttryMinimizeExits(finallyBlock, exitType, labelName);\n \t\t\t}\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 52,
    "bugId": 150,
    "name": "Patch_25_3",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f17..1d76a19 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -139,7 +139,7 @@ class MinimizeExitPoints\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n       if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n+        Node finallyBlock = n.getFirstChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 52,
    "bugId": 150,
    "name": "Patch_6_3",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f17..83acd41 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -140,7 +140,7 @@ class MinimizeExitPoints\n        */\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+        matchingExitNode(finallyBlock, exitType, labelName);\n       }\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 52,
    "bugId": 150,
    "name": "Patch_103_27",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-12 17:48:48.471049857 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_126/patches_qzki/Patch_27/patched/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-12 18:12:20.000163288 -0400\n@@ -134,14 +134,6 @@\n         Node catchCodeBlock = catchNode.getLastChild();\n         tryMinimizeExits(catchCodeBlock, exitType, labelName);\n       }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n     }\n \n     // Just a 'label'.\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 52,
    "bugId": 150,
    "name": "Patch_11_6",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-11 20:13:18.544183844 -0400\n+++ /tmp/GenProg_Defects4J_Closure_126/patches_wwr6/Patch_6/patched/com/google/javascript/jscomp/MinimizeExitPoints.java\t2019-08-11 20:35:48.846501480 -0400\n@@ -140,7 +140,6 @@\n        */\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n     }\n \n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 52,
    "bugId": 150,
    "name": "Patch_4_4",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2018-12-01 19:27:10.090013082 -0500\n+++ /tmp/Kali_Defects4J_Closure_126/patches_1em6/Patch_4/patched/tmp/Kali_Defects4J_Closure_126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2018-12-01 19:31:19.220744708 -0500\n@@ -138,7 +138,7 @@\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n+      if (false) {\n         Node finallyBlock = n.getLastChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 53,
    "bugId": 299,
    "name": "Patch_8_8",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d72883..4395d85e4 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,12 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n+// start of generated patch\n+return getPct((Comparable<?>)v);\n+// end of generated patch\n+/* start of original code\n         return getCumPct((Comparable<?>) v);\n+ end of original code*/\n     }\n \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 53,
    "bugId": 299,
    "name": "Patch_7_4",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d728..68c8bf2 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct((Comparable<?>) v);\n     }\n \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 53,
    "bugId": 299,
    "name": "Patch_7_4",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d728..68c8bf2 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct((Comparable<?>) v);\n     }\n \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 53,
    "bugId": 299,
    "name": "Patch_3_1",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d728..68c8bf2 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct((Comparable<?>) v);\n     }\n \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 54,
    "bugId": 130,
    "name": "Patch_1483_1483",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex 47dc5af9..47ddaa30 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1304,9 +1304,17 @@ public final class JsDocInfoParser {\n           builder.append(toString(token));\n \n           String line = stream.getRemainingJSDocLine();\n+// start of generated patch\n+line=trimEnd(line);\n+builder.append(line);\n+jsdocBuilder.recordDescription(line);\n+token=next();\n+// end of generated patch\n+/* start of original code\n           line = trimEnd(line);\n           builder.append(line);\n           token = next();\n+ end of original code*/\n       }\n     } while (true);\n   }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 55,
    "bugId": 133,
    "name": "Patch_1263_1263",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex 93b35475..58ed7dfa 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -849,6 +849,12 @@ public class CommandLineRunner extends\n       } catch (IOException e) {\n         throw new RuntimeException(\"Reading XTB file\", e);\n       }\n+} else // start of generated patch\n+if(options.messageBundle!=null){\n+options.messageBundle=new EmptyMessageBundle();\n+}\n+// end of generated patch\n+/* start of original code\n     } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n       // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n       // translations file, they might reasonably try to write their own\n@@ -860,6 +866,7 @@ public class CommandLineRunner extends\n       // because the user didn't really ask for i18n.\n       options.messageBundle = new EmptyMessageBundle();\n     }\n+ end of original code*/\n \n     return options;\n   }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 55,
    "bugId": 133,
    "name": "Patch_356_164",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex 93b3547..54f5f08 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -858,7 +858,7 @@ public class CommandLineRunner extends\n       // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n       // so we might as well inline it. But shut off the i18n warnings,\n       // because the user didn't really ask for i18n.\n-      options.messageBundle = new EmptyMessageBundle();\n+      \n     }\n \n     return options;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 56,
    "bugId": 189,
    "name": "Patch_91_91",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex fd03ab8f..1f8a5977 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -463,9 +463,17 @@ public class NumberUtils {\n             // a wrong value.\n             return null;\n         }\n+// start of generated patch\n+str=str.toLowerCase();\n+if(str.startsWith(\"0x\")||str.startsWith(\"-0x\")){\n+return createInteger(str);\n+}\n+// end of generated patch\n+/* start of original code\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n+ end of original code*/\n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 56,
    "bugId": 189,
    "name": "Patch_865_448",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex fd03ab8..fbc54c7 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -485,7 +485,7 @@ public class NumberUtils {\n             }\n             mant = str.substring(0, decPos);\n         } else {\n-            if (expPos > -1) {\n+            if (expPos < -1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 56,
    "bugId": 189,
    "name": "Patch_67_55",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Lang_27/src/main/java/org/apache/commons/lang3/math/NumberUtilsjava\n+++ /tmp/jMutRepair_Defects4J_Lang_27/src/main/java/org/apache/commons/lang3/math/NumberUtilsjava\n@@ -485,7 +485,7 @@\n \t\t\t}\n \t\t\tmant = str.substring(0, decPos);\n \t\t}else {\n-\t\t\tif (expPos > (-1)) {\n+\t\t\tif (expPos < (-1)) {\n \t\t\t\tmant = str.substring(0, expPos);\n \t\t\t}else {\n \t\t\t\tmant = str;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 56,
    "bugId": 189,
    "name": "Patch_59_43",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Lang_27/src/main/java/org/apache/commons/lang3/math/NumberUtilsjava\n+++ /tmp/jKali_Defects4J_Lang_27/src/main/java/org/apache/commons/lang3/math/NumberUtilsjava\n@@ -485,7 +485,7 @@\n \t\t\t}\n \t\t\tmant = str.substring(0, decPos);\n \t\t}else {\n-\t\t\tif (expPos > (-1)) {\n+\t\t\tif (false) {\n \t\t\t\tmant = str.substring(0, expPos);\n \t\t\t}else {\n \t\t\t\tmant = str;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 56,
    "bugId": 189,
    "name": "Patch_2940_1929",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Lang_27/src/main/java/org/apache/commons/lang3/math/NumberUtilsjava\n+++ /tmp/jGenProg_Defects4J_Lang_27/src/main/java/org/apache/commons/lang3/math/NumberUtilsjava\n@@ -486,9 +486,9 @@\n \t\t\tmant = str.substring(0, decPos);\n \t\t}else {\n \t\t\tif (expPos > (-1)) {\n-\t\t\t\tmant = str.substring(0, expPos);\n-\t\t\t}else {\n-\t\t\t\tmant = str;\n+\n+\n+\t\t\t\tmant = str;}else { \t\t\t\tmant = str;\n \t\t\t}\n \t\t\tdec = null;\n \t\t}\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 56,
    "bugId": 189,
    "name": "Patch_621_407",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex fd03ab8..b23bb45 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -486,7 +486,7 @@ public class NumberUtils {\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n-                mant = str.substring(0, expPos);\n+                mant = str.substring(0, INTEGER_ZERO);\n             } else {\n                 mant = str;\n             }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 56,
    "bugId": 189,
    "name": "Patch_1259_919",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex fd03ab8..091d3be 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -485,7 +485,7 @@ public class NumberUtils {\n             }\n             mant = str.substring(0, decPos);\n         } else {\n-            if (expPos > -1) {\n+            if (expPos<-1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 57,
    "bugId": 176,
    "name": "Patch_2548_2548",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 882358f2..6719f465 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -445,9 +445,17 @@ public class NumberUtils {\n         if (str == null) {\n             return null;\n         }\n+// start of generated patch\n+str=str.toLowerCase();\n+if(StringUtils.isBlank(str)){\n+throw new NumberFormatException(\"A blank string is not a valid number\");\n+}\n+// end of generated patch\n+/* start of original code\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n+ end of original code*/\n         if (str.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear ",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 57,
    "bugId": 176,
    "name": "Patch_102_82",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Lang_16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2019-07-22 15:25:27.526223489 -0400\n+++ /tmp/Arja_Defects4J_Lang_16/patches_phj5/Patch_82/patched/org/apache/commons/lang3/math/NumberUtils.java\t2019-07-22 15:34:02.707203269 -0400\n@@ -542,7 +542,7 @@\n                     }\n                     //$FALL-THROUGH$\n                 default :\n-                    throw new NumberFormatException(str + \" is not a valid number.\");\n+\t\t\t\treturn createInteger(str);\n \n             }\n         } else {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 57,
    "bugId": 176,
    "name": "Patch_3010_1624",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 882358f..97d0dab 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -487,7 +487,7 @@ public class NumberUtils {\n             }\n             dec = null;\n         }\n-        if (!Character.isDigit(lastChar) && lastChar != '.') {\n+        if ((!Character.isDigit(lastChar) && lastChar != '.') && (expPos < str.length() - 1)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 57,
    "bugId": 176,
    "name": "Patch_983_418",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Lang_16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2019-07-31 20:58:17.618669992 -0400\n+++ /tmp/RSRepair_Defects4J_Lang_16/patches_cukh/Patch_418/patched/org/apache/commons/lang3/math/NumberUtils.java\t2019-07-31 21:12:16.190456423 -0400\n@@ -542,7 +542,7 @@\n                     }\n                     //$FALL-THROUGH$\n                 default :\n-                    throw new NumberFormatException(str + \" is not a valid number.\");\n+\t\t\t\treturn createInteger(str);\n \n             }\n         } else {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 58,
    "bugId": 97,
    "name": "Patch_80_80",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex 26a56a7a..446f18c2 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1757,9 +1757,17 @@ public final class JsDocInfoParser {\n   private Node parseFunctionType(JsDocToken token) {\n     // NOTE(nicksantos): We're not implementing generics at the moment, so\n     // just throw out TypeParameters.\n+// start of generated patch\n+if(token!=JsDocToken.LP){\n+restoreLookAhead(token);\n+return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n+}\n+// end of generated patch\n+/* start of original code\n     if (token != JsDocToken.LP) {\n       return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n     }\n+ end of original code*/\n \n     Node functionType = newNode(Token.FUNCTION);\n     Node parameters = null;",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 58,
    "bugId": 97,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_68/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2019-08-11 21:54:31.310236574 -0400\n+++ /tmp/Arja_Defects4J_Closure_68/patches_6yhe/Patch_1/patched/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2019-08-11 22:14:05.218014930 -0400\n@@ -884,8 +884,7 @@\n         case EOF:\n           // discard any accumulated information\n           jsdocBuilder.build(null);\n-          parser.addParserWarning(\"msg.unexpected.eof\",\n-              stream.getLineno(), stream.getCharno());\n+          ;\n           checkExtendedTypes(extendedTypes);\n           return false;\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 58,
    "bugId": 97,
    "name": "Patch_17_17",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_68/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2018-12-01 20:00:49.402701210 -0500\n+++ /tmp/Kali_Defects4J_Closure_68/patches_9acd/Patch_3/patched/tmp/Kali_Defects4J_Closure_68/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2018-12-01 20:06:01.936002180 -0500\n@@ -882,8 +882,11 @@\n           return true;\n \n         case EOF:\n-          // discard any accumulated information\n-          jsdocBuilder.build(null);\n+          {\n+\t\t\tif (true)\n+\t\t\t\treturn true;\n+\t\t\tjsdocBuilder.build(null);\n+\t\t}\n           parser.addParserWarning(\"msg.unexpected.eof\",\n               stream.getLineno(), stream.getCharno());\n           checkExtendedTypes(extendedTypes);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 59,
    "bugId": 140,
    "name": "Patch_3_3",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 73d6a4b3..5630da25 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -727,9 +727,16 @@ class FunctionInjector {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n+// start of generated patch\n+if(cArg==null&&NodeUtil.canBeSideEffected(cArg)){\n+return CanInlineResult.NO;\n+}\n+// end of generated patch\n+/* start of original code\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n             return CanInlineResult.NO;\n           }\n+ end of original code*/\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 59,
    "bugId": 140,
    "name": "Patch_3_3",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-11 23:44:32.255259377 -0400\n+++ /tmp/Arja_Defects4J_Closure_115/patches_9qfg/Patch_3/patched/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-12 00:10:27.655111171 -0400\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 59,
    "bugId": 140,
    "name": "Patch_214_66",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 73d6a4b..ca16669 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -727,9 +727,7 @@ class FunctionInjector {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n+          \n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 59,
    "bugId": 140,
    "name": "Patch_232_166",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 73d6a4b..fe08fe5 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -727,7 +727,7 @@ class FunctionInjector {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+          if ((!isDirectCallNodeReplacementPossible(fnNode)) && NodeUtil.canBeSideEffected(cArg)) {\n             return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 59,
    "bugId": 140,
    "name": "Patch_704_253",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 73d6a4b..3e7308a 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -727,7 +727,7 @@ class FunctionInjector {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+          if ((hasSideEffects && NodeUtil.canBeSideEffected(cArg)) && (NodeUtil.mayHaveSideEffects(cArg, compiler))) {\n             return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 59,
    "bugId": 140,
    "name": "Patch_20_8",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-12 14:48:18.459957774 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_115/patches_v7z9/Patch_8/patched/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-12 15:14:07.311233805 -0400\n@@ -699,7 +699,7 @@\n       Preconditions.checkState(block.hasOneChild());\n       Node stmt = block.getFirstChild();\n       if (stmt.isReturn()) {\n-        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n+        int start = 0;\n       }\n     }\n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 59,
    "bugId": 140,
    "name": "Patch_139_77",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-11 17:55:20.438131483 -0400\n+++ /tmp/GenProg_Defects4J_Closure_115/patches_ts3d/Patch_77/patched/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-11 18:24:29.261553002 -0400\n@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 59,
    "bugId": 140,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 19:40:30.353190167 -0500\n+++ /tmp/Kali_Defects4J_Closure_115/patches_nxsz/Patch_2/patched/tmp/Kali_Defects4J_Closure_115/src/com/google/javascript/jscomp/FunctionInjector.java\t2018-12-01 19:47:28.231727638 -0500\n@@ -727,7 +727,7 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+          if (false) {\n             return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 60,
    "bugId": 210,
    "name": "Patch_1884_1884",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/FastDateFormat.java b/src/java/org/apache/commons/lang/time/FastDateFormat.java\nindex 8a26f283..d94c99f5 100644\n--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n@@ -293,9 +293,19 @@ public class FastDateFormat extends Format {\n                 locale = Locale.getDefault();\n             }\n             try {\n+// start of generated patch\n+if(locale!=null){\n+key=new Pair(key,locale);\n+}\n+SimpleDateFormat formatter=(SimpleDateFormat)DateFormat.getDateInstance(style,locale);\n+String pattern=formatter.toPattern();\n+format=getInstance(pattern,timeZone,locale);\n+// end of generated patch\n+/* start of original code\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                 String pattern = formatter.toPattern();\n                 format = getInstance(pattern, timeZone, locale);\n+ end of original code*/\n                 cDateInstanceCache.put(key, format);\n                 \n             } catch (ClassCastException ex) {\n@@ -472,10 +482,20 @@ public class FastDateFormat extends Format {\n                 locale = Locale.getDefault();\n             }\n             try {\n+// start of generated patch\n+if(locale!=null){\n+key=new Pair(key,locale);\n+}\n+SimpleDateFormat formatter=(SimpleDateFormat)DateFormat.getDateTimeInstance(dateStyle,timeStyle,locale);\n+String pattern=formatter.toPattern();\n+format=getInstance(pattern,timeZone,locale);\n+// end of generated patch\n+/* start of original code\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                         locale);\n                 String pattern = formatter.toPattern();\n                 format = getInstance(pattern, timeZone, locale);\n+ end of original code*/\n                 cDateTimeInstanceCache.put(key, format);\n \n             } catch (ClassCastException ex) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 61,
    "bugId": 47,
    "name": "Patch_4878_4878",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\nindex e2e33161..de285723 100644\n--- a/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\n@@ -208,6 +208,20 @@ public class ClosureReverseAbstractInterpreter\n     if (condition.isCall() && condition.getChildCount() == 2) {\n       Node callee = condition.getFirstChild();\n       Node param = condition.getLastChild();\n+// start of generated patch\n+if(param.isName()||param.isGetProp()){\n+JSType paramType=getTypeIfRefinable(param,blindScope);\n+Node left=callee.getFirstChild();\n+Node right=callee.getLastChild();\n+if(left.isName()&&\"goog\".equals(left.getString())){\n+Function<TypeRestriction,JSType> restricter=restricters.get(right.getString());\n+if(restricter!=null){\n+return restrictParameter(param,paramType,blindScope,restricter,outcome);\n+}\n+}\n+}\n+// end of generated patch\n+/* start of original code\n       if (callee.isGetProp() && param.isQualifiedName()) {\n         JSType paramType =  getTypeIfRefinable(param, blindScope);\n         Node left = callee.getFirstChild();\n@@ -222,6 +236,7 @@ public class ClosureReverseAbstractInterpreter\n           }\n         }\n       }\n+ end of original code*/\n     }\n     return nextPreciserScopeKnowingConditionOutcome(\n         condition, blindScope, outcome);",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 61,
    "bugId": 47,
    "name": "Patch_8_4",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c85..94a2a46 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -172,8 +172,7 @@ public abstract class ChainableReverseAbstractInterpreter\n         // \"this\" references aren't currently modeled in the CFG.\n \n       default:\n-        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n-            node.toStringTree());\n+        \n     }\n   }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 62,
    "bugId": 313,
    "name": "Patch_4565_4565",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 97f5eb9a2..44dc99d28 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -80,10 +80,18 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n             double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {\n                 double ratio = rhs / tableau.getEntry(i, col);\n+// start of generated patch\n+if(ratio<=minRatio){\n+minRatio=ratio;\n+minRatioPos=i;\n+}\n+// end of generated patch\n+/* start of original code\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n+ end of original code*/\n             }\n         }\n         return minRatioPos;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 62,
    "bugId": 313,
    "name": "Patch_257_146",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 3bcb17f..c6aee06 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n                     (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (tableau.getEntry(basicRow, i) == 1) {\n                          coefficients[i] = 0;\n                     }\n                 }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 62,
    "bugId": 313,
    "name": "Patch_60_56",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Math_88/src/java/org/apache/commons/math/optimization/linear/SimplexSolverjava\n+++ /tmp/jMutRepair_Defects4J_Math_88/src/java/org/apache/commons/math/optimization/linear/SimplexSolverjava\n@@ -80,7 +80,7 @@\n \t\t\tdouble rhs = tableau.getEntry(i, ((tableau.getWidth()) - 1));\n \t\t\tif ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon)) >= 0) {\n \t\t\t\tdouble ratio = rhs / (tableau.getEntry(i, col));\n-\t\t\t\tif (ratio < minRatio) {\n+\t\t\t\tif (ratio <= minRatio) {\n \t\t\t\t\tminRatio = ratio;\n \t\t\t\t\tminRatioPos = i;\n \t\t\t\t}\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 62,
    "bugId": 313,
    "name": "Patch_269_135",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 3bcb17f..c6aee06 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n                     (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (tableau.getEntry(basicRow, i) == 1) {\n                          coefficients[i] = 0;\n                     }\n                 }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 62,
    "bugId": 313,
    "name": "Patch_593_301",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 3bcb17f..a48c4eb 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n                     (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (j == i && (tableau.getEntry(basicRow, j) == 1)) {\n                          coefficients[i] = 0;\n                     }\n                 }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 63,
    "bugId": 229,
    "name": "Patch_78_78",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\nindex 5cb0e4382..d81653512 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n@@ -186,9 +186,16 @@ public class DiscreteDistribution<T> {\n \n         final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n \n+// start of generated patch\n+for(int i=sampleSize;i<sampleSize;i++){\n+out[i]=sample();\n+}\n+// end of generated patch\n+/* start of original code\n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n+ end of original code*/\n \n         return out;\n ",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 63,
    "bugId": 229,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n@@ -188,4 +188,6 @@\n \n-        for (int i = 0; i < sampleSize; i++) {\n-            out[i] = sample();\n+        if (false) {\n+            for (int i = 0; i < sampleSize; i++) {\n+                out[i] = sample();\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 63,
    "bugId": 229,
    "name": "Patch_5_4",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Math_8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistributionjava\n+++ /tmp/jKali_Defects4J_Math_8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistributionjava\n@@ -186,9 +186,9 @@\n \n \t\tfinal T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));\n \n-\t\tfor (int i = 0; i < sampleSize; i++) {\n-\t\t\tout[i] = sample();\n-\t\t}\n+\n+\n+\n \n \t\treturn out;\n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 63,
    "bugId": 229,
    "name": "Patch_9_5",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Math_8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistributionjava\n+++ /tmp/jGenProg_Defects4J_Math_8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistributionjava\n@@ -187,7 +187,7 @@\n \t\tfinal T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));\n \n \t\tfor (int i = 0; i < sampleSize; i++) {\n-\t\t\tout[i] = sample();\n+\n \t\t}\n \n \t\treturn out;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 63,
    "bugId": 229,
    "name": "Patch_41_6",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\nindex 5cb0e43..55d4ced 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n@@ -184,7 +184,7 @@ public class DiscreteDistribution<T> {\n                     sampleSize);\n         }\n \n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(1).getClass(), sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 63,
    "bugId": 229,
    "name": "Patch_47_16",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\nindex 5cb0e43..0422522 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n@@ -186,7 +186,7 @@ public class DiscreteDistribution<T> {\n \n         final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n \n-        for (int i = 0; i < sampleSize; i++) {\n+        for (int i = 0; i==sampleSize; i++) {\n             out[i] = sample();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 64,
    "bugId": 51,
    "name": "Patch_6288_6288",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex 13895f32..96d5eaa5 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -474,6 +474,17 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n     }\n \n     Node newRight;\n+// start of generated patch\n+if(areNodesEqualForInlining(left,right.getFirstChild())){\n+n.removeChild(right);\n+newRight=right.getLastChild();\n+}else if(NodeUtil.isCommutative(right.getType())&&areNodesEqualForInlining(left,right.getLastChild())){\n+newRight=right.getFirstChild();\n+}else {\n+return n;\n+}\n+// end of generated patch\n+/* start of original code\n     if (areNodesEqualForInlining(left, right.getFirstChild())) {\n       newRight = right.getLastChild();\n     } else if (NodeUtil.isCommutative(right.getType()) &&\n@@ -482,6 +493,7 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n     } else {\n       return n;\n     }\n+ end of original code*/\n \n     int newType = -1;\n     switch (right.getType()) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 64,
    "bugId": 51,
    "name": "Patch_31_25",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_26/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:14:43.266513735 -0500\n+++ /tmp/Kali_Defects4J_Closure_26/patches_xzdn/Patch_79/patched/tmp/Kali_Defects4J_Closure_26/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:19:39.791917840 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 65,
    "bugId": 223,
    "name": "Patch_45_45",
    "tool": "SimFix",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\nindex 127b9279..2a3109ab 100644\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -433,6 +433,16 @@ public class DurationFormatUtils {\n         end.add( field, -1 * difference );\n         int endValue = end.get(field);\n         int startValue = start.get(field);\n+// start of generated patch\n+if(endValue<field){\n+int newdiff=startValue-endValue;\n+end.add(field,newdiff);\n+return newdiff;\n+}else {\n+return 0;\n+}\n+// end of generated patch\n+/* start of original code\n         if (endValue < startValue) {\n             int newdiff = startValue - endValue;\n             end.add( field, newdiff );\n@@ -440,6 +450,7 @@ public class DurationFormatUtils {\n         } else {\n             return 0;\n         }\n+ end of original code*/\n     }\n \n     static final Object y = \"y\";",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 65,
    "bugId": 223,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -437,3 +437,5 @@\n             int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n+            if (false) {\n+                end.add( field, newdiff );\n+            }\n             return newdiff;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 65,
    "bugId": 223,
    "name": "Patch_22_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\nindex 127b927..a309572 100644\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -434,7 +434,7 @@ public class DurationFormatUtils {\n         int endValue = end.get(field);\n         int startValue = start.get(field);\n         if (endValue < startValue) {\n-            int newdiff = startValue - endValue;\n+            int newdiff = endValue - endValue;\n             end.add( field, newdiff );\n             return newdiff;\n         } else {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 65,
    "bugId": 223,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\nindex 127b927..ba1f5dd 100644\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -435,7 +435,7 @@ public class DurationFormatUtils {\n         int startValue = start.get(field);\n         if (endValue < startValue) {\n             int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n+            end.add( newdiff, newdiff );\n             return newdiff;\n         } else {\n             return 0;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 65,
    "bugId": 223,
    "name": "Patch_1_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\nindex 127b927..ba1f5dd 100644\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -435,7 +435,7 @@ public class DurationFormatUtils {\n         int startValue = start.get(field);\n         if (endValue < startValue) {\n             int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n+            end.add( newdiff, newdiff );\n             return newdiff;\n         } else {\n             return 0;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 65,
    "bugId": 223,
    "name": "Patch_28_21",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\nindex 127b927..5b458c6 100644\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n@@ -434,7 +434,7 @@ public class DurationFormatUtils {\n         int endValue = end.get(field);\n         int startValue = start.get(field);\n         if (endValue < startValue) {\n-            int newdiff = startValue - endValue;\n+            int newdiff = difference - endValue;\n             end.add( field, newdiff );\n             return newdiff;\n         } else {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 66,
    "bugId": 170,
    "name": "Patch_4_4",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java b/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\nindex 9b116599..e4b4cde2 100644\n--- a/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n@@ -136,12 +136,22 @@ public class EventListenerSupport<L> implements Serializable {\n      *         not an interface.\n      */\n     public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n+// start of generated patch\n+this();\n+Validate.notNull(listenerInterface,\"Listener interface cannot be null.\");\n+Validate.notNull(classLoader,\"ClassLoader cannot be null.\");\n+Validate.isTrue(listenerInterface.isInterface(),\"Class {0} is not an interface\",listenerInterface.getName());\n+this.prototypeArray=(L[])Array.newInstance(listenerInterface,0);\n+initializeTransientFields(listenerInterface,classLoader);\n+// end of generated patch\n+/* start of original code\n         this();\n         Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n         Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n         Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\n                 listenerInterface.getName());\n         initializeTransientFields(listenerInterface, classLoader);\n+ end of original code*/\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 67,
    "bugId": 168,
    "name": "Patch_2518_2518",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java b/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\nindex 9b116599..e4b4cde2 100644\n--- a/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n@@ -136,12 +136,22 @@ public class EventListenerSupport<L> implements Serializable {\n      *         not an interface.\n      */\n     public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n+// start of generated patch\n+this();\n+Validate.notNull(listenerInterface,\"Listener interface cannot be null.\");\n+Validate.notNull(classLoader,\"ClassLoader cannot be null.\");\n+Validate.isTrue(listenerInterface.isInterface(),\"Class {0} is not an interface\",listenerInterface.getName());\n+this.prototypeArray=(L[])Array.newInstance(listenerInterface,0);\n+initializeTransientFields(listenerInterface,classLoader);\n+// end of generated patch\n+/* start of original code\n         this();\n         Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n         Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n         Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\n                 listenerInterface.getName());\n         initializeTransientFields(listenerInterface, classLoader);\n+ end of original code*/\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex a01159bd..76d2a121 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -303,6 +303,17 @@ public class FastDateParser implements DateParser, Serializable {\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n         boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n+// start of generated patch\n+char c=value.charAt(i);\n+if(Character.isHighSurrogate(c)){\n+if(!wasWhite){\n+wasWhite=true;\n+regex.append(\"\\\\s*+\");\n+}\n+continue;\n+}\n+// end of generated patch\n+/* start of original code\n             char c= value.charAt(i);\n             if(Character.isWhitespace(c)) {\n                 if(!wasWhite) {\n@@ -311,6 +322,7 @@ public class FastDateParser implements DateParser, Serializable {\n                 }\n                 continue;\n             }\n+ end of original code*/\n             wasWhite= false;\n             switch(c) {\n             case '\\'':",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 67,
    "bugId": 168,
    "name": "Patch_2426_512",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex a01159b..aaef1f7 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -304,13 +304,7 @@ public class FastDateParser implements DateParser, Serializable {\n         boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n+            \n             wasWhite= false;\n             switch(c) {\n             case '\\'':\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 67,
    "bugId": 168,
    "name": "Patch_83_81",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Lang_10/src/main/java/org/apache/commons/lang3/time/FastDateParserjava\n+++ /tmp/jKali_Defects4J_Lang_10/src/main/java/org/apache/commons/lang3/time/FastDateParserjava\n@@ -304,7 +304,7 @@\n \t\tboolean wasWhite = false;\n \t\tfor (int i = 0; i < (value.length()); ++i) {\n \t\t\tchar c = value.charAt(i);\n-\t\t\tif (java.lang.Character.isWhitespace(c)) {\n+\t\t\tif (false) {\n \t\t\t\tif (!wasWhite) {\n \t\t\t\t\twasWhite = true;\n \t\t\t\t\tregex.append(\"\\\\s*+\");\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 67,
    "bugId": 168,
    "name": "Patch_1577_529",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex a01159b..5f5fee8 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -304,7 +304,7 @@ public class FastDateParser implements DateParser, Serializable {\n         boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n+            if((Character.isWhitespace(c)) && !(unquote)) {\n                 if(!wasWhite) {\n                     wasWhite= true;\n                     regex.append(\"\\\\s*+\");",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 67,
    "bugId": 168,
    "name": "Patch_2435_1012",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex a01159b..aaef1f7 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -304,13 +304,7 @@ public class FastDateParser implements DateParser, Serializable {\n         boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n+            \n             wasWhite= false;\n             switch(c) {\n             case '\\'':",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 68,
    "bugId": 161,
    "name": "Patch_164_164",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 1e6ccdc0..513f4143 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -465,9 +465,21 @@ public class NumberUtils {\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n+// start of generated patch\n+if(hexDigits>16){\n+try{\n+return createLong(str);\n+}catch (final NumberFormatException nfe) {\n+}\n+\n+return createBigInteger(str);\n+}\n+// end of generated patch\n+/* start of original code\n             if (hexDigits > 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n+ end of original code*/\n             if (hexDigits > 8) { // too many for an int\n                 return createLong(str);\n             }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 69,
    "bugId": 93,
    "name": "Patch_1_1",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74fe..6392591a 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,6 +1042,14 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n+// start of generated patch\n+if(c>0x1f&&c<0x7f){\n+sb.append(c);\n+}else {\n+appendHexJavaScriptRepresentation(sb,c);\n+}\n+// end of generated patch\n+/* start of original code\n             if (c > 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n@@ -1050,6 +1058,7 @@ class CodeGenerator {\n               // so we play it safe and unicode escape them.\n               appendHexJavaScriptRepresentation(sb, c);\n             }\n+ end of original code*/\n           }\n       }\n     }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 69,
    "bugId": 93,
    "name": "Patch_136_29",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74f..823d897 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 69,
    "bugId": 93,
    "name": "Patch_133_69",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74f..823d897 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 69,
    "bugId": 93,
    "name": "Patch_146_58",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74f..fc0d0f4 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (c > 0x1f && c<0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 70,
    "bugId": 134,
    "name": "Patch_4497_4497",
    "tool": "SimFix",
    "diff": "diff --git a/src/com/google/javascript/rhino/Node.java b/src/com/google/javascript/rhino/Node.java\nindex 6a3e9e03..341965fd 100644\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n@@ -1826,6 +1826,15 @@ public class Node implements Cloneable, Serializable {\n    * that of {@code other} iff the source info is missing.\n    */\n   public Node useSourceInfoIfMissingFromForTree(Node other) {\n+// start of generated patch\n+useSourceInfoIfMissingFrom(other);\n+for(Node child=getFirstChild();child!=null;child=child.getNext()){\n+child.useSourceInfoIfMissingFromForTree(other);\n+}\n+this.propListHead=other.propListHead;\n+return this;\n+// end of generated patch\n+/* start of original code\n     useSourceInfoIfMissingFrom(other);\n     for (Node child = getFirstChild();\n          child != null; child = child.getNext()) {\n@@ -1833,6 +1842,7 @@ public class Node implements Cloneable, Serializable {\n     }\n \n     return this;\n+ end of original code*/\n   }\n \n   //==========================================================================",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 70,
    "bugId": 134,
    "name": "Patch_408_102",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java\nindex 1e22c9e..b9dfdcf 100644\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -419,7 +419,7 @@ class ScopedAliases implements HotSwapCompilerPass {\n                 compiler.getCodingConvention(),\n                 globalName,\n                 value,\n-                v.getJSDocInfo())\n+                grandparent.getJSDocInfo())\n                 .useSourceInfoIfMissingFromForTree(n);\n             NodeUtil.setDebugInformation(\n                 newDecl.getFirstChild().getFirstChild(), n, name);\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 71,
    "bugId": 303,
    "name": "Patch_26_26",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..aa20db734 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -87,12 +87,19 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n+// start of generated patch\n+if(comparator.compare(contracted,best)<=0){\n+return ;\n+}\n+// end of generated patch\n+/* start of original code\n             if (comparator.compare(contracted, best) < 0) {\n                 // accept the contracted simplex\n \n             // check convergence\n                 return;\n             }\n+ end of original code*/\n \n         }\n ",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 71,
    "bugId": 303,
    "name": "Patch_520_355",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\t2019-07-31 06:58:56.189317507 -0400\n+++ /tmp/Arja_Defects4J_Math_84/patches_mko5/Patch_355/patched/org/apache/commons/math/optimization/direct/MultiDirectional.java\t2019-07-31 07:09:15.173698880 -0400\n@@ -87,12 +87,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n-            }\n+            break;\n \n         }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 71,
    "bugId": 303,
    "name": "Patch_135_45",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9d..43b1fcf 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -87,7 +87,7 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best) <= 0) {\n                 // accept the contracted simplex\n \n             // check convergence\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 71,
    "bugId": 303,
    "name": "Patch_7_7",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionaljava\n+++ /tmp/jMutRepair_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionaljava\n@@ -87,7 +87,7 @@\n \n \n \t\t\tfinal org.apache.commons.math.optimization.RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-\t\t\tif ((comparator.compare(contracted, best)) < 0) {\n+\t\t\tif ((comparator.compare(contracted, best)) == 0) {\n \n \n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 71,
    "bugId": 303,
    "name": "Patch_803_248",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionaljava\n+++ /tmp/jGenProg_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionaljava\n@@ -92,7 +92,7 @@\n \n \n \t\t\t\treturn;\n-\t\t\t}\n+\t\t\t} \t\t\treturn;\n \n \t\t} \n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 71,
    "bugId": 303,
    "name": "Patch_93_43",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9d..43b1fcf 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -87,7 +87,7 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best) <= 0) {\n                 // accept the contracted simplex\n \n             // check convergence",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 71,
    "bugId": 303,
    "name": "Patch_93_43",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9d..43b1fcf 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -87,7 +87,7 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best) <= 0) {\n                 // accept the contracted simplex\n \n             // check convergence",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 71,
    "bugId": 303,
    "name": "Patch_114_72",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9d..71eb569 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -87,7 +87,7 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best)==0) {\n                 // accept the contracted simplex\n \n             // check convergence",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 71,
    "bugId": 303,
    "name": "Patch_867_312",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\t2019-08-03 00:50:34.230549552 -0400\n+++ /tmp/RSRepair_Defects4J_Math_84/patches_d1k6/Patch_312/patched/org/apache/commons/math/optimization/direct/MultiDirectional.java\t2019-08-03 01:05:32.100055900 -0400\n@@ -63,7 +63,8 @@\n \n         while (true) {\n \n-            incrementIterationsCounter();\n+            final double[] xSmallest = simplex[0].getPointRef();\n+\t\t\tincrementIterationsCounter();\n \n             // save the original vertex\n             final RealPointValuePair[] original = simplex;\n@@ -87,12 +88,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n-            }\n+            return;\n \n         }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 71,
    "bugId": 303,
    "name": "Patch_3_3",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\t2018-12-01 16:40:24.033434484 -0500\n+++ /tmp/Kali_Defects4J_Math_84/patches_sijd/Patch_1/patched/tmp/Kali_Defects4J_Math_84/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\t2018-12-01 16:41:30.749436738 -0500\n@@ -87,7 +87,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (true) {\n                 // accept the contracted simplex\n \n             // check convergence\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 72,
    "bugId": 7,
    "name": "Patch_1622_1622",
    "tool": "SimFix",
    "diff": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex 795d791..b349229 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -1056,6 +1056,24 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n         TimeSeries copy = (TimeSeries) super.clone();\n         copy.data = new java.util.ArrayList();\n         if (this.data.size() > 0) {\n+// start of generated patch\n+this.maxY=1.0;\n+TimeSeries copy=(TimeSeries)super.clone();\n+copy.data=new java.util.ArrayList();\n+if(this.data.size()>0){\n+for(int index=start;index<=end;index++){\n+TimeSeriesDataItem item=(TimeSeriesDataItem)this.data.get(index);\n+TimeSeriesDataItem clone=(TimeSeriesDataItem)item.clone();\n+try{\n+copy.add(clone);\n+}catch (SeriesException e) {\n+  e.printStackTrace();\n+}\n+\n+}\n+}\n+// end of generated patch\n+/* start of original code\n             for (int index = start; index <= end; index++) {\n                 TimeSeriesDataItem item\n                         = (TimeSeriesDataItem) this.data.get(index);\n@@ -1067,6 +1085,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n                     e.printStackTrace();\n                 }\n             }\n+end of original code*/\n         }\n         return copy;\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 72,
    "bugId": 7,
    "name": "Patch_604_568",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_3/source/org/jfree/data/time/TimeSeries.java\t2019-07-18 23:48:37.293919331 -0400\n+++ /tmp/Arja_Defects4J_Chart_3/patches_itwf/Patch_568/patched/org/jfree/data/time/TimeSeries.java\t2019-07-19 00:17:42.037915377 -0400\n@@ -580,17 +580,8 @@\n         Class c = item.getPeriod().getClass();\n         if (this.timePeriodClass == null) {\n             this.timePeriodClass = c;\n-        }\n-        else if (!this.timePeriodClass.equals(c)) {\n-            StringBuffer b = new StringBuffer();\n-            b.append(\"You are trying to add data where the time period class \");\n-            b.append(\"is \");\n-            b.append(item.getPeriod().getClass().getName());\n-            b.append(\", but the TimeSeries is expecting an instance of \");\n-            b.append(this.timePeriodClass.getName());\n-            b.append(\".\");\n-            throw new SeriesException(b.toString());\n-        }\n+        } else\n+\t\t\tfindBoundsByIteration();\n \n         // make the change (if it's not a duplicate time period)...\n         boolean added = false;\n@@ -664,7 +655,10 @@\n     public void add(RegularTimePeriod period, double value, boolean notify) {\n         // defer argument checking...\n         TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n-        add(item, notify);\n+        if (notify) {\n+\t\t\tfireSeriesChanged();\n+\t\t}\n+\t\tadd(item, notify);\n     }\n \n     /**\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 72,
    "bugId": 7,
    "name": "Patch_4211_3698",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Chart_3/source/org/jfree/data/time/TimeSeriesjava\n+++ /tmp/jGenProg_Defects4J_Chart_3/source/org/jfree/data/time/TimeSeriesjava\n@@ -561,8 +561,6 @@\n \n \n \tpublic void add(org.jfree.data.time.TimeSeriesDataItem item) {\n-\t\tadd(item, true);\n-\t}\n \n \n \n@@ -572,74 +570,13 @@\n \n \n \n-\tpublic void add(org.jfree.data.time.TimeSeriesDataItem item, boolean notify) {\n-\t\tif (item == null) {\n-\t\t\tthrow new java.lang.IllegalArgumentException(\"Null 'item' argument.\");\n-\t\t}\n-\t\titem = ((org.jfree.data.time.TimeSeriesDataItem) (item.clone()));\n-\t\tjava.lang.Class c = item.getPeriod().getClass();\n-\t\tif ((this.timePeriodClass) == null) {\n-\t\t\tthis.timePeriodClass = c;\n-\t\t}else\n-\t\t\tif (!(this.timePeriodClass.equals(c))) {\n-\t\t\t\tjava.lang.StringBuffer b = new java.lang.StringBuffer();\n-\t\t\t\tb.append(\"You are trying to add data where the time period class \");\n-\t\t\t\tb.append(\"is \");\n-\t\t\t\tb.append(item.getPeriod().getClass().getName());\n-\t\t\t\tb.append(\", but the TimeSeries is expecting an instance of \");\n-\t\t\t\tb.append(this.timePeriodClass.getName());\n-\t\t\t\tb.append(\".\");\n-\t\t\t\tthrow new org.jfree.data.general.SeriesException(b.toString());\n-\t\t\t}\n \n \n-\t\tboolean added = false;\n-\t\tint count = getItemCount();\n-\t\tif (count == 0) {\n-\t\t\tthis.data.add(item);\n-\t\t\tadded = true;\n-\t\t}else \n-\t\t{\n-\t\t\torg.jfree.data.time.RegularTimePeriod last = getTimePeriod(((getItemCount()) - 1));\n-\t\t\tif ((item.getPeriod().compareTo(last)) > 0) {\n-\t\t\t\tthis.data.add(item);\n-\t\t\t\tadded = true;\n-\t\t\t}else \n-\t\t\t{\n-\t\t\t\tint index = java.util.Collections.binarySearch(this.data, item);\n-\t\t\t\tif (index < 0) {\n-\t\t\t\t\tthis.data.add(((-index) - 1), item);\n-\t\t\t\t\tadded = true;\n-\t\t\t\t}else \n-\t\t\t\t{\n-\t\t\t\t\tjava.lang.StringBuffer b = new java.lang.StringBuffer();\n-\t\t\t\t\tb.append(\"You are attempting to add an observation for \");\n-\t\t\t\t\tb.append(\"the time period \");\n-\t\t\t\t\tb.append(item.getPeriod().toString());\n-\t\t\t\t\tb.append(\" but the series already contains an observation\");\n-\t\t\t\t\tb.append(\" for that time period. Duplicates are not \");\n-\t\t\t\t\tb.append(\"permitted.  Try using the addOrUpdate() method.\");\n-\t\t\t\t\tthrow new org.jfree.data.general.SeriesException(b.toString());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tif (added) {\n-\t\t\tupdateBoundsForAddedItem(item);\n \n-\t\t\tif ((getItemCount()) > (this.maximumItemCount)) {\n-\t\t\t\torg.jfree.data.time.TimeSeriesDataItem d = ((org.jfree.data.time.TimeSeriesDataItem) (this.data.remove(0)));\n-\t\t\t\tupdateBoundsForRemovedItem(d);\n-\t\t\t}\n \n-\t\t\tremoveAgedItems(false);\n \n \n-\t\t\tif (notify) {\n-\t\t\t\tfireSeriesChanged();\n-\t\t\t}\n-\t\t}\n \n-\t}\n \n \n \n@@ -648,10 +585,7 @@\n \n \n \n-\tpublic void add(org.jfree.data.time.RegularTimePeriod period, double value) {\n \n-\t\tadd(period, value, true);\n-\t}\n \n \n \n@@ -661,11 +595,7 @@\n \n \n \n-\tpublic void add(org.jfree.data.time.RegularTimePeriod period, double value, boolean notify) {\n \n-\t\torg.jfree.data.time.TimeSeriesDataItem item = new org.jfree.data.time.TimeSeriesDataItem(period, value);\n-\t\tadd(item, notify);\n-\t}\n \n \n \n@@ -675,10 +605,7 @@\n \n \n \n-\tpublic void add(org.jfree.data.time.RegularTimePeriod period, java.lang.Number value) {\n \n-\t\tadd(period, value, true);\n-\t}\n \n \n \n@@ -688,11 +615,7 @@\n \n \n \n-\tpublic void add(org.jfree.data.time.RegularTimePeriod period, java.lang.Number value, boolean notify) {\n \n-\t\torg.jfree.data.time.TimeSeriesDataItem item = new org.jfree.data.time.TimeSeriesDataItem(period, value);\n-\t\tadd(item, notify);\n-\t}\n \n \n \n@@ -701,15 +624,6 @@\n \n \n \n-\tpublic void update(org.jfree.data.time.RegularTimePeriod period, java.lang.Number value) {\n-\t\torg.jfree.data.time.TimeSeriesDataItem temp = new org.jfree.data.time.TimeSeriesDataItem(period, value);\n-\t\tint index = java.util.Collections.binarySearch(this.data, temp);\n-\t\tif (index < 0) {\n-\t\t\tthrow new org.jfree.data.general.SeriesException((\"There is no existing value for the \" + \n-\t\t\t\"specified 'period'.\"));\n-\t\t}\n-\t\tupdate(index, value);\n-\t}\n \n \n \n@@ -717,27 +631,6 @@\n \n \n \n-\tpublic void update(int index, java.lang.Number value) {\n-\t\torg.jfree.data.time.TimeSeriesDataItem item = ((org.jfree.data.time.TimeSeriesDataItem) (this.data.get(index)));\n-\t\tboolean iterate = false;\n-\t\tjava.lang.Number oldYN = item.getValue();\n-\t\tif (oldYN != null) {\n-\t\t\tdouble oldY = oldYN.doubleValue();\n-\t\t\tif (!(java.lang.Double.isNaN(oldY))) {\n-\t\t\t\titerate = (oldY <= (this.minY)) || (oldY >= (this.maxY));\n-\t\t\t}\n-\t\t}\n-\t\titem.setValue(value);\n-\t\tif (iterate) {\n-\t\t\tfindBoundsByIteration();\n-\t\t}else\n-\t\t\tif (value != null) {\n-\t\t\t\tdouble yy = value.doubleValue();\n-\t\t\t\tthis.minY = minIgnoreNaN(this.minY, yy);\n-\t\t\t\tthis.maxY = maxIgnoreNaN(this.maxY, yy);\n-\t\t\t}\n-\t\tfireSeriesChanged();\n-\t}\n \n \n \n@@ -747,19 +640,6 @@\n \n \n \n-\tpublic org.jfree.data.time.TimeSeries addAndOrUpdate(org.jfree.data.time.TimeSeries series) {\n-\t\torg.jfree.data.time.TimeSeries overwritten = new org.jfree.data.time.TimeSeries((\"Overwritten values from: \" + \n-\t\t(getKey())));\n-\t\tfor (int i = 0; i < (series.getItemCount()); i++) {\n-\t\t\torg.jfree.data.time.TimeSeriesDataItem item = series.getRawDataItem(i);\n-\t\t\torg.jfree.data.time.TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(), \n-\t\t\titem.getValue());\n-\t\t\tif (oldItem != null) {\n-\t\t\t\toverwritten.add(oldItem);\n-\t\t\t}\n-\t\t}\n-\t\treturn overwritten;\n-\t}\n \n \n \n@@ -772,10 +652,6 @@\n \n \n \n-\tpublic org.jfree.data.time.TimeSeriesDataItem addOrUpdate(org.jfree.data.time.RegularTimePeriod period, \n-\tdouble value) {\n-\t\treturn addOrUpdate(period, new java.lang.Double(value));\n-\t}\n \n \n \n@@ -788,10 +664,6 @@\n \n \n \n-\tpublic org.jfree.data.time.TimeSeriesDataItem addOrUpdate(org.jfree.data.time.RegularTimePeriod period, \n-\tjava.lang.Number value) {\n-\t\treturn addOrUpdate(new org.jfree.data.time.TimeSeriesDataItem(period, value));\n-\t}\n \n \n \n@@ -804,64 +676,14 @@\n \n \n \n-\tpublic org.jfree.data.time.TimeSeriesDataItem addOrUpdate(org.jfree.data.time.TimeSeriesDataItem item) {\n \n-\t\tif (item == null) {\n-\t\t\tthrow new java.lang.IllegalArgumentException(\"Null 'period' argument.\");\n-\t\t}\n-\t\tjava.lang.Class periodClass = item.getPeriod().getClass();\n-\t\tif ((this.timePeriodClass) == null) {\n-\t\t\tthis.timePeriodClass = periodClass;\n-\t\t}else\n-\t\t\tif (!(this.timePeriodClass.equals(periodClass))) {\n-\t\t\t\tjava.lang.String msg = ((((\"You are trying to add data where the time \" + \n-\t\t\t\t\"period class is \") + (periodClass.getName())) + \n-\t\t\t\t\", but the TimeSeries is expecting an instance of \") + \n-\t\t\t\t(this.timePeriodClass.getName())) + \".\";\n-\t\t\t\tthrow new org.jfree.data.general.SeriesException(msg);\n-\t\t\t}\n-\t\torg.jfree.data.time.TimeSeriesDataItem overwritten = null;\n-\t\tint index = java.util.Collections.binarySearch(this.data, item);\n-\t\tif (index >= 0) {\n-\t\t\torg.jfree.data.time.TimeSeriesDataItem existing = \n-\t\t\t((org.jfree.data.time.TimeSeriesDataItem) (this.data.get(index)));\n-\t\t\toverwritten = ((org.jfree.data.time.TimeSeriesDataItem) (existing.clone()));\n \n \n-\t\t\tboolean iterate = false;\n-\t\t\tjava.lang.Number oldYN = existing.getValue();\n-\t\t\tdouble oldY = (oldYN != null) ? oldYN.doubleValue() : java.lang.Double.NaN;\n-\t\t\tif (!(java.lang.Double.isNaN(oldY))) {\n-\t\t\t\titerate = (oldY <= (this.minY)) || (oldY >= (this.maxY));\n-\t\t\t}\n-\t\t\texisting.setValue(item.getValue());\n-\t\t\tif (iterate) {\n-\t\t\t\tfindBoundsByIteration();\n-\t\t\t}else\n-\t\t\t\tif ((item.getValue()) != null) {\n-\t\t\t\t\tdouble yy = item.getValue().doubleValue();\n-\t\t\t\t\tthis.minY = minIgnoreNaN(this.minY, yy);\n-\t\t\t\t\tthis.maxY = minIgnoreNaN(this.maxY, yy);\n-\t\t\t\t}\n-\t\t}else \n-\t\t{\n-\t\t\titem = ((org.jfree.data.time.TimeSeriesDataItem) (item.clone()));\n-\t\t\tthis.data.add(((-index) - 1), item);\n-\t\t\tupdateBoundsForAddedItem(item);\n \n \n-\t\t\tif ((getItemCount()) > (this.maximumItemCount)) {\n-\t\t\t\torg.jfree.data.time.TimeSeriesDataItem d = ((org.jfree.data.time.TimeSeriesDataItem) (this.data.remove(0)));\n-\t\t\t\tupdateBoundsForRemovedItem(d);\n-\t\t\t}\n-\t\t}\n-\t\tremoveAgedItems(false);\n \n \n-\t\tfireSeriesChanged();\n-\t\treturn overwritten;\n \n-\t}\n \n \n \n@@ -871,25 +693,8 @@\n \n \n \n-\tpublic void removeAgedItems(boolean notify) {\n \n \n-\t\tif ((getItemCount()) > 1) {\n-\t\t\tlong latest = getTimePeriod(((getItemCount()) - 1)).getSerialIndex();\n-\t\t\tboolean removed = false;\n-\t\t\twhile ((latest - (getTimePeriod(0).getSerialIndex())) > \n-\t\t\t(this.maximumItemAge)) {\n-\t\t\t\tthis.data.remove(0);\n-\t\t\t\tremoved = true;\n-\t\t\t} \n-\t\t\tif (removed) {\n-\t\t\t\tfindBoundsByIteration();\n-\t\t\t\tif (notify) {\n-\t\t\t\t\tfireSeriesChanged();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n \n \n \n@@ -901,60 +706,15 @@\n \n \n \n-\tpublic void removeAgedItems(long latest, boolean notify) {\n-\t\tif (this.data.isEmpty()) {\n-\t\t\treturn;\n-\t\t}\n \n-\t\tlong index = java.lang.Long.MAX_VALUE;\n-\t\ttry {\n-\t\t\tjava.lang.reflect.Method m = org.jfree.data.time.RegularTimePeriod.class.getDeclaredMethod(\n-\t\t\t\"createInstance\", new java.lang.Class[]{ java.lang.Class.class, java.util.Date.class, \n-\t\t\tjava.util.TimeZone.class });\n-\t\t\torg.jfree.data.time.RegularTimePeriod newest = ((org.jfree.data.time.RegularTimePeriod) (m.invoke(\n-\t\t\tthis.timePeriodClass, new java.lang.Object[]{ this.timePeriodClass, \n-\t\t\tnew java.util.Date(latest), java.util.TimeZone.getDefault() })));\n-\t\t\tindex = newest.getSerialIndex();\n-\t\t}\n-\t\t catch (java.lang.NoSuchMethodException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t\t catch (java.lang.IllegalAccessException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n-\t\t catch (java.lang.reflect.InvocationTargetException e) {\n-\t\t\te.printStackTrace();\n-\t\t}\n \n \n \n-\t\tboolean removed = false;\n-\t\twhile (((getItemCount()) > 0) && ((index - \n-\t\t(getTimePeriod(0).getSerialIndex())) > (this.maximumItemAge))) {\n-\t\t\tthis.data.remove(0);\n-\t\t\tremoved = true;\n-\t\t} \n-\t\tif (removed) {\n-\t\t\tfindBoundsByIteration();\n-\t\t\tif (notify) {\n-\t\t\t\tfireSeriesChanged();\n-\t\t\t}\n-\t\t}\n-\t}\n \n \n \n \n \n-\tpublic void clear() {\n-\t\tif ((this.data.size()) > 0) {\n-\t\t\tthis.data.clear();\n-\t\t\tthis.timePeriodClass = null;\n-\t\t\tthis.minY = java.lang.Double.NaN;\n-\t\t\tthis.maxY = java.lang.Double.NaN;\n-\t\t\tfireSeriesChanged();\n-\t\t}\n-\t}\n \n \n \n@@ -964,12 +724,252 @@\n \n \n \n-\tpublic void delete(org.jfree.data.time.RegularTimePeriod period) {\n-\t\tint index = getIndex(period);\n-\t\tif (index >= 0) {\n-\t\t\torg.jfree.data.time.TimeSeriesDataItem item = ((org.jfree.data.time.TimeSeriesDataItem) (this.data.remove(\n-\t\t\tindex)));\n-\t\t\tupdateBoundsForRemovedItem(item);\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\t\tupdateBoundsForRemovedItem(item); \t\tadd(item, true);} \tpublic void add(org.jfree.data.time.TimeSeriesDataItem item, boolean notify) { \t\tif (item == null) { \t\t\tthrow new java.lang.IllegalArgumentException(\"Null 'item' argument.\");} \t\titem = ((org.jfree.data.time.TimeSeriesDataItem) (item.clone())); \t\tjava.lang.Class c = item.getPeriod().getClass(); \t\tif ((this.timePeriodClass) == null) { \t\t\tthis.timePeriodClass = c;}else \t\t\tif (!(this.timePeriodClass.equals(c))) { \t\t\t\tjava.lang.StringBuffer b = new java.lang.StringBuffer(); \t\t\t\tb.append(\"You are trying to add data where the time period class \"); \t\t\t\tb.append(\"is \"); \t\t\t\tb.append(item.getPeriod().getClass().getName()); \t\t\t\tb.append(\", but the TimeSeries is expecting an instance of \"); \t\t\t\tb.append(this.timePeriodClass.getName()); \t\t\t\tb.append(\".\"); \t\t\t\tthrow new org.jfree.data.general.SeriesException(b.toString());} \t\tboolean added = false; \t\tint count = getItemCount(); \t\tif (count == 0) { \t\t\tthis.data.add(item); \t\t\tadded = true;}else { \t\t\torg.jfree.data.time.RegularTimePeriod last = getTimePeriod(((getItemCount()) - 1)); \t\t\tif ((item.getPeriod().compareTo(last)) > 0) { \t\t\t\tthis.data.add(item); \t\t\t\tadded = true;}else { \t\t\t\tint index = java.util.Collections.binarySearch(this.data, item); \t\t\t\tif (index < 0) { \t\t\t\t\tthis.data.add(((-index) - 1), item); \t\t\t\t\tadded = true;}else { \t\t\t\t\tjava.lang.StringBuffer b = new java.lang.StringBuffer(); \t\t\t\t\tb.append(\"You are attempting to add an observation for \"); \t\t\t\t\tb.append(\"the time period \"); \t\t\t\t\tb.append(item.getPeriod().toString()); \t\t\t\t\tb.append(\" but the series already contains an observation\"); \t\t\t\t\tb.append(\" for that time period. Duplicates are not \"); \t\t\t\t\tb.append(\"permitted.  Try using the addOrUpdate() method.\"); \t\t\t\t\tthrow new org.jfree.data.general.SeriesException(b.toString());}}} \t\tif (added) { \t\t\tupdateBoundsForAddedItem(item); \t\t\tif ((getItemCount()) > (this.maximumItemCount)) { \t\t\t\torg.jfree.data.time.TimeSeriesDataItem d = ((org.jfree.data.time.TimeSeriesDataItem) (this.data.remove(0))); \t\t\t\tupdateBoundsForRemovedItem(d);} \t\t\tremoveAgedItems(false); \t\t\tif (notify) { \t\t\t\tfireSeriesChanged();}}} \tpublic void add(org.jfree.data.time.RegularTimePeriod period, double value) { \t\tadd(period, value, true);} \tpublic void add(org.jfree.data.time.RegularTimePeriod period, double value, boolean notify) { \t\torg.jfree.data.time.TimeSeriesDataItem item = new org.jfree.data.time.TimeSeriesDataItem(period, value); \t\tadd(item, notify);} \tpublic void add(org.jfree.data.time.RegularTimePeriod period, java.lang.Number value) { \t\tadd(period, value, true);} \tpublic void add(org.jfree.data.time.RegularTimePeriod period, java.lang.Number value, boolean notify) { \t\torg.jfree.data.time.TimeSeriesDataItem item = new org.jfree.data.time.TimeSeriesDataItem(period, value); \t\tadd(item, notify);} \tpublic void update(org.jfree.data.time.RegularTimePeriod period, java.lang.Number value) { \t\torg.jfree.data.time.TimeSeriesDataItem temp = new org.jfree.data.time.TimeSeriesDataItem(period, value); \t\tint index = java.util.Collections.binarySearch(this.data, temp); \t\tif (index < 0) { \t\t\tthrow new org.jfree.data.general.SeriesException((\"There is no existing value for the \" + \"specified 'period'.\"));} \t\tupdate(index, value);} \tpublic void update(int index, java.lang.Number value) { \t\torg.jfree.data.time.TimeSeriesDataItem item = ((org.jfree.data.time.TimeSeriesDataItem) (this.data.get(index))); \t\tboolean iterate = false; \t\tjava.lang.Number oldYN = item.getValue(); \t\tif (oldYN != null) { \t\t\tdouble oldY = oldYN.doubleValue(); \t\t\tif (!(java.lang.Double.isNaN(oldY))) { \t\t\t\titerate = (oldY <= (this.minY)) || (oldY >= (this.maxY));}} \t\titem.setValue(value); \t\tif (iterate) { \t\t\tfindBoundsByIteration();}else \t\t\tif (value != null) { \t\t\t\tdouble yy = value.doubleValue(); \t\t\t\tthis.minY = minIgnoreNaN(this.minY, yy); \t\t\t\tthis.maxY = maxIgnoreNaN(this.maxY, yy);} \t\tfireSeriesChanged();} \tpublic org.jfree.data.time.TimeSeries addAndOrUpdate(org.jfree.data.time.TimeSeries series) { \t\torg.jfree.data.time.TimeSeries overwritten = new org.jfree.data.time.TimeSeries((\"Overwritten values from: \" + (getKey()))); \t\tfor (int i = 0; i < (series.getItemCount()); i++) { \t\t\torg.jfree.data.time.TimeSeriesDataItem item = series.getRawDataItem(i); \t\t\torg.jfree.data.time.TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(), item.getValue()); \t\t\tif (oldItem != null) { \t\t\t\toverwritten.add(oldItem);}} \t\treturn overwritten;} \tpublic org.jfree.data.time.TimeSeriesDataItem addOrUpdate(org.jfree.data.time.RegularTimePeriod period, double value) { \t\treturn addOrUpdate(period, new java.lang.Double(value));} \tpublic org.jfree.data.time.TimeSeriesDataItem addOrUpdate(org.jfree.data.time.RegularTimePeriod period, java.lang.Number value) { \t\treturn addOrUpdate(new org.jfree.data.time.TimeSeriesDataItem(period, value));} \tpublic org.jfree.data.time.TimeSeriesDataItem addOrUpdate(org.jfree.data.time.TimeSeriesDataItem item) { \t\tif (item == null) { \t\t\tthrow new java.lang.IllegalArgumentException(\"Null 'period' argument.\");} \t\tjava.lang.Class periodClass = item.getPeriod().getClass(); \t\tif ((this.timePeriodClass) == null) { \t\t\tthis.timePeriodClass = periodClass;}else \t\t\tif (!(this.timePeriodClass.equals(periodClass))) { \t\t\t\tjava.lang.String msg = ((((\"You are trying to add data where the time \" + \"period class is \") + (periodClass.getName())) + \", but the TimeSeries is expecting an instance of \") + (this.timePeriodClass.getName())) + \".\"; \t\t\t\tthrow new org.jfree.data.general.SeriesException(msg);} \t\torg.jfree.data.time.TimeSeriesDataItem overwritten = null; \t\tint index = java.util.Collections.binarySearch(this.data, item); \t\tif (index >= 0) { \t\t\torg.jfree.data.time.TimeSeriesDataItem existing = ((org.jfree.data.time.TimeSeriesDataItem) (this.data.get(index))); \t\t\toverwritten = ((org.jfree.data.time.TimeSeriesDataItem) (existing.clone())); \t\t\tboolean iterate = false; \t\t\tjava.lang.Number oldYN = existing.getValue(); \t\t\tdouble oldY = (oldYN != null) ? oldYN.doubleValue() : java.lang.Double.NaN; \t\t\tif (!(java.lang.Double.isNaN(oldY))) { \t\t\t\titerate = (oldY <= (this.minY)) || (oldY >= (this.maxY));} \t\t\texisting.setValue(item.getValue()); \t\t\tif (iterate) { \t\t\t\tfindBoundsByIteration();}else \t\t\t\tif ((item.getValue()) != null) { \t\t\t\t\tdouble yy = item.getValue().doubleValue(); \t\t\t\t\tthis.minY = minIgnoreNaN(this.minY, yy); \t\t\t\t\tthis.maxY = minIgnoreNaN(this.maxY, yy);}}else { \t\t\titem = ((org.jfree.data.time.TimeSeriesDataItem) (item.clone())); \t\t\tthis.data.add(((-index) - 1), item); \t\t\tupdateBoundsForAddedItem(item); \t\t\tif ((getItemCount()) > (this.maximumItemCount)) { \t\t\t\torg.jfree.data.time.TimeSeriesDataItem d = ((org.jfree.data.time.TimeSeriesDataItem) (this.data.remove(0))); \t\t\t\tupdateBoundsForRemovedItem(d);}} \t\tremoveAgedItems(false); \t\tfireSeriesChanged(); \t\treturn overwritten;} \tpublic void removeAgedItems(boolean notify) { \t\tif ((getItemCount()) > 1) { \t\t\tlong latest = getTimePeriod(((getItemCount()) - 1)).getSerialIndex(); \t\t\tboolean removed = false; \t\t\twhile ((latest - (getTimePeriod(0).getSerialIndex())) > (this.maximumItemAge)) { \t\t\t\tthis.data.remove(0); \t\t\t\tremoved = true;} \t\t\tif (removed) { \t\t\t\tfindBoundsByIteration(); \t\t\t\tif (notify) { \t\t\t\t\tfireSeriesChanged();}}}} \tpublic void removeAgedItems(long latest, boolean notify) { \t\tif (this.data.isEmpty()) { \t\t\treturn;} \t\tlong index = java.lang.Long.MAX_VALUE; \t\ttry { \t\t\tjava.lang.reflect.Method m = org.jfree.data.time.RegularTimePeriod.class.getDeclaredMethod(\"createInstance\", new java.lang.Class[]{ java.lang.Class.class, java.util.Date.class, java.util.TimeZone.class }); \t\t\torg.jfree.data.time.RegularTimePeriod newest = ((org.jfree.data.time.RegularTimePeriod) (m.invoke(this.timePeriodClass, new java.lang.Object[]{ this.timePeriodClass, new java.util.Date(latest), java.util.TimeZone.getDefault() }))); \t\t\tindex = newest.getSerialIndex();} catch (java.lang.NoSuchMethodException e) { \t\t\te.printStackTrace();} catch (java.lang.IllegalAccessException e) { \t\t\te.printStackTrace();} catch (java.lang.reflect.InvocationTargetException e) { \t\t\te.printStackTrace();} \t\tboolean removed = false; \t\twhile (((getItemCount()) > 0) && ((index - (getTimePeriod(0).getSerialIndex())) > (this.maximumItemAge))) { \t\t\tthis.data.remove(0); \t\t\tremoved = true;} \t\tif (removed) { \t\t\tfindBoundsByIteration(); \t\t\tif (notify) { \t\t\t\tfireSeriesChanged();}}} \tpublic void clear() { \t\tif ((this.data.size()) > 0) { \t\t\tthis.data.clear(); \t\t\tthis.timePeriodClass = null; \t\t\tthis.minY = java.lang.Double.NaN; \t\t\tthis.maxY = java.lang.Double.NaN; \t\t\tfireSeriesChanged();}} \tpublic void delete(org.jfree.data.time.RegularTimePeriod period) { \t\tint index = getIndex(period); \t\tif (index >= 0) { \t\t\torg.jfree.data.time.TimeSeriesDataItem item = ((org.jfree.data.time.TimeSeriesDataItem) (this.data.remove(index))); \t\t\tupdateBoundsForRemovedItem(item);\n \t\t\tif (this.data.isEmpty()) {\n \t\t\t\tthis.timePeriodClass = null;\n \t\t\t}\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 72,
    "bugId": 7,
    "name": "Patch_583_267",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex 795d791..4e77f41 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -882,7 +882,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n                 this.data.remove(0);\n                 removed = true;\n             }\n-            if (removed) {\n+            if ((removed) || !(notify)) {\n                 findBoundsByIteration();\n                 if (notify) {\n                     fireSeriesChanged();",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 72,
    "bugId": 7,
    "name": "Patch_583_267",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex 795d791..4e77f41 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -882,7 +882,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n                 this.data.remove(0);\n                 removed = true;\n             }\n-            if (removed) {\n+            if ((removed) || !(notify)) {\n                 findBoundsByIteration();\n                 if (notify) {\n                     fireSeriesChanged();",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 72,
    "bugId": 7,
    "name": "Patch_440_242",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex 795d791..d39fa2b 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -561,7 +561,8 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n      *              permitted).\n      */\n     public void add(TimeSeriesDataItem item) {\n-        add(item, true);\n+        updateBoundsForRemovedItem(item);\n+\tadd(item, true);\n     }\n \n     /**",
    "correctness": "P ",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 72,
    "bugId": 7,
    "name": "Patch_1990_733",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Chart_3/source/org/jfree/data/time/TimeSeries.java\t2019-07-23 12:46:15.213902377 -0400\n+++ /tmp/GenProg_Defects4J_Chart_3/patches_ff3y/Patch_733/patched/org/jfree/data/time/TimeSeries.java\t2019-07-23 13:01:07.102151342 -0400\n@@ -573,9 +573,7 @@\n      * @param notify  notify listeners?\n      */\n     public void add(TimeSeriesDataItem item, boolean notify) {\n-        if (item == null) {\n-            throw new IllegalArgumentException(\"Null 'item' argument.\");\n-        }\n+        updateBoundsForRemovedItem(item);\n         item = (TimeSeriesDataItem) item.clone();\n         Class c = item.getPeriod().getClass();\n         if (this.timePeriodClass == null) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 73,
    "bugId": 279,
    "name": "Patch_2_2",
    "tool": "SimFix",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex e0a8e97e9..831dd3dda 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -149,9 +149,18 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n      */\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n+// start of generated patch\n+MathUtils.checkNotNull(rhs);\n+if(isNaN||rhs.isNaN){\n+return NaN;\n+}\n+return createComplex(real+rhs.getReal(),imaginary+rhs.getImaginary());\n+// end of generated patch\n+/* start of original code\n         MathUtils.checkNotNull(rhs);\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n+ end of original code*/\n     }\n \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 73,
    "bugId": 279,
    "name": "Patch_191_80",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Math_53/src/main/java/org/apache/commons/math/complex/Complexjava\n+++ /tmp/jGenProg_Defects4J_Math_53/src/main/java/org/apache/commons/math/complex/Complexjava\n@@ -150,9 +150,6 @@\n \tpublic org.apache.commons.math.complex.Complex add(org.apache.commons.math.complex.Complex rhs) throws \n \torg.apache.commons.math.exception.NullArgumentException {\n \t\torg.apache.commons.math.util.MathUtils.checkNotNull(rhs);\n-\t\treturn createComplex(((real) + (rhs.getReal())), \n-\t\t((imaginary) + (rhs.getImaginary())));\n-\t}\n \n \n \n@@ -168,12 +165,6 @@\n \n \n \n-\tpublic org.apache.commons.math.complex.Complex conjugate() {\n-\t\tif (isNaN) {\n-\t\t\treturn org.apache.commons.math.complex.Complex.NaN;\n-\t\t}\n-\t\treturn createComplex(real, (-(imaginary)));\n-\t}\n \n \n \n@@ -210,12 +201,21 @@\n \n \n \n-\tpublic org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex rhs) throws \n-\torg.apache.commons.math.exception.NullArgumentException {\n-\t\torg.apache.commons.math.util.MathUtils.checkNotNull(rhs);\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n \t\tif ((isNaN) || (rhs.isNaN)) {\n \t\t\treturn org.apache.commons.math.complex.Complex.NaN;\n-\t\t}\n+\t\t} \t\treturn createComplex(((real) + (rhs.getReal())), ((imaginary) + (rhs.getImaginary())));} \tpublic org.apache.commons.math.complex.Complex conjugate() { \t\tif (isNaN) { \t\t\treturn org.apache.commons.math.complex.Complex.NaN;} \t\treturn createComplex(real, (-(imaginary)));} \tpublic org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex rhs) throws org.apache.commons.math.exception.NullArgumentException { \t\torg.apache.commons.math.util.MathUtils.checkNotNull(rhs); \t\tif ((isNaN) || (rhs.isNaN)) { \t\t\treturn org.apache.commons.math.complex.Complex.NaN;}\n \n \t\tdouble c = rhs.getReal();\n \t\tdouble d = rhs.getImaginary();\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 74,
    "bugId": 323,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n@@ -106,3 +106,5 @@\n         if (n == 0) {\n-            xbar = x;\n+            if ((x <= 1) || (y <= x)) {\n+                xbar = x;\n+            }\n             ybar = y;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 74,
    "bugId": 323,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n@@ -106,3 +106,5 @@\n         if (n == 0) {\n-            xbar = x;\n+            if (((!((x) != (1))) && (!((x) != (1)))) || (y < x)) {\n+                xbar = x;\n+            }\n             ybar = y;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 75,
    "bugId": 256,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -135,3 +135,3 @@\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (false) {\n  ",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 75,
    "bugId": 256,
    "name": "Patch_2_2",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Math_32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSetjava\n+++ /tmp/jKali_Defects4J_Math_32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSetjava\n@@ -133,7 +133,7 @@\n \n \t\tif ((v.length) == 0) {\n \t\t\tfinal org.apache.commons.math3.geometry.partitioning.BSPTree<org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D> tree = getTree(false);\n-\t\t\tif (((java.lang.Boolean) (tree.getAttribute()))) {\n+\t\t\tif (false) {\n \n \t\t\t\tsetSize(java.lang.Double.POSITIVE_INFINITY);\n \t\t\t\tsetBarycenter(org.apache.commons.math3.geometry.euclidean.twod.Vector2D.NaN);\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 75,
    "bugId": 256,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Math_32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2018-12-01 17:26:58.373440956 -0500\n+++ /tmp/Kali_Defects4J_Math_32/patches_r50i/Patch_2/patched/tmp/Kali_Defects4J_Math_32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2018-12-01 17:45:18.089896403 -0500\n@@ -133,7 +133,7 @@\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (false) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 76,
    "bugId": 276,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n@@ -604,3 +604,5 @@\n             }\n-            sum2 = 0;\n+            if (this.costRelativeTolerance != this.orthoTolerance) {\n+                sum2 = 0;\n+            }\n             for (int j = 0; j < solvedCols; ++j) {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 76,
    "bugId": 276,
    "name": "Patch_184_149",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2019-07-30 02:09:20.819666049 -0400\n+++ /tmp/Arja_Defects4J_Math_58/patches_vq7e/Patch_149/patched/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2019-07-30 02:39:02.385212272 -0400\n@@ -118,7 +118,7 @@\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+        return fit((new ParameterGuesser(getObservations())).guess());\n     }\n \n     /**\n\n\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 76,
    "bugId": 276,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n@@ -592,5 +592,7 @@\n             // compute the Newton correction\n-            for (int j = 0; j < solvedCols; ++j) {\n-                int pj = permutation[j];\n-                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n+            if (org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) {\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    int pj = permutation[j];\n+                    work1[pj] = work3[pj] * diag[pj] / dxNorm;\n+                }\n             }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 76,
    "bugId": 276,
    "name": "Patch_130_85",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\nindex ae7ac39..e1b54f4 100644\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n@@ -118,7 +118,7 @@ public class GaussianFitter extends CurveFitter {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+        return fit(guess);\n     }\n \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 76,
    "bugId": 276,
    "name": "Patch_4_3",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_58/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\t2019-08-03 02:57:06.112167041 -0400\n+++ /tmp/RSRepair_Defects4J_Math_58/patches_vk2l/Patch_3/patched/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\t2019-08-03 03:35:29.452318769 -0400\n@@ -589,11 +589,6 @@\n                 return;\n             }\n \n-            // compute the Newton correction\n-            for (int j = 0; j < solvedCols; ++j) {\n-                int pj = permutation[j];\n-                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n-            }\n             for (int j = 0; j < solvedCols; ++j) {\n                 int pj = permutation[j];\n                 work1[pj] /= work2[j];\n@@ -612,9 +607,14 @@\n             // depending on the sign of the function, update parl or paru.\n             if (fp > 0) {\n                 parl = FastMath.max(parl, lmPar);\n-            } else if (fp < 0) {\n-                paru = FastMath.min(paru, lmPar);\n-            }\n+            } else {\n+\t\t\t\tfor (int j = rank; j < cols; ++j) {\n+\t\t\t\t\tlmDir[permutation[j]] = 0;\n+\t\t\t\t}\n+\t\t\t\tif (fp < 0) {\n+\t\t\t\t\tparu = FastMath.min(paru, lmPar);\n+\t\t\t\t}\n+\t\t\t}\n \n             // compute an improved estimate for lmPar\n             lmPar = FastMath.max(parl, lmPar + correction);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 77,
    "bugId": 6,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "--- a/source/org/jfree/data/xy/XYSeries.java\n+++ b/source/org/jfree/data/xy/XYSeries.java\n@@ -562,3 +562,3 @@\n             // append the value to the list...\n-            if (this.autoSort) {\n+            if (false) {\n                 this.data.add(-index - 1, new XYDataItem(x, y));\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 77,
    "bugId": 6,
    "name": "Patch_86_70",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_5/source/org/jfree/data/xy/XYSeries.java\t2019-07-19 01:50:40.741902735 -0400\n+++ /tmp/Arja_Defects4J_Chart_5/patches_clxy/Patch_70/patched/org/jfree/data/xy/XYSeries.java\t2019-07-19 02:04:42.069900828 -0400\n@@ -556,17 +556,8 @@\n             existing.setY(y);\n         }\n         else {\n-            // if the series is sorted, the negative index is a result from\n-            // Collections.binarySearch() and tells us where to insert the\n-            // new item...otherwise it will be just -1 and we should just\n-            // append the value to the list...\n-            if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n-            }\n-            else {\n-                this.data.add(new XYDataItem(x, y));\n-            }\n-            // check if this addition will exceed the maximum item count...\n+            this.data.add(new XYDataItem(x, y));\n+\t\t\t// check if this addition will exceed the maximum item count...\n             if (getItemCount() > this.maximumItemCount) {\n                 this.data.remove(0);\n             }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 77,
    "bugId": 6,
    "name": "Patch_1_1",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/data/xy/XYSeries.java b/source/org/jfree/data/xy/XYSeries.java\nindex 0b37e6e..edb3cb0 100644\n--- a/source/org/jfree/data/xy/XYSeries.java\n+++ b/source/org/jfree/data/xy/XYSeries.java\n@@ -524,7 +524,7 @@ public class XYSeries extends Series implements Cloneable, Serializable {\n      * @since 1.0.10\n      */\n     public XYDataItem addOrUpdate(double x, double y) {\n-        return addOrUpdate(new Double(x), new Double(y));\n+        return addOrUpdate(new Double(y), new Double(y));\n     }\n \n     /**\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 77,
    "bugId": 6,
    "name": "Patch_3_3",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Chart_5/source/org/jfree/data/xy/XYSeriesjava\n+++ /tmp/jKali_Defects4J_Chart_5/source/org/jfree/data/xy/XYSeriesjava\n@@ -560,7 +560,7 @@\n \n \n \n-\t\t\tif (this.autoSort) {\n+\t\t\tif (false) {\n \t\t\t\tthis.data.add(((-index) - 1), new org.jfree.data.xy.XYDataItem(x, y));\n \t\t\t}else \n \t\t\t{\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 77,
    "bugId": 6,
    "name": "Patch_37_27",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Chart_5/source/org/jfree/data/xy/XYSeriesjava\n+++ /tmp/jGenProg_Defects4J_Chart_5/source/org/jfree/data/xy/XYSeriesjava\n@@ -560,8 +560,8 @@\n \n \n \n-\t\t\tif (this.autoSort) {\n-\t\t\t\tthis.data.add(((-index) - 1), new org.jfree.data.xy.XYDataItem(x, y));\n+\t\t\tif (this.autoSort) { \t\t\t\tadd(x, y, true);\n+\n \t\t\t}else \n \t\t\t{\n \t\t\t\tthis.data.add(new org.jfree.data.xy.XYDataItem(x, y));\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 77,
    "bugId": 6,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "--- a/source/org/jfree/data/xy/XYSeries.java\n+++ b/source/org/jfree/data/xy/XYSeries.java\n@@ -562,3 +562,3 @@\n             // append the value to the list...\n-            if (this.autoSort) {\n+            if (overwritten!=null) {\n                 this.data.add(-index - 1, new XYDataItem(x, y));\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 77,
    "bugId": 6,
    "name": "Patch_100_32",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/data/xy/XYSeries.java b/source/org/jfree/data/xy/XYSeries.java\nindex 0b37e6e..c57053b 100644\n--- a/source/org/jfree/data/xy/XYSeries.java\n+++ b/source/org/jfree/data/xy/XYSeries.java\n@@ -560,7 +560,7 @@ public class XYSeries extends Series implements Cloneable, Serializable {\n             // Collections.binarySearch() and tells us where to insert the\n             // new item...otherwise it will be just -1 and we should just\n             // append the value to the list...\n-            if (this.autoSort) {\n+            if ((index >= 0 && !this.allowDuplicateXValues)) {\n                 this.data.add(-index - 1, new XYDataItem(x, y));\n             }\n             else {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 77,
    "bugId": 6,
    "name": "Patch_52_1",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/data/xy/XYSeries.java b/source/org/jfree/data/xy/XYSeries.java\nindex 0b37e6e..deb2dad 100644\n--- a/source/org/jfree/data/xy/XYSeries.java\n+++ b/source/org/jfree/data/xy/XYSeries.java\n@@ -524,7 +524,7 @@ public class XYSeries extends Series implements Cloneable, Serializable {\n      * @since 1.0.10\n      */\n     public XYDataItem addOrUpdate(double x, double y) {\n-        return addOrUpdate(new Double(x), new Double(y));\n+        return addOrUpdate(new Double(getItemCount()), new Double(y));\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 77,
    "bugId": 6,
    "name": "Patch_440_130",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Chart_5/source/org/jfree/data/xy/XYSeries.java\t2019-07-29 23:48:29.867968543 -0400\n+++ /tmp/RSRepair_Defects4J_Chart_5/patches_1jzm/Patch_130/patched/org/jfree/data/xy/XYSeries.java\t2019-07-30 00:06:13.391705145 -0400\n@@ -556,16 +556,7 @@\n             existing.setY(y);\n         }\n         else {\n-            // if the series is sorted, the negative index is a result from\n-            // Collections.binarySearch() and tells us where to insert the\n-            // new item...otherwise it will be just -1 and we should just\n-            // append the value to the list...\n-            if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n-            }\n-            else {\n-                this.data.add(new XYDataItem(x, y));\n-            }\n+            this.data.add(new XYDataItem(x, y));\n             // check if this addition will exceed the maximum item count...\n             if (getItemCount() > this.maximumItemCount) {\n                 this.data.remove(0);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 77,
    "bugId": 6,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Chart_5/source/org/jfree/data/xy/XYSeries.java\t2018-12-01 18:57:57.662993256 -0500\n+++ /tmp/Kali_Defects4J_Chart_5/patches_ifcn/Patch_2/patched/tmp/Kali_Defects4J_Chart_5/source/org/jfree/data/xy/XYSeries.java\t2018-12-01 18:59:35.858996573 -0500\n@@ -560,7 +560,7 @@\n             // Collections.binarySearch() and tells us where to insert the\n             // new item...otherwise it will be just -1 and we should just\n             // append the value to the list...\n-            if (this.autoSort) {\n+            if (false) {\n                 this.data.add(-index - 1, new XYDataItem(x, y));\n             }\n             else {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 78,
    "bugId": 380,
    "name": "Patch_15_15",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java\n+++ b/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java\n@@ -308,8 +308,10 @@\n     {\n-        if (fromYear <= toYear) {\n-            OfYear ofYear = new OfYear\n+        if (nameKey.length() != 0) {\n+            if (fromYear <= toYear) {\n+                OfYear ofYear = new OfYear\n                 (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n-            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);\n-            Rule rule = new Rule(recurrence, fromYear, toYear);\n-            getLastRuleSet().addRule(rule);\n+                Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);\n+                Rule rule = new Rule(recurrence, fromYear, toYear);\n+                getLastRuleSet().addRule(rule);\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 78,
    "bugId": 380,
    "name": "Patch_5839_1807",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\nindex 6efe071..7182c1d 100644\n--- a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n+++ b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\n@@ -75,7 +75,7 @@ public class ZoneInfoCompiler {\n      * @return true to log verbosely\n      */\n     public static boolean verbose() {\n-        return cVerbose.get();\n+        return cVerbose != null || cVerbose.get();\n     }\n \n     //-----------------------------------------------------------------------",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 79,
    "bugId": 17,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "--- a/source/org/jfree/chart/JFreeChart.java\n+++ b/source/org/jfree/chart/JFreeChart.java\n@@ -1218,3 +1218,5 @@\n         }\n-        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\n+        if (false) {\n+            this.plot.draw(g2, plotArea, anchor, null, plotInfo);\n+        }\n ",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 79,
    "bugId": 17,
    "name": "Patch_16_14",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_15/source/org/jfree/chart/ChartFactory.java\t2019-07-19 07:08:29.349859522 -0400\n+++ /tmp/Arja_Defects4J_Chart_15/patches_rx8d/Patch_14/patched/org/jfree/chart/ChartFactory.java\t2019-07-19 07:19:01.833858089 -0400\n@@ -691,7 +691,7 @@\n                                               boolean tooltips,\n                                               boolean urls) {\n \n-        PiePlot3D plot = new PiePlot3D(dataset);\n+        PiePlot plot = new PiePlot(dataset);\n         plot.setInsets(new RectangleInsets(0.0, 5.0, 5.0, 5.0));\n         if (tooltips) {\n             plot.setToolTipGenerator(new StandardPieToolTipGenerator());\n\n\n--- /tmp/Arja_Defects4J_Chart_15/source/org/jfree/chart/plot/PiePlot.java\t2019-07-19 07:08:34.593859510 -0400\n+++ /tmp/Arja_Defects4J_Chart_15/patches_rx8d/Patch_14/patched/org/jfree/chart/plot/PiePlot.java\t2019-07-19 07:19:01.853858089 -0400\n@@ -2047,7 +2047,7 @@\n             PiePlot plot, Integer index, PlotRenderingInfo info) {\n      \n         PiePlotState state = new PiePlotState(info);\n-        state.setPassesRequired(2);\n+        g2.setPaint(Color.gray);\n             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                     plot.getDataset()));\n         state.setLatestAngle(plot.getStartAngle());\n@@ -2610,7 +2610,7 @@\n \n         LegendItemCollection result = new LegendItemCollection();\n         if (this.dataset == null) {\n-            return result;\n+            return null;\n         }\n         List keys = this.dataset.getKeys();\n         int section = 0;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 79,
    "bugId": 17,
    "name": "Patch_253_51",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/PiePlot3D.java b/source/org/jfree/chart/plot/PiePlot3D.java\nindex e8fbaf2..02babeb 100644\n--- a/source/org/jfree/chart/plot/PiePlot3D.java\n+++ b/source/org/jfree/chart/plot/PiePlot3D.java\n@@ -209,386 +209,7 @@ public class PiePlot3D extends PiePlot implements Serializable {\n         notifyListeners(new PlotChangeEvent(this));\n     }\n \n-    /**\n-     * Draws the plot on a Java 2D graphics device (such as the screen or a \n-     * printer).  This method is called by the \n-     * {@link org.jfree.chart.JFreeChart} class, you don't normally need \n-     * to call it yourself.\n-     *\n-     * @param g2  the graphics device.\n-     * @param plotArea  the area within which the plot should be drawn.\n-     * @param anchor  the anchor point.\n-     * @param parentState  the state from the parent plot, if there is one.\n-     * @param info  collects info about the drawing \n-     *              (<code>null</code> permitted).\n-     */\n-    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor,\n-                     PlotState parentState,\n-                     PlotRenderingInfo info) {\n-\n-        // adjust for insets...\n-        RectangleInsets insets = getInsets();\n-        insets.trim(plotArea);\n-\n-        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone();\n-        if (info != null) {\n-            info.setPlotArea(plotArea);\n-            info.setDataArea(plotArea);\n-        }\n-\n-        drawBackground(g2, plotArea);\n-\n-        Shape savedClip = g2.getClip();\n-        g2.clip(plotArea);\n-\n-        // adjust the plot area by the interior spacing value\n-        double gapPercent = getInteriorGap();\n-        double labelPercent = 0.0;\n-        if (getLabelGenerator() != null) {\n-            labelPercent = getLabelGap() + getMaximumLabelWidth();   \n-        }\n-        double gapHorizontal = plotArea.getWidth() * (gapPercent \n-                + labelPercent) * 2.0;\n-        double gapVertical = plotArea.getHeight() * gapPercent * 2.0;\n-\n-        if (DEBUG_DRAW_INTERIOR) {\n-            double hGap = plotArea.getWidth() * getInteriorGap();\n-            double vGap = plotArea.getHeight() * getInteriorGap();\n-            double igx1 = plotArea.getX() + hGap;\n-            double igx2 = plotArea.getMaxX() - hGap;\n-            double igy1 = plotArea.getY() + vGap;\n-            double igy2 = plotArea.getMaxY() - vGap;\n-            g2.setPaint(Color.lightGray);\n-            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \n-                    igy2 - igy1));\n-        }\n-\n-        double linkX = plotArea.getX() + gapHorizontal / 2;\n-        double linkY = plotArea.getY() + gapVertical / 2;\n-        double linkW = plotArea.getWidth() - gapHorizontal;\n-        double linkH = plotArea.getHeight() - gapVertical;\n-        \n-        // make the link area a square if the pie chart is to be circular...\n-        if (isCircular()) { // is circular?\n-            double min = Math.min(linkW, linkH) / 2;\n-            linkX = (linkX + linkX + linkW) / 2 - min;\n-            linkY = (linkY + linkY + linkH) / 2 - min;\n-            linkW = 2 * min;\n-            linkH = 2 * min;\n-        }\n-        \n-        PiePlotState state = initialise(g2, plotArea, this, null, info);\n-\n-        // the link area defines the dog leg points for the linking lines to \n-        // the labels\n-        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, \n-                linkH * (1 - this.depthFactor));\n-        state.setLinkArea(linkAreaXX);\n-\n-        if (DEBUG_DRAW_LINK_AREA) {\n-            g2.setPaint(Color.blue);\n-            g2.draw(linkAreaXX);\n-            g2.setPaint(Color.yellow);\n-            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), \n-                    linkAreaXX.getWidth(), linkAreaXX.getHeight()));\n-        }\n-        \n-        // the explode area defines the max circle/ellipse for the exploded pie \n-        // sections.\n-        // it is defined by shrinking the linkArea by the linkMargin factor.\n-        double hh = linkW * getLabelLinkMargin();\n-        double vv = linkH * getLabelLinkMargin();\n-        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \n-                linkY + vv / 2.0, linkW - hh, linkH - vv);\n-       \n-        state.setExplodedPieArea(explodeArea);\n-        \n-        // the pie area defines the circle/ellipse for regular pie sections.\n-        // it is defined by shrinking the explodeArea by the explodeMargin \n-        // factor. \n-        double maximumExplodePercent = getMaximumExplodePercent();\n-        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\n-        \n-        double h1 = explodeArea.getWidth() * percent;\n-        double v1 = explodeArea.getHeight() * percent;\n-        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \n-                + h1 / 2.0, explodeArea.getY() + v1 / 2.0,\n-                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\n-\n-        // the link area defines the dog-leg point for the linking lines to \n-        // the labels\n-        int depth = (int) (pieArea.getHeight() * this.depthFactor);\n-        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \n-                linkH - depth);\n-        state.setLinkArea(linkArea);   \n-\n-        state.setPieArea(pieArea);\n-        state.setPieCenterX(pieArea.getCenterX());\n-        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0);\n-        state.setPieWRadius(pieArea.getWidth() / 2.0);\n-        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0);\n-\n-        // get the data source - return if null;\n-        PieDataset dataset = getDataset();\n-        if (DatasetUtilities.isEmptyOrNull(getDataset())) {\n-            drawNoDataMessage(g2, plotArea);\n-            g2.setClip(savedClip);\n-            drawOutline(g2, plotArea);\n-            return;\n-        }\n-\n-        // if too any elements\n-        if (dataset.getKeys().size() > plotArea.getWidth()) {\n-            String text = \"Too many elements\";\n-            Font sfont = new Font(\"dialog\", Font.BOLD, 10);\n-            g2.setFont(sfont);\n-            FontMetrics fm = g2.getFontMetrics(sfont);\n-            int stringWidth = fm.stringWidth(text);\n-\n-            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() \n-                    - stringWidth) / 2), (int) (plotArea.getY() \n-                    + (plotArea.getHeight() / 2)));\n-            return;\n-        }\n-        // if we are drawing a perfect circle, we need to readjust the top left\n-        // coordinates of the drawing area for the arcs to arrive at this\n-        // effect.\n-        if (isCircular()) {\n-            double min = Math.min(plotArea.getWidth(), \n-                    plotArea.getHeight()) / 2;\n-            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, \n-                    plotArea.getCenterY() - min, 2 * min, 2 * min);\n-        }\n-        // get a list of keys...\n-        List sectionKeys = dataset.getKeys();\n-\n-        if (sectionKeys.size() == 0) {\n-            return;\n-        }\n-\n-        // establish the coordinates of the top left corner of the drawing area\n-        double arcX = pieArea.getX();\n-        double arcY = pieArea.getY();\n-\n-        //g2.clip(clipArea);\n-        Composite originalComposite = g2.getComposite();\n-        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n-                getForegroundAlpha()));\n-\n-        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset);\n-        double runningTotal = 0;\n-        if (depth < 0) {\n-            return;  // if depth is negative don't draw anything\n-        }\n-\n-        ArrayList arcList = new ArrayList();\n-        Arc2D.Double arc;\n-        Paint paint;\n-        Paint outlinePaint;\n-        Stroke outlineStroke;\n-\n-        Iterator iterator = sectionKeys.iterator();\n-        while (iterator.hasNext()) {\n-\n-            Comparable currentKey = (Comparable) iterator.next();\n-            Number dataValue = dataset.getValue(currentKey);\n-            if (dataValue == null) {\n-                arcList.add(null);\n-                continue;\n-            }\n-            double value = dataValue.doubleValue();\n-            if (value <= 0) {\n-                arcList.add(null);\n-                continue;\n-            }\n-            double startAngle = getStartAngle();\n-            double direction = getDirection().getFactor();\n-            double angle1 = startAngle + (direction * (runningTotal * 360)) \n-                    / totalValue;\n-            double angle2 = startAngle + (direction * (runningTotal + value) \n-                    * 360) / totalValue;\n-            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) {\n-                arcList.add(new Arc2D.Double(arcX, arcY + depth, \n-                        pieArea.getWidth(), pieArea.getHeight() - depth,\n-                        angle1, angle2 - angle1, Arc2D.PIE));\n-            }\n-            else {\n-                arcList.add(null);\n-            }\n-            runningTotal += value;\n-        }\n-\n-        Shape oldClip = g2.getClip();\n-\n-        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), \n-                pieArea.getWidth(), pieArea.getHeight() - depth);\n-\n-        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() \n-                + depth, pieArea.getWidth(), pieArea.getHeight() - depth);\n-\n-        Rectangle2D lower = new Rectangle2D.Double(top.getX(), \n-                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() \n-                - top.getCenterY());\n-\n-        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), \n-                pieArea.getWidth(), bottom.getCenterY() - top.getY());\n-\n-        Area a = new Area(top);\n-        a.add(new Area(lower));\n-        Area b = new Area(bottom);\n-        b.add(new Area(upper));\n-        Area pie = new Area(a);\n-        pie.intersect(b);\n-\n-        Area front = new Area(pie);\n-        front.subtract(new Area(top));\n-\n-        Area back = new Area(pie);\n-        back.subtract(new Area(bottom));\n-\n-        // draw the bottom circle\n-        int[] xs;\n-        int[] ys;\n-        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), \n-                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE);\n-\n-        int categoryCount = arcList.size();\n-        for (int categoryIndex = 0; categoryIndex < categoryCount; \n-                 categoryIndex++) {\n-            arc = (Arc2D.Double) arcList.get(categoryIndex);\n-            if (arc == null) {\n-                continue;\n-            }\n-            Comparable key = getSectionKey(categoryIndex);\n-            paint = lookupSectionPaint(key, true);\n-            outlinePaint = lookupSectionOutlinePaint(key);\n-            outlineStroke = lookupSectionOutlineStroke(key);\n-            g2.setPaint(paint);\n-            g2.fill(arc);\n-            g2.setPaint(outlinePaint);\n-            g2.setStroke(outlineStroke);\n-            g2.draw(arc);\n-            g2.setPaint(paint);\n-\n-            Point2D p1 = arc.getStartPoint();\n-\n-            // draw the height\n-            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(),\n-                    (int) p1.getX(), (int) p1.getX()};\n-            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() \n-                    - depth, (int) p1.getY() - depth, (int) p1.getY()};\n-            Polygon polygon = new Polygon(xs, ys, 4);\n-            g2.setPaint(java.awt.Color.lightGray);\n-            g2.fill(polygon);\n-            g2.setPaint(outlinePaint);\n-            g2.setStroke(outlineStroke);\n-            g2.draw(polygon);\n-            g2.setPaint(paint);\n-\n-        }\n-\n-        g2.setPaint(Color.gray);\n-        g2.fill(back);\n-        g2.fill(front);\n-\n-        // cycle through once drawing only the sides at the back...\n-        int cat = 0;\n-        iterator = arcList.iterator();\n-        while (iterator.hasNext()) {\n-            Arc2D segment = (Arc2D) iterator.next();\n-            if (segment != null) {\n-                Comparable key = getSectionKey(cat);\n-                paint = lookupSectionPaint(key, true);\n-                outlinePaint = lookupSectionOutlinePaint(key);\n-                outlineStroke = lookupSectionOutlineStroke(key);\n-                drawSide(g2, pieArea, segment, front, back, paint, \n-                        outlinePaint, outlineStroke, false, true);\n-            }\n-            cat++;\n-        }\n-\n-        // cycle through again drawing only the sides at the front...\n-        cat = 0;\n-        iterator = arcList.iterator();\n-        while (iterator.hasNext()) {\n-            Arc2D segment = (Arc2D) iterator.next();\n-            if (segment != null) {\n-                Comparable key = getSectionKey(cat);\n-                paint = lookupSectionPaint(key);\n-                outlinePaint = lookupSectionOutlinePaint(key);\n-                outlineStroke = lookupSectionOutlineStroke(key);\n-                drawSide(g2, pieArea, segment, front, back, paint, \n-                        outlinePaint, outlineStroke, true, false);\n-            }\n-            cat++;\n-        }\n-\n-        g2.setClip(oldClip);\n-\n-        // draw the sections at the top of the pie (and set up tooltips)...\n-        Arc2D upperArc;\n-        for (int sectionIndex = 0; sectionIndex < categoryCount; \n-                 sectionIndex++) {\n-            arc = (Arc2D.Double) arcList.get(sectionIndex);\n-            if (arc == null) {\n-                continue;\n-            }\n-            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(),\n-                    pieArea.getHeight() - depth, arc.getAngleStart(), \n-                    arc.getAngleExtent(), Arc2D.PIE);\n-            \n-            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex);\n-            paint = lookupSectionPaint(currentKey, true);\n-            outlinePaint = lookupSectionOutlinePaint(currentKey);\n-            outlineStroke = lookupSectionOutlineStroke(currentKey);\n-            g2.setPaint(paint);\n-            g2.fill(upperArc);\n-            g2.setStroke(outlineStroke);\n-            g2.setPaint(outlinePaint);\n-            g2.draw(upperArc);\n-\n-           // add a tooltip for the section...\n-            if (info != null) {\n-                EntityCollection entities \n-                        = info.getOwner().getEntityCollection();\n-                if (entities != null) {\n-                    String tip = null;\n-                    PieToolTipGenerator tipster = getToolTipGenerator();\n-                    if (tipster != null) {\n-                        // @mgs: using the method's return value was missing \n-                        tip = tipster.generateToolTip(dataset, currentKey);\n-                    }\n-                    String url = null;\n-                    if (getURLGenerator() != null) {\n-                        url = getURLGenerator().generateURL(dataset, currentKey,\n-                                getPieIndex());\n-                    }\n-                    PieSectionEntity entity = new PieSectionEntity(\n-                            upperArc, dataset, getPieIndex(), sectionIndex, \n-                            currentKey, tip, url);\n-                    entities.add(entity);\n-                }\n-            }\n-            List keys = dataset.getKeys();\n-            Rectangle2D adjustedPlotArea = new Rectangle2D.Double(\n-                    originalPlotArea.getX(), originalPlotArea.getY(), \n-                    originalPlotArea.getWidth(), originalPlotArea.getHeight() \n-                    - depth);\n-            if (getSimpleLabels()) {\n-                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, \n-                        linkArea, state);\n-            }\n-            else {\n-                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, \n-                        state);\n-            }\n-        }\n-\n-        g2.setClip(savedClip);\n-        g2.setComposite(originalComposite);\n-        drawOutline(g2, originalPlotArea);\n-\n-    }\n+    \n \n     /**\n      * Draws the side of a pie section.\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 79,
    "bugId": 17,
    "name": "Patch_564_218",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/PiePlot3D.java b/source/org/jfree/chart/plot/PiePlot3D.java\nindex e8fbaf2..24e39c1 100644\n--- a/source/org/jfree/chart/plot/PiePlot3D.java\n+++ b/source/org/jfree/chart/plot/PiePlot3D.java\n@@ -277,7 +277,10 @@ public class PiePlot3D extends PiePlot implements Serializable {\n             linkH = 2 * min;\n         }\n         \n-        PiePlotState state = initialise(g2, plotArea, this, null, info);\n+        if (info == null) {\n+    return;\n+}\n+PiePlotState state = initialise(g2, plotArea, this, null, info);\n \n         // the link area defines the dog leg points for the linking lines to \n         // the labels",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 79,
    "bugId": 17,
    "name": "Patch_564_218",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/PiePlot3D.java b/source/org/jfree/chart/plot/PiePlot3D.java\nindex e8fbaf2..24e39c1 100644\n--- a/source/org/jfree/chart/plot/PiePlot3D.java\n+++ b/source/org/jfree/chart/plot/PiePlot3D.java\n@@ -277,7 +277,10 @@ public class PiePlot3D extends PiePlot implements Serializable {\n             linkH = 2 * min;\n         }\n         \n-        PiePlotState state = initialise(g2, plotArea, this, null, info);\n+        if (info == null) {\n+    return;\n+}\n+PiePlotState state = initialise(g2, plotArea, this, null, info);\n \n         // the link area defines the dog leg points for the linking lines to \n         // the labels",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 79,
    "bugId": 17,
    "name": "Patch_220_119",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/PiePlot3D.java b/source/org/jfree/chart/plot/PiePlot3D.java\nindex e8fbaf2..02babeb 100644\n--- a/source/org/jfree/chart/plot/PiePlot3D.java\n+++ b/source/org/jfree/chart/plot/PiePlot3D.java\n@@ -209,386 +209,7 @@ public class PiePlot3D extends PiePlot implements Serializable {\n         notifyListeners(new PlotChangeEvent(this));\n     }\n \n-    /**\n-     * Draws the plot on a Java 2D graphics device (such as the screen or a \n-     * printer).  This method is called by the \n-     * {@link org.jfree.chart.JFreeChart} class, you don't normally need \n-     * to call it yourself.\n-     *\n-     * @param g2  the graphics device.\n-     * @param plotArea  the area within which the plot should be drawn.\n-     * @param anchor  the anchor point.\n-     * @param parentState  the state from the parent plot, if there is one.\n-     * @param info  collects info about the drawing \n-     *              (<code>null</code> permitted).\n-     */\n-    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor,\n-                     PlotState parentState,\n-                     PlotRenderingInfo info) {\n-\n-        // adjust for insets...\n-        RectangleInsets insets = getInsets();\n-        insets.trim(plotArea);\n-\n-        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone();\n-        if (info != null) {\n-            info.setPlotArea(plotArea);\n-            info.setDataArea(plotArea);\n-        }\n-\n-        drawBackground(g2, plotArea);\n-\n-        Shape savedClip = g2.getClip();\n-        g2.clip(plotArea);\n-\n-        // adjust the plot area by the interior spacing value\n-        double gapPercent = getInteriorGap();\n-        double labelPercent = 0.0;\n-        if (getLabelGenerator() != null) {\n-            labelPercent = getLabelGap() + getMaximumLabelWidth();   \n-        }\n-        double gapHorizontal = plotArea.getWidth() * (gapPercent \n-                + labelPercent) * 2.0;\n-        double gapVertical = plotArea.getHeight() * gapPercent * 2.0;\n-\n-        if (DEBUG_DRAW_INTERIOR) {\n-            double hGap = plotArea.getWidth() * getInteriorGap();\n-            double vGap = plotArea.getHeight() * getInteriorGap();\n-            double igx1 = plotArea.getX() + hGap;\n-            double igx2 = plotArea.getMaxX() - hGap;\n-            double igy1 = plotArea.getY() + vGap;\n-            double igy2 = plotArea.getMaxY() - vGap;\n-            g2.setPaint(Color.lightGray);\n-            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \n-                    igy2 - igy1));\n-        }\n-\n-        double linkX = plotArea.getX() + gapHorizontal / 2;\n-        double linkY = plotArea.getY() + gapVertical / 2;\n-        double linkW = plotArea.getWidth() - gapHorizontal;\n-        double linkH = plotArea.getHeight() - gapVertical;\n-        \n-        // make the link area a square if the pie chart is to be circular...\n-        if (isCircular()) { // is circular?\n-            double min = Math.min(linkW, linkH) / 2;\n-            linkX = (linkX + linkX + linkW) / 2 - min;\n-            linkY = (linkY + linkY + linkH) / 2 - min;\n-            linkW = 2 * min;\n-            linkH = 2 * min;\n-        }\n-        \n-        PiePlotState state = initialise(g2, plotArea, this, null, info);\n-\n-        // the link area defines the dog leg points for the linking lines to \n-        // the labels\n-        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, \n-                linkH * (1 - this.depthFactor));\n-        state.setLinkArea(linkAreaXX);\n-\n-        if (DEBUG_DRAW_LINK_AREA) {\n-            g2.setPaint(Color.blue);\n-            g2.draw(linkAreaXX);\n-            g2.setPaint(Color.yellow);\n-            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), \n-                    linkAreaXX.getWidth(), linkAreaXX.getHeight()));\n-        }\n-        \n-        // the explode area defines the max circle/ellipse for the exploded pie \n-        // sections.\n-        // it is defined by shrinking the linkArea by the linkMargin factor.\n-        double hh = linkW * getLabelLinkMargin();\n-        double vv = linkH * getLabelLinkMargin();\n-        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \n-                linkY + vv / 2.0, linkW - hh, linkH - vv);\n-       \n-        state.setExplodedPieArea(explodeArea);\n-        \n-        // the pie area defines the circle/ellipse for regular pie sections.\n-        // it is defined by shrinking the explodeArea by the explodeMargin \n-        // factor. \n-        double maximumExplodePercent = getMaximumExplodePercent();\n-        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\n-        \n-        double h1 = explodeArea.getWidth() * percent;\n-        double v1 = explodeArea.getHeight() * percent;\n-        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \n-                + h1 / 2.0, explodeArea.getY() + v1 / 2.0,\n-                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\n-\n-        // the link area defines the dog-leg point for the linking lines to \n-        // the labels\n-        int depth = (int) (pieArea.getHeight() * this.depthFactor);\n-        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \n-                linkH - depth);\n-        state.setLinkArea(linkArea);   \n-\n-        state.setPieArea(pieArea);\n-        state.setPieCenterX(pieArea.getCenterX());\n-        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0);\n-        state.setPieWRadius(pieArea.getWidth() / 2.0);\n-        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0);\n-\n-        // get the data source - return if null;\n-        PieDataset dataset = getDataset();\n-        if (DatasetUtilities.isEmptyOrNull(getDataset())) {\n-            drawNoDataMessage(g2, plotArea);\n-            g2.setClip(savedClip);\n-            drawOutline(g2, plotArea);\n-            return;\n-        }\n-\n-        // if too any elements\n-        if (dataset.getKeys().size() > plotArea.getWidth()) {\n-            String text = \"Too many elements\";\n-            Font sfont = new Font(\"dialog\", Font.BOLD, 10);\n-            g2.setFont(sfont);\n-            FontMetrics fm = g2.getFontMetrics(sfont);\n-            int stringWidth = fm.stringWidth(text);\n-\n-            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() \n-                    - stringWidth) / 2), (int) (plotArea.getY() \n-                    + (plotArea.getHeight() / 2)));\n-            return;\n-        }\n-        // if we are drawing a perfect circle, we need to readjust the top left\n-        // coordinates of the drawing area for the arcs to arrive at this\n-        // effect.\n-        if (isCircular()) {\n-            double min = Math.min(plotArea.getWidth(), \n-                    plotArea.getHeight()) / 2;\n-            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, \n-                    plotArea.getCenterY() - min, 2 * min, 2 * min);\n-        }\n-        // get a list of keys...\n-        List sectionKeys = dataset.getKeys();\n-\n-        if (sectionKeys.size() == 0) {\n-            return;\n-        }\n-\n-        // establish the coordinates of the top left corner of the drawing area\n-        double arcX = pieArea.getX();\n-        double arcY = pieArea.getY();\n-\n-        //g2.clip(clipArea);\n-        Composite originalComposite = g2.getComposite();\n-        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n-                getForegroundAlpha()));\n-\n-        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset);\n-        double runningTotal = 0;\n-        if (depth < 0) {\n-            return;  // if depth is negative don't draw anything\n-        }\n-\n-        ArrayList arcList = new ArrayList();\n-        Arc2D.Double arc;\n-        Paint paint;\n-        Paint outlinePaint;\n-        Stroke outlineStroke;\n-\n-        Iterator iterator = sectionKeys.iterator();\n-        while (iterator.hasNext()) {\n-\n-            Comparable currentKey = (Comparable) iterator.next();\n-            Number dataValue = dataset.getValue(currentKey);\n-            if (dataValue == null) {\n-                arcList.add(null);\n-                continue;\n-            }\n-            double value = dataValue.doubleValue();\n-            if (value <= 0) {\n-                arcList.add(null);\n-                continue;\n-            }\n-            double startAngle = getStartAngle();\n-            double direction = getDirection().getFactor();\n-            double angle1 = startAngle + (direction * (runningTotal * 360)) \n-                    / totalValue;\n-            double angle2 = startAngle + (direction * (runningTotal + value) \n-                    * 360) / totalValue;\n-            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) {\n-                arcList.add(new Arc2D.Double(arcX, arcY + depth, \n-                        pieArea.getWidth(), pieArea.getHeight() - depth,\n-                        angle1, angle2 - angle1, Arc2D.PIE));\n-            }\n-            else {\n-                arcList.add(null);\n-            }\n-            runningTotal += value;\n-        }\n-\n-        Shape oldClip = g2.getClip();\n-\n-        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), \n-                pieArea.getWidth(), pieArea.getHeight() - depth);\n-\n-        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() \n-                + depth, pieArea.getWidth(), pieArea.getHeight() - depth);\n-\n-        Rectangle2D lower = new Rectangle2D.Double(top.getX(), \n-                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() \n-                - top.getCenterY());\n-\n-        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), \n-                pieArea.getWidth(), bottom.getCenterY() - top.getY());\n-\n-        Area a = new Area(top);\n-        a.add(new Area(lower));\n-        Area b = new Area(bottom);\n-        b.add(new Area(upper));\n-        Area pie = new Area(a);\n-        pie.intersect(b);\n-\n-        Area front = new Area(pie);\n-        front.subtract(new Area(top));\n-\n-        Area back = new Area(pie);\n-        back.subtract(new Area(bottom));\n-\n-        // draw the bottom circle\n-        int[] xs;\n-        int[] ys;\n-        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), \n-                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE);\n-\n-        int categoryCount = arcList.size();\n-        for (int categoryIndex = 0; categoryIndex < categoryCount; \n-                 categoryIndex++) {\n-            arc = (Arc2D.Double) arcList.get(categoryIndex);\n-            if (arc == null) {\n-                continue;\n-            }\n-            Comparable key = getSectionKey(categoryIndex);\n-            paint = lookupSectionPaint(key, true);\n-            outlinePaint = lookupSectionOutlinePaint(key);\n-            outlineStroke = lookupSectionOutlineStroke(key);\n-            g2.setPaint(paint);\n-            g2.fill(arc);\n-            g2.setPaint(outlinePaint);\n-            g2.setStroke(outlineStroke);\n-            g2.draw(arc);\n-            g2.setPaint(paint);\n-\n-            Point2D p1 = arc.getStartPoint();\n-\n-            // draw the height\n-            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(),\n-                    (int) p1.getX(), (int) p1.getX()};\n-            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() \n-                    - depth, (int) p1.getY() - depth, (int) p1.getY()};\n-            Polygon polygon = new Polygon(xs, ys, 4);\n-            g2.setPaint(java.awt.Color.lightGray);\n-            g2.fill(polygon);\n-            g2.setPaint(outlinePaint);\n-            g2.setStroke(outlineStroke);\n-            g2.draw(polygon);\n-            g2.setPaint(paint);\n-\n-        }\n-\n-        g2.setPaint(Color.gray);\n-        g2.fill(back);\n-        g2.fill(front);\n-\n-        // cycle through once drawing only the sides at the back...\n-        int cat = 0;\n-        iterator = arcList.iterator();\n-        while (iterator.hasNext()) {\n-            Arc2D segment = (Arc2D) iterator.next();\n-            if (segment != null) {\n-                Comparable key = getSectionKey(cat);\n-                paint = lookupSectionPaint(key, true);\n-                outlinePaint = lookupSectionOutlinePaint(key);\n-                outlineStroke = lookupSectionOutlineStroke(key);\n-                drawSide(g2, pieArea, segment, front, back, paint, \n-                        outlinePaint, outlineStroke, false, true);\n-            }\n-            cat++;\n-        }\n-\n-        // cycle through again drawing only the sides at the front...\n-        cat = 0;\n-        iterator = arcList.iterator();\n-        while (iterator.hasNext()) {\n-            Arc2D segment = (Arc2D) iterator.next();\n-            if (segment != null) {\n-                Comparable key = getSectionKey(cat);\n-                paint = lookupSectionPaint(key);\n-                outlinePaint = lookupSectionOutlinePaint(key);\n-                outlineStroke = lookupSectionOutlineStroke(key);\n-                drawSide(g2, pieArea, segment, front, back, paint, \n-                        outlinePaint, outlineStroke, true, false);\n-            }\n-            cat++;\n-        }\n-\n-        g2.setClip(oldClip);\n-\n-        // draw the sections at the top of the pie (and set up tooltips)...\n-        Arc2D upperArc;\n-        for (int sectionIndex = 0; sectionIndex < categoryCount; \n-                 sectionIndex++) {\n-            arc = (Arc2D.Double) arcList.get(sectionIndex);\n-            if (arc == null) {\n-                continue;\n-            }\n-            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(),\n-                    pieArea.getHeight() - depth, arc.getAngleStart(), \n-                    arc.getAngleExtent(), Arc2D.PIE);\n-            \n-            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex);\n-            paint = lookupSectionPaint(currentKey, true);\n-            outlinePaint = lookupSectionOutlinePaint(currentKey);\n-            outlineStroke = lookupSectionOutlineStroke(currentKey);\n-            g2.setPaint(paint);\n-            g2.fill(upperArc);\n-            g2.setStroke(outlineStroke);\n-            g2.setPaint(outlinePaint);\n-            g2.draw(upperArc);\n-\n-           // add a tooltip for the section...\n-            if (info != null) {\n-                EntityCollection entities \n-                        = info.getOwner().getEntityCollection();\n-                if (entities != null) {\n-                    String tip = null;\n-                    PieToolTipGenerator tipster = getToolTipGenerator();\n-                    if (tipster != null) {\n-                        // @mgs: using the method's return value was missing \n-                        tip = tipster.generateToolTip(dataset, currentKey);\n-                    }\n-                    String url = null;\n-                    if (getURLGenerator() != null) {\n-                        url = getURLGenerator().generateURL(dataset, currentKey,\n-                                getPieIndex());\n-                    }\n-                    PieSectionEntity entity = new PieSectionEntity(\n-                            upperArc, dataset, getPieIndex(), sectionIndex, \n-                            currentKey, tip, url);\n-                    entities.add(entity);\n-                }\n-            }\n-            List keys = dataset.getKeys();\n-            Rectangle2D adjustedPlotArea = new Rectangle2D.Double(\n-                    originalPlotArea.getX(), originalPlotArea.getY(), \n-                    originalPlotArea.getWidth(), originalPlotArea.getHeight() \n-                    - depth);\n-            if (getSimpleLabels()) {\n-                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, \n-                        linkArea, state);\n-            }\n-            else {\n-                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, \n-                        state);\n-            }\n-        }\n-\n-        g2.setClip(savedClip);\n-        g2.setComposite(originalComposite);\n-        drawOutline(g2, originalPlotArea);\n-\n-    }\n+    \n \n     /**\n      * Draws the side of a pie section.",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 79,
    "bugId": 17,
    "name": "Patch_17_17",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Chart_15/source/org/jfree/chart/plot/PiePlot3D.java\t2018-12-01 18:52:46.650539916 -0500\n+++ /tmp/Kali_Defects4J_Chart_15/patches_dkr6/Patch_17/patched/tmp/Kali_Defects4J_Chart_15/source/org/jfree/chart/plot/PiePlot3D.java\t2018-12-01 18:54:47.442528590 -0500\n@@ -277,7 +277,9 @@\n             linkH = 2 * min;\n         }\n         \n-        PiePlotState state = initialise(g2, plotArea, this, null, info);\n+        if (true)\n+\t\t\treturn;\n+\t\tPiePlotState state = initialise(g2, plotArea, this, null, info);\n \n         // the link area defines the dog leg points for the linking lines to \n         // the labels\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 80,
    "bugId": 272,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -665,4 +665,8 @@\n             entries.put(index, value);\n-        } else if (entries.containsKey(index)) {\n-            entries.remove(index);\n+        } else {\n+            if (this.DEFAULT_ZERO_TOLERANCE == this.epsilon) {\n+                if (entries.containsKey(index)) {\n+                    entries.remove(index);\n+                }\n+            }\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 80,
    "bugId": 272,
    "name": "Patch_15_1",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/MathRuntimeException.java b/src/main/java/org/apache/commons/math/MathRuntimeException.java\nindex ce2d352..a19d14c 100644\n--- a/src/main/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/main/java/org/apache/commons/math/MathRuntimeException.java\n@@ -129,7 +129,7 @@ public class MathRuntimeException extends RuntimeException implements MathThrowa\n      */\n     private static String buildMessage(final Locale locale, final Localizable pattern,\n                                        final Object ... arguments) {\n-        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments);\n+        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale);\n     }\n \n     /** Gets the message in a specified locale.\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 80,
    "bugId": 272,
    "name": "Patch_22_16",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Math_49/src/main/java/org/apache/commons/math/linear/OpenMapRealVectorjava\n+++ /tmp/jKali_Defects4J_Math_49/src/main/java/org/apache/commons/math/linear/OpenMapRealVectorjava\n@@ -661,10 +661,10 @@\n \n \tpublic void setEntry(int index, double value) {\n \t\tcheckIndex(index);\n-\t\tif (!(isDefaultValue(value))) {\n-\t\t\tentries.put(index, value);\n-\t\t}else \t\t\tif (entries.containsKey(index)) {\n-\t\t\t\tentries.remove(index);\n+\t\tif (true) {\n+\t\t\tthis.entries.put(index, value);\n+\t\t}else \t\t\tif (this.entries.containsKey(index)) {\n+\t\t\t\tthis.entries.remove(index);\n \t\t\t}\n \t}\n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 80,
    "bugId": 272,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -665,4 +665,8 @@\n             entries.put(index, value);\n-        } else if (entries.containsKey(index)) {\n-            entries.remove(index);\n+        } else {\n+            if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) {\n+                if (entries.containsKey(index)) {\n+                    entries.remove(index);\n+                }\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 80,
    "bugId": 272,
    "name": "Patch_2_1",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/MathRuntimeException.java b/src/main/java/org/apache/commons/math/MathRuntimeException.java\nindex ce2d352..a19d14c 100644\n--- a/src/main/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/main/java/org/apache/commons/math/MathRuntimeException.java\n@@ -129,7 +129,7 @@ public class MathRuntimeException extends RuntimeException implements MathThrowa\n      */\n     private static String buildMessage(final Locale locale, final Localizable pattern,\n                                        final Object ... arguments) {\n-        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments);\n+        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale);\n     }\n \n     /** Gets the message in a specified locale.",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 80,
    "bugId": 272,
    "name": "Patch_7_7",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Math_49/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\t2018-12-01 17:08:14.175600876 -0500\n+++ /tmp/Kali_Defects4J_Math_49/patches_kb7n/Patch_7/patched/tmp/Kali_Defects4J_Math_49/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\t2018-12-01 17:19:11.413853881 -0500\n@@ -661,7 +661,7 @@\n     /** {@inheritDoc} */\n     public void setEntry(int index, double value) {\n         checkIndex(index);\n-        if (!isDefaultValue(value)) {\n+        if (true) {\n             entries.put(index, value);\n         } else if (entries.containsKey(index)) {\n             entries.remove(index);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 81,
    "bugId": 244,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -786,3 +786,3 @@\n             }\n-            if (max(diagD) > 1e14 * min(diagD)) {\n+            if (this.dimension == 1) {\n                 double tfac = max(diagD) / 1e14 - min(diagD);\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 81,
    "bugId": 244,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex 4b7dbf6..463dff0 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -237,7 +237,7 @@ public class CMAESOptimizer\n      * Default constructor, uses default parameters\n      */\n     public CMAESOptimizer() {\n-        this(0);\n+        \n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 81,
    "bugId": 244,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -703,3 +703,5 @@\n             double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);\n-            oldFac += 1. - ccov1 - ccovmu;\n+            if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) {\n+                oldFac += 1. - ccov1 - ccovmu;\n+            }\n             if (isActiveCMA) {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 82,
    "bugId": 211,
    "name": "Patch_1_1",
    "tool": "DynaMoth",
    "diff": "--- a/src/java/org/apache/commons/lang/BooleanUtils.java\n+++ b/src/java/org/apache/commons/lang/BooleanUtils.java\n@@ -671,6 +671,6 @@\n                 char ch = str.charAt(0);\n-                if (ch == 'y') {\n-                    return \n-                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n-                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n+                if (true) {\n+                    return\n+                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n+                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 82,
    "bugId": 211,
    "name": "Patch_120_90",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/BooleanUtils.java b/src/java/org/apache/commons/lang/BooleanUtils.java\nindex 3fda4ec..7f10329 100644\n--- a/src/java/org/apache/commons/lang/BooleanUtils.java\n+++ b/src/java/org/apache/commons/lang/BooleanUtils.java\n@@ -674,11 +674,9 @@ public class BooleanUtils {\n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n-                if (ch == 'Y') {\n-                    return \n+                return \n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n-                }\n             }\n             case 4: {\n                 char ch = str.charAt(0);\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 82,
    "bugId": 211,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "--- a/src/java/org/apache/commons/lang/BooleanUtils.java\n+++ b/src/java/org/apache/commons/lang/BooleanUtils.java\n@@ -671,6 +671,6 @@\n                 char ch = str.charAt(0);\n-                if (ch == 'y') {\n-                    return \n-                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n-                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n+                if (str!=null) {\n+                    return\n+                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n+                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 82,
    "bugId": 211,
    "name": "Patch_83_75",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/BooleanUtils.java b/src/java/org/apache/commons/lang/BooleanUtils.java\nindex 3fda4ec..de9c104 100644\n--- a/src/java/org/apache/commons/lang/BooleanUtils.java\n+++ b/src/java/org/apache/commons/lang/BooleanUtils.java\n@@ -669,7 +669,7 @@ public class BooleanUtils {\n             }\n             case 3: {\n                 char ch = str.charAt(0);\n-                if (ch == 'y') {\n+                if ((ch == 'y') || !(ch == 'Y')) {\n                     return \n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 82,
    "bugId": 211,
    "name": "Patch_180_129",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/BooleanUtils.java b/src/java/org/apache/commons/lang/BooleanUtils.java\nindex 3fda4ec..d063a90 100644\n--- a/src/java/org/apache/commons/lang/BooleanUtils.java\n+++ b/src/java/org/apache/commons/lang/BooleanUtils.java\n@@ -669,7 +669,7 @@ public class BooleanUtils {\n             }\n             case 3: {\n                 char ch = str.charAt(0);\n-                if (ch == 'y') {\n+                if (ch<='y') {\n                     return \n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 83,
    "bugId": 325,
    "name": "Patch_13_13",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 766d87e..4ef9a60 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -135,8 +135,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n+if (sign >= 0&&!(sign<=(double)0.413505)) {            // check if either value is close to a zero\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw new IllegalArgumentException\n                 (\"Function values at endpoints do not have different signs.\" +",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 84,
    "bugId": 280,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\nindex 148daad..c225e86 100644\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.commons.math.distribution;\n+package org.apache.commons.math.distribution;import  org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n import java.io.Serializable;\n \n@@ -91,7 +91,7 @@ public class PoissonDistributionImpl extends AbstractIntegerDistribution\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n+if (p <= 0){throw new NotStrictlyPositiveException(null);}            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 85,
    "bugId": 315,
    "name": "Patch_5_5",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex 7d8aa4d..1bdade6 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -25,6 +25,13 @@ import java.util.Arrays;\n  * @version $Revision$ $Date$\n  */\n public final class MathUtils {\n+private static long patch_method(int n){\n+  long result=1;\n+  for (int i=2; i <= n; i++) {\n+    result*=i;\n+  }\n+  return result;\n+}\n \n     /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */\n     public static final double EPSILON = 0x1.0p-53;\n@@ -374,7 +381,7 @@ public final class MathUtils {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n         }\n-        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n+if (n<(int)20.0){return patch_method(n);}        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }\n \n     /**",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 86,
    "bugId": 318,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex 75914d7..97d0346 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -130,7 +130,7 @@ public class Frequency implements Serializable {\n                 freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n             }\n         } catch (ClassCastException ex) {   \n-            //TreeMap will throw ClassCastException if v is not comparable\n+if (!(v instanceof Comparable<?>)){throw new ClassCastException();}            //TreeMap will throw ClassCastException if v is not comparable\n             throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n         }\n     }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 87,
    "bugId": 183,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 4a1d845..445ce73 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -1409,7 +1409,7 @@ public class NumberUtils {\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n-                // not allowing L with an exponent or decimal point\n+if (hasDecPoint==true){return false;}                // not allowing L with an exponent or decimal point\n                 return foundDigit && !hasExp;\n             }\n             // last character is illegal",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 87,
    "bugId": 183,
    "name": "Patch_6785_5804",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 4a1d845..43ff40c 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -1392,7 +1392,8 @@ public class NumberUtils {\n                 // can't have an E at the last byte\n                 return false;\n             }\n-            if (chars[i] == '.') {\n+            if ((chars[i] == '.') || (chars[i] == 'l'\n+                || chars[i] == 'L')) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 87,
    "bugId": 183,
    "name": "Patch_2414_1931",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 4a1d845..43ff40c 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -1392,7 +1392,8 @@ public class NumberUtils {\n                 // can't have an E at the last byte\n                 return false;\n             }\n-            if (chars[i] == '.') {\n+            if ((chars[i] == '.') || (chars[i] == 'l'\n+                || chars[i] == 'L')) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 88,
    "bugId": 250,
    "name": "Patch_2_2",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\nindex 1da2c45..09a999f 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n@@ -324,7 +324,7 @@ public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> {\n                     // procedure cannot produce sensible results.\n \n                 a = FastMath.sqrt(c1 / c2);\n-                omega = FastMath.sqrt(c2 / c3);\n+if (c2==0.0){throw new MathIllegalStateException();}                omega = FastMath.sqrt(c2 / c3);\n             }\n         }\n ",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 89,
    "bugId": 383,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/joda/time/field/FieldUtils.java b/src/main/java/org/joda/time/field/FieldUtils.java\nindex a0fe7e2..10cb24c 100644\n--- a/src/main/java/org/joda/time/field/FieldUtils.java\n+++ b/src/main/java/org/joda/time/field/FieldUtils.java\n@@ -135,7 +135,7 @@ public class FieldUtils {\n     public static long safeMultiply(long val1, int val2) {\n         switch (val2) {\n             case -1:\n-                return -val1;\n+if (val1==Long.MIN_VALUE){throw new ArithmeticException();}                return -val1;\n             case 0:\n                 return 0L;\n             case 1:",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_116_32",
    "tool": "ACS",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..4945860 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,7 +2163,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+if (markers == null){return false;}        boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n@@ -2444,7 +2444,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+if (markers == null){return false;}        boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\ndiff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..a6234ab 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,7 +2290,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+if (markers == null){return false;}        boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n@@ -2526,7 +2526,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+if (markers == null){return false;}        boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_972_738",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_14/source/org/jfree/chart/plot/CategoryPlot.java\t2019-07-19 06:10:38.765867387 -0400\n+++ /tmp/Arja_Defects4J_Chart_14/patches_unzb/Patch_738/patched/org/jfree/chart/plot/CategoryPlot.java\t2019-07-19 07:08:25.985859530 -0400\n@@ -2156,8 +2156,7 @@\n     \t\tboolean notify) {\n         ArrayList markers;\n         if (layer == Layer.FOREGROUND) {\n-            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n-                    index));\n+            return this.rangeCrosshairVisible;\n         }\n         else {\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n@@ -2375,7 +2374,7 @@\n      * @see #addRangeMarker(Marker)\n      */\n     public boolean removeRangeMarker(Marker marker) {\n-        return removeRangeMarker(marker, Layer.FOREGROUND);\n+        return this.rangeCrosshairVisible;\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Chart_14/source/org/jfree/chart/plot/XYPlot.java\t2019-07-19 06:10:38.777867387 -0400\n+++ /tmp/Arja_Defects4J_Chart_14/patches_unzb/Patch_738/patched/org/jfree/chart/plot/XYPlot.java\t2019-07-19 07:08:26.009859529 -0400\n@@ -2262,7 +2262,7 @@\n      * @since 1.0.7\n      */\n     public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n-    \treturn removeDomainMarker(index, marker, layer, true);\n+    \treturn this.domainZeroBaselineVisible;\n     }\n \n     /**\n@@ -2478,7 +2478,7 @@\n      * @since 1.0.7\n      */\n     public boolean removeRangeMarker(Marker marker, Layer layer) {\n-        return removeRangeMarker(0, marker, layer);\n+        return false;\n     }\n \n     /**\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_1181_109",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..8399cea 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2526,7 +2526,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_560_34",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..c10fd5a 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,7 +2290,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_1573_139",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..d997068 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,7 +2163,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_1534_138",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..bafca56 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2156,7 +2156,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n     \t\tboolean notify) {\n         ArrayList markers;\n         if (layer == Layer.FOREGROUND) {\n-            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n+            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n         else {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_1574_511",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..165b1c1 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,7 +2163,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_1102_358",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..5cacbc6 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2526,7 +2526,10 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_1940_564",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..6a1df48 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2437,7 +2437,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             throw new IllegalArgumentException(\"Null 'marker' argument.\");\n         }\n         ArrayList markers;\n-        if (layer == Layer.FOREGROUND) {\n+        if (layer != Layer.FOREGROUND) {\n             markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                     index));\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_538_171",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..74dfab4 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,7 +2290,10 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_1574_511",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..165b1c1 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,7 +2163,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_1102_358",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..5cacbc6 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2526,7 +2526,10 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_1940_564",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..6a1df48 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2437,7 +2437,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             throw new IllegalArgumentException(\"Null 'marker' argument.\");\n         }\n         ArrayList markers;\n-        if (layer == Layer.FOREGROUND) {\n+        if (layer != Layer.FOREGROUND) {\n             markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                     index));\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_538_171",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..74dfab4 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,7 +2290,10 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_2669_616",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..b2e1e8b 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2163,7 +2163,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = getAnnotations().remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_2631_615",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex dc7d06b..bafca56 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2156,7 +2156,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n     \t\tboolean notify) {\n         ArrayList markers;\n         if (layer == Layer.FOREGROUND) {\n-            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n+            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n         else {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_974_207",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..3a361b2 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2290,7 +2290,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = getAnnotations().remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 90,
    "bugId": 15,
    "name": "Patch_2034_473",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex 50cf416..ed59298 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -2526,7 +2526,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = getAnnotations().remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 91,
    "bugId": 195,
    "name": "Patch_4_4",
    "tool": "ACS",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/ArrayUtils.java b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\nindex ac22f8f..d3e9ab5 100644\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -3297,7 +3297,7 @@ public class ArrayUtils {\n         @SuppressWarnings(\"unchecked\") // type must be T\n         T[] newArray = (T[]) copyArrayGrow1(array, type);\n         newArray[newArray.length - 1] = element;\n-        return newArray;\n+if (element == null){throw new IllegalArgumentException();}        return newArray;\n     }\n \n     /**\n@@ -3571,7 +3571,7 @@ public class ArrayUtils {\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n-            return (T[]) new Object[] { null };\n+if (element == null){throw new IllegalArgumentException();}            return (T[]) new Object[] { null };\n         }\n         @SuppressWarnings(\"unchecked\") // the add method creates an array of type clss, which is type T\n         final T[] newArray = (T[]) add(array, index, element, clss)",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 92,
    "bugId": 21,
    "name": "Patch_6_4",
    "tool": "ACS",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..8b96d93 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,7 +695,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        return this.domainAxes.indexOf(axis);\n+if (axis == null){throw new IllegalArgumentException();}        return this.domainAxes.indexOf(axis);\n     }\n     \n     /**\n@@ -978,7 +978,7 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n                 result = p.getRangeAxisIndex(axis);\n             }\n         }\n-        return result;\n+if (axis == null){throw new IllegalArgumentException();}        return result;\n     }\n     \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 92,
    "bugId": 21,
    "name": "Patch_169_155",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Chart_19/source/org/jfree/chart/util/AbstractObjectList.java\t2019-07-19 11:54:43.125820603 -0400\n+++ /tmp/Arja_Defects4J_Chart_19/patches_mg6q/Patch_155/patched/org/jfree/chart/util/AbstractObjectList.java\t2019-07-19 12:15:29.205817779 -0400\n@@ -161,7 +161,10 @@\n                 return (index);\n             }\n         }\n-        return -1;\n+        if (object == null) {\n+\t\t\tthrow new IllegalArgumentException(\"Null 'object' argument.\");\n+\t\t}\n+\t\treturn -1;\n     }\n \n     /**\n\n\n--- /tmp/Arja_Defects4J_Chart_19/source/org/jfree/chart/plot/CategoryPlot.java\t2019-07-19 11:54:48.221820592 -0400\n+++ /tmp/Arja_Defects4J_Chart_19/patches_mg6q/Patch_155/patched/org/jfree/chart/plot/CategoryPlot.java\t2019-07-19 12:15:29.225817779 -0400\n@@ -657,9 +657,9 @@\n             axis.setPlot(this);\n         }\n         this.domainAxes.set(index, axis);\n-        if (axis != null) {\n+        this.weight = weight;\n+\t\tif (axis != null) {\n             axis.configure();\n-            axis.addChangeListener(this);\n         }\n         if (notify) {\n             notifyListeners(new PlotChangeEvent(this));\n@@ -924,11 +924,16 @@\n      */\n     public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n         ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n-        if (existing != null) {\n+        this.orientation = PlotOrientation.VERTICAL;\n+\t\tif (existing != null) {\n             existing.removeChangeListener(this);\n         }\n         if (axis != null) {\n-            axis.setPlot(this);\n+            if (axis != null) {\n+\t\t\t\taxis.setPlot(this);\n+\t\t\t\taxis.addChangeListener(this);\n+\t\t\t}\n+\t\t\taxis.setPlot(this);\n         }\n         this.rangeAxes.set(index, axis);\n         if (axis != null) {\n@@ -970,7 +975,8 @@\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        int result = this.rangeAxes.indexOf(axis);\n+        this.rangeGridlinesVisible = true;\n+\t\tint result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n             if (parent instanceof CategoryPlot) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 92,
    "bugId": 21,
    "name": "Patch_81_49",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..5f38aed 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,7 +695,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        return this.domainAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+}\n+return this.domainAxes.indexOf(axis);\n     }\n     \n     /**\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 92,
    "bugId": 21,
    "name": "Patch_164_98",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..b81a415 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -970,7 +970,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        int result = this.rangeAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+}\n+int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n             if (parent instanceof CategoryPlot) {\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 92,
    "bugId": 21,
    "name": "Patch_51_49",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..5f38aed 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,7 +695,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        return this.domainAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+}\n+return this.domainAxes.indexOf(axis);\n     }\n     \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 92,
    "bugId": 21,
    "name": "Patch_56_52",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..b81a415 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -970,7 +970,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        int result = this.rangeAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+}\n+int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n             if (parent instanceof CategoryPlot) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 92,
    "bugId": 21,
    "name": "Patch_51_49",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..5f38aed 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,7 +695,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        return this.domainAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+}\n+return this.domainAxes.indexOf(axis);\n     }\n     \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 92,
    "bugId": 21,
    "name": "Patch_56_52",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..b81a415 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -970,7 +970,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        int result = this.rangeAxes.indexOf(axis);\n+        if (axis == null) {\n+    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+}\n+int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n             if (parent instanceof CategoryPlot) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 92,
    "bugId": 21,
    "name": "Patch_68_59",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..fa80ec2 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -695,7 +695,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        return this.domainAxes.indexOf(axis);\n+        if (axis == null) {\n+\t    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+\t}\n+return this.domainAxes.indexOf(axis);\n     }\n     \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 92,
    "bugId": 21,
    "name": "Patch_143_118",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex cf3f52f..a51c0a9 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -970,7 +970,10 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        int result = this.rangeAxes.indexOf(axis);\n+        if (axis == null) {\n+\t    throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+\t}\n+int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n             if (parent instanceof CategoryPlot) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 93,
    "bugId": 236,
    "name": "Patch_2_2",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\nindex a146cb6..ee8f12b 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n@@ -112,7 +112,7 @@ public class SubLine {\n         // compute the intersection on infinite line\n         Vector3D v1D = line.intersection(subLine.line);\n \n-        // check location of point with respect to first sub-line\n+if (v1D == null){return null;}        // check location of point with respect to first sub-line\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n \n         // check location of point with respect to second sub-line\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\nindex a9d621a..0b1b07e 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n@@ -116,7 +116,7 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {\n         // compute the intersection on infinite line\n         Vector2D v2D = line1.intersection(line2);\n \n-        // check location of point with respect to first sub-line\n+if (v2D == null){return null;}        // check location of point with respect to first sub-line\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n \n         // check location of point with respect to second sub-line",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 93,
    "bugId": 236,
    "name": "Patch_284_96",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\nindex a146cb6..ea79097 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n@@ -113,7 +113,10 @@ public class SubLine {\n         Vector3D v1D = line.intersection(subLine.line);\n \n         // check location of point with respect to first sub-line\n-        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n+        if (v1D == null) {\n+    return null;\n+}\n+Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n \n         // check location of point with respect to second sub-line\n         Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 93,
    "bugId": 236,
    "name": "Patch_221_71",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\nindex a9d621a..c7ebae9 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n@@ -117,7 +117,10 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {\n         Vector2D v2D = line1.intersection(line2);\n \n         // check location of point with respect to first sub-line\n-        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n+        if (v2D == null) {\n+    return null;\n+}\n+Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n \n         // check location of point with respect to second sub-line\n         Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 93,
    "bugId": 236,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Line.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/Line.java\n@@ -199,3 +199,5 @@\n         if (FastMath.abs(d) < 1.0e-10) {\n-            return null;\n+            if (((other.sin < 1) && (other.sin < 1)) || ((org.apache.commons.math3.geometry.euclidean.twod.Line.this.originOffset) != (d))) {\n+                return null;\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 94,
    "bugId": 254,
    "name": "Patch_2_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\nindex a84438d..5a9de5a 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -112,8 +112,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n \n         if (minRatioPositions.size() == 0) {\n             return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n+} else if (minRatioPositions.size() > 1&&!(minRatioPositions.size()>(double)0.0)) {            // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n                 for (Integer row : minRatioPositions) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 94,
    "bugId": 254,
    "name": "Patch_6_6",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-07-27 17:02:44.982829949 -0400\n+++ /tmp/Arja_Defects4J_Math_28/patches_blu4/Patch_6/patched/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-07-27 18:05:42.920952838 -0400\n@@ -142,7 +142,6 @@\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n-                                minIndex = i;\n                                 minRow = row;\n                             }\n                         }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 94,
    "bugId": 254,
    "name": "Patch_1_1",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n+++ /tmp/jMutRepair_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n@@ -140,7 +140,7 @@\n \t\t\t\tfor (java.lang.Integer row : minRatioPositions) {\n \t\t\t\t\tint i = tableau.getNumObjectiveFunctions();\n \t\t\t\t\tfor (; (i < ((tableau.getWidth()) - 1)) && (minRow != row); i++) {\n-\t\t\t\t\t\tif (row == (tableau.getBasicRow(i))) {\n+\t\t\t\t\t\tif (row != (tableau.getBasicRow(i))) {\n \t\t\t\t\t\t\tif (i < minIndex) {\n \t\t\t\t\t\t\t\tminIndex = i;\n \t\t\t\t\t\t\t\tminRow = row;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 94,
    "bugId": 254,
    "name": "Patch_5_4",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n+++ /tmp/jKali_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolverjava\n@@ -140,7 +140,7 @@\n \t\t\t\tfor (java.lang.Integer row : minRatioPositions) {\n \t\t\t\t\tint i = tableau.getNumObjectiveFunctions();\n \t\t\t\t\tfor (; (i < ((tableau.getWidth()) - 1)) && (minRow != row); i++) {\n-\t\t\t\t\t\tif (row == (tableau.getBasicRow(i))) {\n+\t\t\t\t\t\tif (true) {\n \t\t\t\t\t\t\tif (i < minIndex) {\n \t\t\t\t\t\t\t\tminIndex = i;\n \t\t\t\t\t\t\t\tminRow = row;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 94,
    "bugId": 254,
    "name": "Patch_28_11",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-08-01 00:48:50.626330166 -0400\n+++ /tmp/RSRepair_Defects4J_Math_28/patches_l2ve/Patch_11/patched/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-08-01 02:09:54.582588228 -0400\n@@ -148,7 +148,6 @@\n                         }\n                     }\n                 }\n-                return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 94,
    "bugId": 254,
    "name": "Patch_6_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-07-31 06:36:22.594645383 -0400\n+++ /tmp/GenProg_Defects4J_Math_28/patches_ghxi/Patch_1/patched/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2019-07-31 07:36:57.838545025 -0400\n@@ -142,7 +142,6 @@\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n-                                minIndex = i;\n                                 minRow = row;\n                             }\n                         }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 94,
    "bugId": 254,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 17:29:26.406627915 -0500\n+++ /tmp/Kali_Defects4J_Math_28/patches_5n7v/Patch_1/patched/tmp/Kali_Defects4J_Math_28/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\t2018-12-01 17:55:08.912495964 -0500\n@@ -140,7 +140,7 @@\n                 for (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n+                        if (true) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n                                 minRow = row;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 95,
    "bugId": 227,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 325fd94..7208bf8 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -843,7 +843,7 @@ public class MathArrays {\n \n \n         final double prodHighCur = prodHigh[0];\n-        double prodHighNext = prodHigh[1];\n+if (len==1.0){return a[0] * b[0];}        double prodHighNext = prodHigh[1];\n         double sHighPrev = prodHighCur + prodHighNext;\n         double sPrime = sHighPrev - prodHighNext;\n         double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 96,
    "bugId": 257,
    "name": "Patch_11_11",
    "tool": "ACS",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\nindex 67b368d..3e4ead8 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.commons.math3.genetics;\n+package org.apache.commons.math3.genetics;import  org.apache.commons.math3.exception.OutOfRangeException;import  org.apache.commons.math3.exception.OutOfRangeException;import  org\n \n import java.util.Collections;\n import java.util.List;\n@@ -48,7 +48,7 @@ public class ElitisticListPopulation extends ListPopulation {\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n-        this.elitismRate = elitismRate;\n+if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);}if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);}         this.elitismRate = elitismRate;\n     }\n \n     /**\n@@ -62,7 +62,7 @@ public class ElitisticListPopulation extends ListPopulation {\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n-        this.elitismRate = elitismRate;\n+if (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);}if (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);}        this.elitismRate = \n     }\n \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 96,
    "bugId": 257,
    "name": "Patch_303_303",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_35/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\t2019-07-28 03:45:19.759179973 -0400\n+++ /tmp/Arja_Defects4J_Math_35/patches_rvo9/Patch_303/patched/org/apache/commons/math3/genetics/ElitisticListPopulation.java\t2019-07-28 04:44:46.033213057 -0400\n@@ -48,7 +48,9 @@\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n-        this.elitismRate = elitismRate;\n+        if (elitismRate < 0 || elitismRate > 1) {\n+\t\t\tthrow new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1);\n+\t\t}\n     }\n \n     /**\n@@ -62,7 +64,10 @@\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n-        this.elitismRate = elitismRate;\n+        if (elitismRate < 0 || elitismRate > 1) {\n+\t\t\tthrow new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1);\n+\t\t}\n+\t\tthis.elitismRate = elitismRate;\n     }\n \n     /**\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 97,
    "bugId": 329,
    "name": "Patch_3_3",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex d51ec7a..89ee746 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -540,7 +540,7 @@ public final class MathUtils {\n         int u = p;\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n-            return (Math.abs(u) + Math.abs(v));\n+if (u==Integer.MIN_VALUE){throw new ArithmeticException();}if (v==Integer.MIN_VALUE){throw new ArithmeticException();}            return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n@@ -711,7 +711,7 @@ public final class MathUtils {\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n-        return lcm;\n+if (lcm==Integer.MIN_VALUE){throw new ArithmeticException();}        return lcm;\n     }\n \n     /** ",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 98,
    "bugId": 310,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex c8deca3..1887afe 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,7 +107,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+if (!(v instanceof Comparable<?>)){throw new IllegalArgumentException();}            addValue((Comparable<?>) v);            \n     }\n     \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 98,
    "bugId": 310,
    "name": "Patch_6_6",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex c8deca3..7ecb4f1 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,7 +107,12 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+            if (v instanceof Comparable<?>) {\n+\taddValue((Comparable<?>) v);\n+} else {\n+\tthrow new IllegalArgumentException(\"Illegal argument: v\");\n+}\n+            \n     }\n     \n     /**\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 98,
    "bugId": 310,
    "name": "Patch_12_11",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex c8deca3..7ecb4f1 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,7 +107,12 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+            if (v instanceof Comparable<?>) {\n+\taddValue((Comparable<?>) v);\n+} else {\n+\tthrow new IllegalArgumentException(\"Illegal argument: v\");\n+}\n+            \n     }\n     \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 98,
    "bugId": 310,
    "name": "Patch_14_12",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex c8deca3..bfe0188 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -107,7 +107,12 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+            if (v instanceof Comparable<?>) {\n+\taddValue((Comparable<?>) v);\n+\t} else {\n+\tthrow new IllegalArgumentException(\"Illegal argument: v\");\n+}\n+            \n     }\n     \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 99,
    "bugId": 165,
    "name": "Patch_1_1",
    "tool": "ACS",
    "diff": "\ndiff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex d49da7f..dc96426 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -450,7 +450,7 @@ public class NumberUtils {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n-            return null;\n+if (str.startsWith(\"--\")==true){throw new NumberFormatException();}            return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 99,
    "bugId": 165,
    "name": "Patch_219_193",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Lang_7/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\t2019-07-22 03:59:47.269723469 -0400\n+++ /tmp/Arja_Defects4J_Lang_7/patches_j21g/Patch_193/patched/org/apache/commons/lang3/event/EventListenerSupport.java\t2019-07-22 04:10:01.891393027 -0400\n@@ -138,7 +138,7 @@\n     public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n         this();\n         Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n-        Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n+        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n         Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\n                 listenerInterface.getName());\n         initializeTransientFields(listenerInterface, classLoader);\n@@ -274,7 +274,8 @@\n      * @param classLoader the class loader to be used\n      */\n     private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\n-        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\n+        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\", listenerInterface.getName());\n+\t\tproxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\n                 new Class[] { listenerInterface }, createInvocationHandler()));\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Lang_7/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2019-07-22 03:59:50.861752000 -0400\n+++ /tmp/Arja_Defects4J_Lang_7/patches_j21g/Patch_193/patched/org/apache/commons/lang3/math/NumberUtils.java\t2019-07-22 04:10:01.899393109 -0400\n@@ -450,7 +450,6 @@\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n-            return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 99,
    "bugId": 165,
    "name": "Patch_1065_498",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex d49da7f..efa89f0 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -449,9 +449,7 @@ public class NumberUtils {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n-        if (str.startsWith(\"--\")) {\n-            return null;\n-        }\n+        \n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n             if (str.startsWith(\"-\")) { // drop -\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 99,
    "bugId": 165,
    "name": "Patch_18_17",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Lang_7/src/main/java/org/apache/commons/lang3/math/NumberUtilsjava\n+++ /tmp/jKali_Defects4J_Lang_7/src/main/java/org/apache/commons/lang3/math/NumberUtilsjava\n@@ -450,7 +450,7 @@\n \t\t\tthrow new java.lang.NumberFormatException(\"A blank string is not a valid number\");\n \t\t}\n \t\tif (str.startsWith(\"--\")) {\n-\t\t\treturn null;\n+\n \t\t}\n \t\tif ((((str.startsWith(\"0x\")) || (str.startsWith(\"-0x\"))) || (str.startsWith(\"0X\"))) || (str.startsWith(\"-0X\"))) {\n \t\t\tint hexDigits = (str.length()) - 2;\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 99,
    "bugId": 165,
    "name": "Patch_3162_1871",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex d49da7f..7de6c49 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -446,7 +446,7 @@ public class NumberUtils {\n         if (str == null) {\n             return null;\n         }\n-        if (StringUtils.isBlank(str)) {\n+        if ((StringUtils.isBlank(str)) || (str.startsWith(\"--\"))) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 99,
    "bugId": 165,
    "name": "Patch_1504_1083",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex d49da7f..7de6c49 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -446,7 +446,7 @@ public class NumberUtils {\n         if (str == null) {\n             return null;\n         }\n-        if (StringUtils.isBlank(str)) {\n+        if ((StringUtils.isBlank(str)) || (str.startsWith(\"--\"))) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 99,
    "bugId": 165,
    "name": "Patch_208_103",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Lang_7/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2019-07-31 13:12:02.526321275 -0400\n+++ /tmp/RSRepair_Defects4J_Lang_7/patches_q0u3/Patch_103/patched/org/apache/commons/lang3/math/NumberUtils.java\t2019-07-31 13:21:29.488734736 -0400\n@@ -450,7 +450,7 @@\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n-            return null;\n+            return Short.parseShort(str);\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 99,
    "bugId": 165,
    "name": "Patch_40_21",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Lang_7/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2019-07-26 04:36:30.226708490 -0400\n+++ /tmp/GenProg_Defects4J_Lang_7/patches_sxic/Patch_21/patched/org/apache/commons/lang3/math/NumberUtils.java\t2019-07-26 04:43:30.312129025 -0400\n@@ -450,7 +450,8 @@\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n-            return null;\n+            Double d = createDouble(str);\n+\t\t\treturn null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 100,
    "bugId": 145,
    "name": "Patch_17_11",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_120/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\t2019-08-12 02:48:31.222396263 -0400\n+++ /tmp/Arja_Defects4J_Closure_120/patches_ukx3/Patch_11/patched/com/google/javascript/jscomp/GlobalVarReferenceMap.java\t2019-08-12 03:15:46.769170181 -0400\n@@ -81,9 +81,6 @@\n     refMap = Maps.newHashMap();\n     for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) {\n       Var var = entry.getKey();\n-      if (var.isGlobal()) {\n-        refMap.put(var.getName(), entry.getValue());\n-      }\n     }\n   }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 100,
    "bugId": 145,
    "name": "Patch_13_5",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_120/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2019-08-12 16:33:04.935843351 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_120/patches_gmns/Patch_5/patched/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2019-08-12 16:59:41.998474304 -0400\n@@ -182,7 +182,6 @@\n     if (t.getScope().isGlobal()) {\n       // Update global scope reference lists when we are done with it.\n       compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\n-      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\n     } else {\n       behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\n     }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 100,
    "bugId": 145,
    "name": "Patch_8_8",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_120/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:30:11.800514756 -0500\n+++ /tmp/Kali_Defects4J_Closure_120/patches_bneu/Patch_3/patched/tmp/Kali_Defects4J_Closure_120/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:34:28.181910821 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 101,
    "bugId": 80,
    "name": "Patch_81_59",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_59/src/com/google/javascript/jscomp/WarningLevel.java\t2019-08-11 21:09:32.482460285 -0400\n+++ /tmp/Arja_Defects4J_Closure_59/patches_m0ey/Patch_59/patched/com/google/javascript/jscomp/WarningLevel.java\t2019-08-11 21:34:43.810917450 -0400\n@@ -39,7 +39,7 @@\n         addDefaultWarnings(options);\n         break;\n       case VERBOSE:\n-        addVerboseWarnings(options);\n+        ;\n         break;\n       default:\n         throw new RuntimeException(\"Unknown warning level.\");\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 101,
    "bugId": 80,
    "name": "Patch_64_27",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_59/src/com/google/javascript/jscomp/WarningLevel.java\t2019-08-12 11:54:38.867374200 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_59/patches_1gmg/Patch_27/patched/com/google/javascript/jscomp/WarningLevel.java\t2019-08-12 12:18:02.868588357 -0400\n@@ -76,7 +76,6 @@\n \n     // checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run.\n     options.checkSuspiciousCode = true;\n-    options.checkGlobalThisLevel = CheckLevel.WARNING;\n     options.checkSymbols = true;\n     options.checkMissingReturn = CheckLevel.WARNING;\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 101,
    "bugId": 80,
    "name": "Patch_96_27",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_59/src/com/google/javascript/jscomp/WarningLevel.java\t2019-08-11 15:34:18.053197985 -0400\n+++ /tmp/GenProg_Defects4J_Closure_59/patches_imep/Patch_27/patched/com/google/javascript/jscomp/WarningLevel.java\t2019-08-11 15:58:32.008810285 -0400\n@@ -39,7 +39,7 @@\n         addDefaultWarnings(options);\n         break;\n       case VERBOSE:\n-        addVerboseWarnings(options);\n+        boolean valid = false;\n         break;\n       default:\n         throw new RuntimeException(\"Unknown warning level.\");\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 101,
    "bugId": 80,
    "name": "Patch_39_39",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_59/src/com/google/javascript/jscomp/DefaultPassConfig.java\t2018-12-01 20:03:32.314309418 -0500\n+++ /tmp/Kali_Defects4J_Closure_59/patches_z1hr/Patch_61/patched/tmp/Kali_Defects4J_Closure_59/src/com/google/javascript/jscomp/DefaultPassConfig.java\t2018-12-01 20:10:19.587488139 -0500\n@@ -260,7 +260,9 @@\n     if (options.checkTypes &&\n         (options.enables(DiagnosticGroups.ACCESS_CONTROLS)\n          || options.enables(DiagnosticGroups.CONSTANT_PROPERTY))) {\n-      checks.add(checkAccessControls);\n+      if (true)\n+\t\t\t\treturn null;\n+\tchecks.add(checkAccessControls);\n     }\n \n     if (options.checkGlobalNamesLevel.isOn()) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 102,
    "bugId": 81,
    "name": "Patch_18_8",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-11 20:47:01.346945154 -0400\n+++ /tmp/Arja_Defects4J_Closure_55/patches_e0jo/Patch_8/patched/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-11 21:09:29.730457780 -0400\n@@ -85,7 +85,6 @@\n       // Estimate savings\n       int savings = 0;\n       for (Reduction reduction : reductions) {\n-        savings += reduction.estimateSavings();\n       }\n \n       // Compare estimated savings against the helper cost.  Apply\n@@ -114,7 +113,7 @@\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+    return false;\n   }\n \n   /**\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 102,
    "bugId": 81,
    "name": "Patch_32_6",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-12 11:32:28.825170457 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_55/patches_83p1/Patch_6/patched/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-12 11:54:36.455406473 -0400\n@@ -87,18 +87,6 @@\n       for (Reduction reduction : reductions) {\n         savings += reduction.estimateSavings();\n       }\n-\n-      // Compare estimated savings against the helper cost.  Apply\n-      // reductions if doing so will result in some savings.\n-      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {\n-        for (Reduction reduction : reductions) {\n-          reduction.apply();\n-        }\n-\n-        Node addingRoot = compiler.getNodeForCodeInsertion(null);\n-        addingRoot.addChildrenToFront(helperCode);\n-        compiler.reportCodeChange();\n-      }\n     }\n   }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 102,
    "bugId": 81,
    "name": "Patch_1_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-11 15:10:13.561322801 -0400\n+++ /tmp/GenProg_Defects4J_Closure_55/patches_jmrq/Patch_1/patched/com/google/javascript/jscomp/FunctionRewriter.java\t2019-08-11 15:34:15.513268537 -0400\n@@ -63,11 +63,6 @@\n \n     Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n \n-    // Accumulate possible reductions in the reduction multi map.  They\n-    // will be applied in the loop below.\n-    NodeTraversal.traverse(compiler, root,\n-                           new ReductionGatherer(reducers, reductionMap));\n-\n     // Apply reductions iff they will provide some savings.\n     for (Reducer reducer : reducers) {\n       Collection<Reduction> reductions = reductionMap.get(reducer);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 102,
    "bugId": 81,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2018-12-01 20:04:55.583882688 -0500\n+++ /tmp/Kali_Defects4J_Closure_55/patches_u9rc/Patch_3/patched/tmp/Kali_Defects4J_Closure_55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2018-12-01 20:09:58.307042025 -0500\n@@ -76,7 +76,7 @@\n       }\n \n       Node helperCode = parseHelperCode(reducer);\n-      if (helperCode == null) {\n+      if (true) {\n         continue;\n       }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 103,
    "bugId": 225,
    "name": "Patch_21_15",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_2/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\t2019-07-25 03:26:20.766331389 -0400\n+++ /tmp/Arja_Defects4J_Math_2/patches_2d8v/Patch_15/patched/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\t2019-07-25 04:18:02.819682996 -0400\n@@ -134,9 +134,6 @@\n             }\n             k = 1.0 / k;\n             tmp = mu + k * sigma;\n-            if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n-            }\n         }\n \n         return solveInverseCumulativeProbability(p, lower, upper);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 103,
    "bugId": 225,
    "name": "Patch_367_117",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java b/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\nindex 78c588e..c5ac52d 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\n@@ -127,7 +127,7 @@ public abstract class AbstractIntegerDistribution implements IntegerDistribution\n         final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                 Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n         if (chebyshevApplies) {\n-            double k = FastMath.sqrt((1.0 - p) / p);\n+            double k = FastMath.sqrt((1.0 - upper) / p);\n             double tmp = mu - k * sigma;\n             if (tmp > lower) {\n                 lower = ((int) Math.ceil(tmp)) - 1;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 103,
    "bugId": 225,
    "name": "Patch_16_16",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Math_2/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistributionjava\n+++ /tmp/jMutRepair_Defects4J_Math_2/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistributionjava\n@@ -134,7 +134,7 @@\n \t\t\t}\n \t\t\tk = 1.0 / k;\n \t\t\ttmp = mu + (k * sigma);\n-\t\t\tif (tmp < upper) {\n+\t\t\tif (tmp >= upper) {\n \t\t\t\tupper = ((int) (java.lang.Math.ceil(tmp))) - 1;\n \t\t\t}\n \t\t}\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 103,
    "bugId": 225,
    "name": "Patch_23_18",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Math_2/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistributionjava\n+++ /tmp/jKali_Defects4J_Math_2/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistributionjava\n@@ -134,7 +134,7 @@\n \t\t\t}\n \t\t\tk = 1.0 / k;\n \t\t\ttmp = mu + (k * sigma);\n-\t\t\tif (tmp < upper) {\n+\t\t\tif (false) {\n \t\t\t\tupper = ((int) (java.lang.Math.ceil(tmp))) - 1;\n \t\t\t}\n \t\t}\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 103,
    "bugId": 225,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\n@@ -136,4 +136,6 @@\n             tmp = mu + k * sigma;\n-            if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n+            if (sigma == lower) {\n+                if (tmp < upper) {\n+                    upper = ((int) Math.ceil(tmp)) - 1;\n+                }\n             }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 103,
    "bugId": 225,
    "name": "Patch_155_56",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java b/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\nindex 78c588e..e95b393 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\n@@ -127,7 +127,7 @@ public abstract class AbstractIntegerDistribution implements IntegerDistribution\n         final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                 Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n         if (chebyshevApplies) {\n-            double k = FastMath.sqrt((1.0 - p) / p);\n+            double k = FastMath.sqrt(serialVersionUID);\n             double tmp = mu - k * sigma;\n             if (tmp > lower) {\n                 lower = ((int) Math.ceil(tmp)) - 1;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 103,
    "bugId": 225,
    "name": "Patch_468_285",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\nindex 2769127..59bb82b 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n@@ -290,8 +290,8 @@ public class HypergeometricDistribution extends AbstractIntegerDistribution {\n      */\n     protected double calculateNumericalVariance() {\n         final double N = getPopulationSize();\n-        final double m = getNumberOfSuccesses();\n-        final double n = getSampleSize();\n+        final int m = getNumberOfSuccesses();\n+        final int n = getSampleSize();\n         return (n * m * (N - n) * (N - m)) / (N * N * (N - 1));\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 103,
    "bugId": 225,
    "name": "Patch_134_37",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_2/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\t2019-08-02 18:44:13.742473777 -0400\n+++ /tmp/RSRepair_Defects4J_Math_2/patches_b6rx/Patch_37/patched/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\t2019-08-02 19:53:26.126036423 -0400\n@@ -134,9 +134,6 @@\n             }\n             k = 1.0 / k;\n             tmp = mu + k * sigma;\n-            if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n-            }\n         }\n \n         return solveInverseCumulativeProbability(p, lower, upper);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 103,
    "bugId": 225,
    "name": "Patch_35_11",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_2/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\t2019-07-29 04:18:02.648695844 -0400\n+++ /tmp/GenProg_Defects4J_Math_2/patches_fwqz/Patch_11/patched/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\t2019-07-29 05:03:10.569665590 -0400\n@@ -135,7 +135,6 @@\n             k = 1.0 / k;\n             tmp = mu + k * sigma;\n             if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n             }\n         }\n \n\n\n--- /tmp/GenProg_Defects4J_Math_2/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\t2019-07-29 04:18:02.676695848 -0400\n+++ /tmp/GenProg_Defects4J_Math_2/patches_fwqz/Patch_11/patched/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\t2019-07-29 05:03:10.601665967 -0400\n@@ -154,7 +154,8 @@\n \n         this.membershipMatrix = null;\n         this.points = null;\n-        this.clusters = null;\n+        boolean emptyCluster = false;\n+\t\tthis.clusters = null;\n     }\n \n     /**\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 103,
    "bugId": 225,
    "name": "Patch_6_6",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Math_2/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\t2018-12-01 18:09:20.555146778 -0500\n+++ /tmp/Kali_Defects4J_Math_2/patches_jbci/Patch_6/patched/tmp/Kali_Defects4J_Math_2/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java\t2018-12-01 18:29:12.670587072 -0500\n@@ -134,7 +134,7 @@\n             }\n             k = 1.0 / k;\n             tmp = mu + k * sigma;\n-            if (tmp < upper) {\n+            if (false) {\n                 upper = ((int) Math.ceil(tmp)) - 1;\n             }\n         }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 104,
    "bugId": 34,
    "name": "Patch_46_19",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_8/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\t2019-08-11 13:55:05.510546569 -0400\n+++ /tmp/Arja_Defects4J_Closure_8/patches_lr4t/Patch_19/patched/com/google/javascript/jscomp/CollapseVariableDeclarations.java\t2019-08-11 14:19:26.861953431 -0400\n@@ -114,7 +114,6 @@\n \n     if (!collapses.isEmpty()) {\n       applyCollapses();\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -207,40 +206,5 @@\n \n \n   private void applyCollapses() {\n-    for (Collapse collapse : collapses) {\n-\n-      Node var = new Node(Token.VAR);\n-      var.copyInformationFrom(collapse.startNode);\n-      collapse.parent.addChildBefore(var, collapse.startNode);\n-\n-      boolean redeclaration = false;\n-      for (Node n = collapse.startNode; n != collapse.endNode;) {\n-        Node next = n.getNext();\n-\n-        Preconditions.checkState(var.getNext() == n);\n-        collapse.parent.removeChildAfter(var);\n-\n-        if (n.isVar()) {\n-          while(n.hasChildren()) {\n-            var.addChildToBack(n.removeFirstChild());\n-          }\n-        } else {\n-          Node assign = n.getFirstChild();\n-          Node lhs = assign.getFirstChild();\n-          Preconditions.checkState(lhs.isName());\n-          Node rhs = assign.getLastChild();\n-          lhs.addChildToBack(rhs.detachFromParent());\n-          var.addChildToBack(lhs.detachFromParent());\n-          redeclaration = true;\n-        }\n-        n = next;\n-      }\n-\n-      if (redeclaration) {\n-        JSDocInfo info = new JSDocInfo();\n-        info.addSuppression(\"duplicate\");\n-        var.setJSDocInfo(info);\n-      }\n-    }\n   }\n }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 104,
    "bugId": 34,
    "name": "Patch_39_35",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_8/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:21:29.619699365 -0500\n+++ /tmp/Kali_Defects4J_Closure_8/patches_cpbc/Patch_31/patched/tmp/Kali_Defects4J_Closure_8/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:25:59.476001698 -0500\n@@ -1437,7 +1437,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 105,
    "bugId": 104,
    "name": "Patch_135_77",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_75/src/com/google/javascript/jscomp/CodeGenerator.java\t2019-08-11 22:14:06.518098223 -0400\n+++ /tmp/Arja_Defects4J_Closure_75/patches_tjoc/Patch_77/patched/com/google/javascript/jscomp/CodeGenerator.java\t2019-08-11 22:36:06.094679335 -0400\n@@ -1013,10 +1013,6 @@\n             if (c > 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n-              // Other characters can be misinterpreted by some js parsers,\n-              // or perhaps mangled by proxies along the way,\n-              // so we play it safe and unicode escape them.\n-              appendHexJavaScriptRepresentation(sb, c);\n             }\n           }\n       }\n@@ -1152,10 +1148,5 @@\n       appendHexJavaScriptRepresentation(surrogates[1], out);\n       return;\n     }\n-    out.append(\"\\\\u\")\n-        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])\n-        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n-        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n-        .append(HEX_CHARS[codePoint & 0xf]);\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_75/src/com/google/javascript/jscomp/NodeUtil.java\t2019-08-11 22:14:08.278210821 -0400\n+++ /tmp/Arja_Defects4J_Closure_75/patches_tjoc/Patch_77/patched/com/google/javascript/jscomp/NodeUtil.java\t2019-08-11 22:36:06.102679603 -0400\n@@ -346,7 +346,7 @@\n     }\n \n     try {\n-      return Double.parseDouble(s);\n+      return null;\n     } catch (NumberFormatException e) {\n       return Double.NaN;\n     }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 105,
    "bugId": 104,
    "name": "Patch_1277_304",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_75/src/com/google/javascript/jscomp/NodeUtil.java\t2019-08-12 13:10:38.418366411 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_75/patches_i3i2/Patch_304/patched/com/google/javascript/jscomp/NodeUtil.java\t2019-08-12 13:40:23.626479936 -0400\n@@ -298,7 +298,7 @@\n         break;\n \n       case Token.STRING:\n-        return getStringNumberValue(n.getString());\n+        break;\n \n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 105,
    "bugId": 104,
    "name": "Patch_128_47",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_75/src/com/google/javascript/rhino/Token.java\t2019-08-11 16:19:02.670625198 -0400\n+++ /tmp/GenProg_Defects4J_Closure_75/patches_mgrb/Patch_47/patched/com/google/javascript/rhino/Token.java\t2019-08-11 16:42:37.767316913 -0400\n@@ -300,7 +300,7 @@\n           case MOD:             return \"MOD\";\n           case NOT:             return \"NOT\";\n           case BITNOT:          return \"BITNOT\";\n-          case POS:             return \"POS\";\n+          case POS:             ;\n           case NEG:             return \"NEG\";\n           case NEW:             return \"NEW\";\n           case DELPROP:         return \"DELPROP\";\n\n\n--- /tmp/GenProg_Defects4J_Closure_75/src/com/google/javascript/jscomp/NodeUtil.java\t2019-08-11 16:19:04.506574198 -0400\n+++ /tmp/GenProg_Defects4J_Closure_75/patches_mgrb/Patch_47/patched/com/google/javascript/jscomp/NodeUtil.java\t2019-08-11 16:42:37.783316469 -0400\n@@ -372,7 +372,7 @@\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\n       case '\\u000B': // <VT>\n-        return TernaryValue.TRUE;\n+        ;\n       case ' ': // <SP>\n       case '\\n': // <LF>\n       case '\\r': // <CR>\n\n\n--- /tmp/GenProg_Defects4J_Closure_75/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-11 16:19:02.642625975 -0400\n+++ /tmp/GenProg_Defects4J_Closure_75/patches_mgrb/Patch_47/patched/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-11 16:42:37.799316025 -0400\n@@ -260,9 +260,6 @@\n     } else {\n       replacement = Node.newNumber(value);\n     }\n-\n-    n.getParent().replaceChild(n, replacement);\n-    reportCodeChange();\n   }\n \n   /**\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 105,
    "bugId": 104,
    "name": "Patch_5_5",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_75/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-01 19:59:12.215140786 -0500\n+++ /tmp/Kali_Defects4J_Closure_75/patches_l9sy/Patch_3/patched/tmp/Kali_Defects4J_Closure_75/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-01 20:03:28.632758076 -0500\n@@ -329,10 +329,7 @@\n       }\n     }\n \n-    if (s.length() > 3\n-        && (s.charAt(0) == '-' || s.charAt(0) == '+')\n-        && s.charAt(1) == '0'\n-        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n+    if (true) {\n       // hex numbers with explicit signs vary between browsers.\n       return null;\n     }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 106,
    "bugId": 182,
    "name": "Patch_288_287",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Lang_20/src/main/java/org/apache/commons/lang3/StringUtils.java\t2019-07-22 19:12:24.141842790 -0400\n+++ /tmp/Arja_Defects4J_Lang_20/patches_bjrb/Patch_287/patched/org/apache/commons/lang3/StringUtils.java\t2019-07-22 19:28:57.603445668 -0400\n@@ -3295,7 +3295,7 @@\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder(256);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n@@ -3380,7 +3380,7 @@\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n+        StringBuilder buf = new StringBuilder(256);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 106,
    "bugId": 182,
    "name": "Patch_455_139",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..919cc6a 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3295,7 +3295,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder((16) + 1);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 106,
    "bugId": 182,
    "name": "Patch_922_376",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..4441214 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3380,7 +3380,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n+        StringBuilder buf = new StringBuilder((16) + separator.length());\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 106,
    "bugId": 182,
    "name": "Patch_533_325",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..b80ac21 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3380,7 +3380,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n+        StringBuilder buf = new StringBuilder(noOfItems + separator.length());\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 106,
    "bugId": 182,
    "name": "Patch_282_124",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..7f1e65a 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3295,7 +3295,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder(noOfItems + 1);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 106,
    "bugId": 182,
    "name": "Patch_336_182",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..f079122 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3295,7 +3295,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder();\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 106,
    "bugId": 182,
    "name": "Patch_1220_617",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 3c2cf3f..a308c6e 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -3380,7 +3380,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n+        StringBuilder buf = new StringBuilder();\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 107,
    "bugId": 160,
    "name": "Patch_19_11",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_129/src/com/google/javascript/rhino/Node.java\t2019-08-12 05:53:09.542014571 -0400\n+++ /tmp/Arja_Defects4J_Closure_129/patches_v1fr/Patch_11/patched/com/google/javascript/rhino/Node.java\t2019-08-12 06:19:22.193288141 -0400\n@@ -1543,7 +1543,6 @@\n       }\n     } else if (type == Token.CALL) {\n       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n       }\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 107,
    "bugId": 160,
    "name": "Patch_25_21",
    "tool": "FixMiner",
    "diff": "diff --git a/src/com/google/javascript/rhino/Node.java b/src/com/google/javascript/rhino/Node.java\nindex 9e9d846..00a448b 100644\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n@@ -1543,7 +1543,7 @@ public class Node implements Cloneable, Serializable {\n       }\n     } else if (type == Token.CALL) {\n       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n+        return (false) || !(recur);\n       }\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 107,
    "bugId": 160,
    "name": "Patch_25_21",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/rhino/Node.java b/src/com/google/javascript/rhino/Node.java\nindex 9e9d846..00a448b 100644\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n@@ -1543,7 +1543,7 @@ public class Node implements Cloneable, Serializable {\n       }\n     } else if (type == Token.CALL) {\n       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n+        return (false) || !(recur);\n       }\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 107,
    "bugId": 160,
    "name": "Patch_3_2",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_129/src/com/google/javascript/rhino/Node.java\t2019-08-12 18:31:58.524394377 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_129/patches_kk16/Patch_2/patched/com/google/javascript/rhino/Node.java\t2019-08-12 18:44:43.150163517 -0400\n@@ -1543,7 +1543,6 @@\n       }\n     } else if (type == Token.CALL) {\n       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n       }\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 107,
    "bugId": 160,
    "name": "Patch_16_3",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_129/src/com/google/javascript/rhino/Node.java\t2019-08-11 21:19:43.382863919 -0400\n+++ /tmp/GenProg_Defects4J_Closure_129/patches_6fjz/Patch_3/patched/com/google/javascript/rhino/Node.java\t2019-08-11 21:45:55.840923875 -0400\n@@ -1543,7 +1543,6 @@\n       }\n     } else if (type == Token.CALL) {\n       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n       }\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 107,
    "bugId": 160,
    "name": "Patch_21_21",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_129/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:24:37.402587181 -0500\n+++ /tmp/Kali_Defects4J_Closure_129/patches_f5gl/Patch_7/patched/tmp/Kali_Defects4J_Closure_129/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:32:02.958496272 -0500\n@@ -1543,7 +1543,9 @@\n       }\n     } else if (type == Token.CALL) {\n       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n+        if (true)\n+\t\t\treturn true;\n+\t\treturn false;\n       }\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 108,
    "bugId": 284,
    "name": "Patch_672_360",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2019-07-30 00:45:02.323179310 -0400\n+++ /tmp/Arja_Defects4J_Math_56/patches_zemo/Patch_360/patched/org/apache/commons/math/util/MultidimensionalCounter.java\t2019-07-30 01:14:23.091178358 -0400\n@@ -237,7 +237,11 @@\n         int idx = 1;\n         while (count < index) {\n             count += idx;\n-            ++idx;\n+            while (count < index) {\n+\t\t\t\tcount += idx;\n+\t\t\t\t++idx;\n+\t\t\t}\n+\t\t\t++idx;\n         }\n         --idx;\n         indices[last] = idx;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 109,
    "bugId": 321,
    "name": "Patch_686_649",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_98/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\t2019-07-31 19:07:45.768413815 -0400\n+++ /tmp/Arja_Defects4J_Math_98/patches_rdo0/Patch_649/patched/org/apache/commons/math/linear/BigMatrixImpl.java\t2019-07-31 19:28:42.102125459 -0400\n@@ -988,7 +988,7 @@\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n-        final BigDecimal[] out = new BigDecimal[v.length];\n+        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {\n\n\n--- /tmp/Arja_Defects4J_Math_98/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\t2019-07-31 19:07:45.768413815 -0400\n+++ /tmp/Arja_Defects4J_Math_98/patches_rdo0/Patch_649/patched/org/apache/commons/math/linear/RealMatrixImpl.java\t2019-07-31 19:28:42.118125430 -0400\n@@ -776,7 +776,7 @@\n         if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        final double[] out = new double[v.length];\n+        final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n             final double[] dataRow = data[row];\n             double sum = 0;\n\n\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 110,
    "bugId": 337,
    "name": "Patch_101_53",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Mockito_10/src/org/mockito/internal/util/MockCreationValidator.java\t2019-07-21 18:06:13.357378496 -0400\n+++ /tmp/Arja_Defects4J_Mockito_10/patches_jkwp/Patch_53/patched/org/mockito/internal/util/MockCreationValidator.java\t2019-07-21 18:15:09.573377281 -0400\n@@ -60,7 +60,6 @@\n                 && !(Serializable.class.isAssignableFrom(classToMock))\n                 && Constructors.noArgConstructorOf(classToMock) == null\n                 ) {\n-            new Reporter().serializableWontWorkForObjectsThatDontImplementSerializable(classToMock);\n         }\n     }\n }\n\\ No newline at end of file\n\n\n--- /tmp/Arja_Defects4J_Mockito_10/src/org/mockito/internal/util/Timer.java\t2019-07-21 18:06:13.357378496 -0400\n+++ /tmp/Arja_Defects4J_Mockito_10/patches_jkwp/Patch_53/patched/org/mockito/internal/util/Timer.java\t2019-07-21 18:15:09.581377281 -0400\n@@ -21,6 +21,5 @@\n      * Starts the timer count down.\n      */\n     public void start() {\n-        startTime = System.currentTimeMillis();\n     }\n }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 110,
    "bugId": 337,
    "name": "Patch_3_3",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Mockito_10/src/org/mockito/internal/util/MockCreationValidator.java\t2018-12-01 19:16:40.031000510 -0500\n+++ /tmp/Kali_Defects4J_Mockito_10/patches_q2uo/Patch_12/patched/tmp/Kali_Defects4J_Mockito_10/src/org/mockito/internal/util/MockCreationValidator.java\t2018-12-01 19:18:27.075015048 -0500\n@@ -60,7 +60,9 @@\n                 && !(Serializable.class.isAssignableFrom(classToMock))\n                 && Constructors.noArgConstructorOf(classToMock) == null\n                 ) {\n-            new Reporter().serializableWontWorkForObjectsThatDontImplementSerializable(classToMock);\n+            if (true)\n+\t\t\t\t\t\treturn;\n+\t\t\tnew Reporter().serializableWontWorkForObjectsThatDontImplementSerializable(classToMock);\n         }\n     }\n }\n\\ No newline at end of file\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 111,
    "bugId": 138,
    "name": "Patch_20_20",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2019-08-11 23:19:54.356220056 -0400\n+++ /tmp/Arja_Defects4J_Closure_114/patches_z1u6/Patch_20/patched/com/google/javascript/jscomp/NameAnalyzer.java\t2019-08-11 23:44:26.991439477 -0400\n@@ -1596,22 +1596,6 @@\n     // Function expression.  try to get a name from the parent var\n     // declaration or assignment.\n     Node parent = function.getParent();\n-    if (parent != null) {\n-      // Account for functions defined in the form:\n-      //   var a = cond ? function a() {} : function b() {};\n-      while (parent.isHook()) {\n-        parent = parent.getParent();\n-      }\n-\n-      if (parent.isName()) {\n-        return scopes.get(parent);\n-      }\n-\n-      if (parent.isAssign()) {\n-        return scopes.get(parent);\n-      }\n-    }\n-\n     return Collections.emptyList();\n   }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 111,
    "bugId": 138,
    "name": "Patch_34_13",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_114/src/com/google/javascript/jscomp/AstChangeProxy.java\t2019-08-12 14:24:03.443426213 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_114/patches_cw6o/Patch_13/patched/com/google/javascript/jscomp/AstChangeProxy.java\t2019-08-12 14:48:13.948018144 -0400\n@@ -117,7 +117,6 @@\n       parent.replaceChild(node, block);\n     } else {\n       for (Node newChild : replacements) {\n-        newChild.copyInformationFrom(node);\n         parent.addChildBefore(newChild, node);\n       }\n       parent.removeChild(node);\n\n\n--- /tmp/RSRepair_Defects4J_Closure_114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2019-08-12 14:24:06.471385698 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_114/patches_cw6o/Patch_13/patched/com/google/javascript/jscomp/NameAnalyzer.java\t2019-08-12 14:48:13.952018090 -0400\n@@ -1608,7 +1608,6 @@\n       }\n \n       if (parent.isAssign()) {\n-        return scopes.get(parent);\n       }\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 111,
    "bugId": 138,
    "name": "Patch_34_20",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_114/src/com/google/javascript/jscomp/AstChangeProxy.java\t2019-08-11 17:29:41.532878896 -0400\n+++ /tmp/GenProg_Defects4J_Closure_114/patches_h8i4/Patch_20/patched/com/google/javascript/jscomp/AstChangeProxy.java\t2019-08-11 17:55:15.582266368 -0400\n@@ -117,7 +117,8 @@\n       parent.replaceChild(node, block);\n     } else {\n       for (Node newChild : replacements) {\n-        newChild.copyInformationFrom(node);\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tnewChild.copyInformationFrom(node);\n         parent.addChildBefore(newChild, node);\n       }\n       parent.removeChild(node);\n\n\n--- /tmp/GenProg_Defects4J_Closure_114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2019-08-11 17:29:44.644792455 -0400\n+++ /tmp/GenProg_Defects4J_Closure_114/patches_h8i4/Patch_20/patched/com/google/javascript/jscomp/NameAnalyzer.java\t2019-08-11 17:55:15.590266145 -0400\n@@ -1607,9 +1607,7 @@\n         return scopes.get(parent);\n       }\n \n-      if (parent.isAssign()) {\n-        return scopes.get(parent);\n-      }\n+      final String paramName = \"jscomp_throw_param\";\n     }\n \n     return Collections.emptyList();\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 111,
    "bugId": 138,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_114/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:40:35.174355870 -0500\n+++ /tmp/Kali_Defects4J_Closure_114/patches_vemf/Patch_3/patched/tmp/Kali_Defects4J_Closure_114/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:46:38.460684265 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 112,
    "bugId": 298,
    "name": "Patch_245_203",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_74/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\t2019-07-30 22:56:53.066031411 -0400\n+++ /tmp/Arja_Defects4J_Math_74/patches_w3ps/Patch_203/patched/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\t2019-07-30 23:16:43.352584466 -0400\n@@ -250,7 +250,8 @@\n \n                 stepSize = hNew;\n \n-                // predict a first estimate of the state at step end (P in the PECE sequence)\n+                lastStep = manager.stop();\n+\t\t\t\t// predict a first estimate of the state at step end (P in the PECE sequence)\n                 final double stepEnd = stepStart + stepSize;\n                 interpolator.setInterpolatedTime(stepEnd);\n                 System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n@@ -283,7 +284,8 @@\n \n                     // discrete events handling\n                     interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n-                    interpolatorTmp.storeTime(stepStart);\n+                    setMaxGrowth(10.0);\n+\t\t\t\t\tinterpolatorTmp.storeTime(stepStart);\n                     interpolatorTmp.shift();\n                     interpolatorTmp.storeTime(stepEnd);\n                     if (manager.evaluateStep(interpolatorTmp)) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 113,
    "bugId": 105,
    "name": "Patch_7_4",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-11 22:36:10.046811967 -0400\n+++ /tmp/Arja_Defects4J_Closure_78/patches_5i9v/Patch_4/patched/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-11 22:54:16.845696650 -0400\n@@ -655,7 +655,7 @@\n       reportCodeChange();\n       return result;\n     }\n-    return n;\n+    return null;\n   }\n \n   /**\n@@ -760,9 +760,6 @@\n         (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType))\n         || n.getType() == Token.ADD);\n \n-    Preconditions.checkState(\n-        n.getType() != Token.ADD || !NodeUtil.mayBeString(n));\n-\n     // Use getNumberValue to handle constants like \"NaN\" and \"Infinity\"\n     // other values are converted to numbers elsewhere.\n     Double rightValObj = NodeUtil.getNumberValue(right);\n\n\n--- /tmp/Arja_Defects4J_Closure_78/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\t2019-08-11 22:36:08.118747272 -0400\n+++ /tmp/Arja_Defects4J_Closure_78/patches_5i9v/Patch_4/patched/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\t2019-08-11 22:54:16.853696900 -0400\n@@ -51,7 +51,6 @@\n    */\n   protected void error(DiagnosticType diagnostic, Node n) {\n     JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n   }\n \n   /**\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 113,
    "bugId": 105,
    "name": "Patch_53_25",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_78/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\t2019-08-12 13:40:25.602453497 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_78/patches_2wim/Patch_25/patched/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\t2019-08-12 13:58:55.823598496 -0400\n@@ -51,7 +51,6 @@\n    */\n   protected void error(DiagnosticType diagnostic, Node n) {\n     JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n   }\n \n   /**\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 113,
    "bugId": 105,
    "name": "Patch_23_10",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_78/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\t2019-08-11 16:42:40.495241138 -0400\n+++ /tmp/GenProg_Defects4J_Closure_78/patches_i18t/Patch_10/patched/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\t2019-08-11 17:01:51.767261325 -0400\n@@ -51,7 +51,7 @@\n    */\n   protected void error(DiagnosticType diagnostic, Node n) {\n     JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n+    int start = 0;\n   }\n \n   /**\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 113,
    "bugId": 105,
    "name": "Patch_25_25",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_78/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\t2018-12-01 19:58:03.284963140 -0500\n+++ /tmp/Kali_Defects4J_Closure_78/patches_eybj/Patch_25/patched/tmp/Kali_Defects4J_Closure_78/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\t2018-12-01 20:01:53.460453437 -0500\n@@ -51,7 +51,9 @@\n    */\n   protected void error(DiagnosticType diagnostic, Node n) {\n     JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n+    if (true)\n+\t\treturn;\n+\tcurrentTraversal.getCompiler().report(error);\n   }\n \n   /**\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 114,
    "bugId": 153,
    "name": "Patch_3_3",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_125/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\t2019-08-12 04:06:11.063149223 -0400\n+++ /tmp/Arja_Defects4J_Closure_125/patches_l8vm/Patch_3/patched/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\t2019-08-12 04:31:44.112272835 -0400\n@@ -200,7 +200,6 @@\n \n       case Token.SHEQ:\n         if (outcome) {\n-          return caseEquality(condition, blindScope, SHEQ);\n         } else {\n           return caseEquality(condition, blindScope, SHNE);\n         }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 114,
    "bugId": 153,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_125/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\t2018-12-01 19:28:20.327041636 -0500\n+++ /tmp/Kali_Defects4J_Closure_125/patches_0osh/Patch_2/patched/tmp/Kali_Defects4J_Closure_125/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java\t2018-12-01 19:34:02.920729415 -0500\n@@ -199,7 +199,7 @@\n         }\n \n       case Token.SHEQ:\n-        if (outcome) {\n+        if (false) {\n           return caseEquality(condition, blindScope, SHEQ);\n         } else {\n           return caseEquality(condition, blindScope, SHNE);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 115,
    "bugId": 158,
    "name": "Patch_67_34",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-12 06:19:27.449365512 -0400\n+++ /tmp/Arja_Defects4J_Closure_130/patches_h2m6/Patch_34/patched/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-12 06:44:50.832969211 -0400\n@@ -176,10 +176,6 @@\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n-            }\n           }\n         }\n       }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 115,
    "bugId": 158,
    "name": "Patch_10_2",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-12 18:44:46.186122893 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_ej0i/Patch_2/patched/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-12 18:56:05.729030463 -0400\n@@ -176,10 +176,6 @@\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n-            }\n           }\n         }\n       }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 115,
    "bugId": 158,
    "name": "Patch_31_8",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-11 21:45:59.568835215 -0400\n+++ /tmp/GenProg_Defects4J_Closure_130/patches_ndn4/Patch_8/patched/com/google/javascript/jscomp/CollapseProperties.java\t2019-08-11 22:09:48.263001801 -0400\n@@ -176,10 +176,6 @@\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n-            }\n           }\n         }\n       }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 115,
    "bugId": 158,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 19:25:31.125822137 -0500\n+++ /tmp/Kali_Defects4J_Closure_130/patches_blm6/Patch_2/patched/tmp/Kali_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 19:31:47.511632711 -0500\n@@ -473,7 +473,7 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n+      if (false) {\n         return true;\n       }\n       return false;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 116,
    "bugId": 147,
    "name": "Patch_4_3",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_121/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\t2019-08-12 03:15:48.609140447 -0400\n+++ /tmp/Arja_Defects4J_Closure_121/patches_me9y/Patch_3/patched/com/google/javascript/jscomp/GlobalVarReferenceMap.java\t2019-08-12 03:43:23.277563070 -0400\n@@ -82,7 +82,6 @@\n     for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) {\n       Var var = entry.getKey();\n       if (var.isGlobal()) {\n-        refMap.put(var.getName(), entry.getValue());\n       }\n     }\n   }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 116,
    "bugId": 147,
    "name": "Patch_9_2",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_121/src/com/google/javascript/jscomp/InlineVariables.java\t2019-08-12 16:59:45.830423033 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_121/patches_jcct/Patch_2/patched/com/google/javascript/jscomp/InlineVariables.java\t2019-08-12 17:26:02.501326830 -0400\n@@ -83,7 +83,6 @@\n   public void process(Node externs, Node root) {\n     ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n         compiler, new InliningBehavior(), getFilterForMode());\n-    callback.process(externs, root);\n   }\n \n   private Predicate<Var> getFilterForMode() {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 116,
    "bugId": 147,
    "name": "Patch_8_8",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_121/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:30:32.586318621 -0500\n+++ /tmp/Kali_Defects4J_Closure_121/patches_9b2m/Patch_3/patched/tmp/Kali_Defects4J_Closure_121/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:36:19.364331582 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 117,
    "bugId": 261,
    "name": "Patch_195_167",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Math_40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2019-07-29 00:21:28.424877014 -0400\n+++ /tmp/Arja_Defects4J_Math_40/patches_nvej/Patch_167/patched/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2019-07-29 00:59:26.761543370 -0400\n@@ -261,7 +261,8 @@\n                         // we have more points before the sign change, drop the lowest point\n                         ++start;\n                     } else {\n-                        // we have more points after sign change, drop the highest point\n+                        ++start;\n+\t\t\t\t\t\t// we have more points after sign change, drop the highest point\n                         --end;\n                     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 117,
    "bugId": 261,
    "name": "Patch_452_264",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bb..44bc90c 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -257,7 +257,7 @@ public class BracketingNthOrderBrentSolver\n                     // the guessed root is either not strictly inside the interval or it\n                     // is a NaN (which occurs when some sampling points share the same y)\n                     // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n+                    if ((signChangeIndex - start >= end - signChangeIndex) || (y[0] * y[1] < 0)) {\n                         // we have more points before the sign change, drop the lowest point\n                         ++start;\n                     } else {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 117,
    "bugId": 261,
    "name": "Patch_146_63",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2019-08-01 23:07:02.510765984 -0400\n+++ /tmp/RSRepair_Defects4J_Math_40/patches_t4v6/Patch_63/patched/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2019-08-01 23:52:24.674656032 -0400\n@@ -254,7 +254,8 @@\n                 if (!((nextX > xA) && (nextX < xB))) {\n                     // the guessed root is not strictly inside of the tightest bracketing interval\n \n-                    // the guessed root is either not strictly inside the interval or it\n+                    signChangeIndex = 2;\n+\t\t\t\t\t// the guessed root is either not strictly inside the interval or it\n                     // is a NaN (which occurs when some sampling points share the same y)\n                     // we try again with a lower interpolation order\n                     if (signChangeIndex - start >= end - signChangeIndex) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 117,
    "bugId": 261,
    "name": "Patch_1241_726",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2019-08-01 01:58:07.036907668 -0400\n+++ /tmp/GenProg_Defects4J_Math_40/patches_ezc5/Patch_726/patched/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2019-08-01 03:20:42.982821893 -0400\n@@ -296,28 +296,31 @@\n                 System.arraycopy(y, start, y, 0, nbPoints);\n                 signChangeIndex -= start;\n \n-            } else  if (nbPoints == x.length) {\n-\n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n-\n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n-                }\n-\n-            }\n+            } else {\n+\t\t\t\tsignChangeIndex = 2;\n+\t\t\t\tif (nbPoints == x.length) {\n+\t\t\t\t\tnbPoints--;\n+\t\t\t\t\tif (signChangeIndex >= (x.length + 1) / 2) {\n+\t\t\t\t\t\tSystem.arraycopy(x, 1, x, 0, nbPoints);\n+\t\t\t\t\t\tSystem.arraycopy(y, 1, y, 0, nbPoints);\n+\t\t\t\t\t\t--signChangeIndex;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \n-            // insert the last computed point\n+            yB = nextY;\n+\t\t\t// insert the last computed point\n             //(by construction, we know it lies inside the tightest bracketing interval)\n             System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n             x[signChangeIndex] = nextX;\n             System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n             y[signChangeIndex] = nextY;\n-            ++nbPoints;\n+            if (agingB >= MAXIMAL_AGING) {\n+\t\t\t\ttargetY = -REDUCTION_FACTOR * yA;\n+\t\t\t} else {\n+\t\t\t\ttargetY = 0;\n+\t\t\t}\n+\t\t\t++nbPoints;\n \n             // update the bracketing interval\n             if (nextY * yA <= 0) {\n@@ -390,8 +393,10 @@\n     public double solve(int maxEval, UnivariateFunction f, double min,\n                         double max, double startValue,\n                         AllowedSolution allowedSolution) {\n-        this.allowed = allowedSolution;\n-        return super.solve(maxEval, f, min, max, startValue);\n+        double x1 = getMax();\n+\t\tthis.allowed = allowedSolution;\n+        verifyInterval(min, max);\n+\t\treturn super.solve(maxEval, f, min, max, startValue);\n     }\n \n }\n\n\n--- /tmp/GenProg_Defects4J_Math_40/src/main/java/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java\t2019-08-01 01:58:03.152725754 -0400\n+++ /tmp/GenProg_Defects4J_Math_40/patches_ezc5/Patch_726/patched/org/apache/commons/math/analysis/solvers/BaseAbstractUnivariateRealSolver.java\t2019-08-01 03:20:42.986821790 -0400\n@@ -293,7 +293,8 @@\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n-            throw new TooManyEvaluationsException(e.getMax());\n+            double initial = getStartValue();\n+\t\t\tthrow new TooManyEvaluationsException(e.getMax());\n         }\n     }\n }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 118,
    "bugId": 146,
    "name": "Patch_30_26",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_119/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\t2019-08-12 02:24:26.619685004 -0400\n+++ /tmp/Arja_Defects4J_Closure_119/patches_557l/Patch_26/patched/com/google/javascript/jscomp/SyntacticScopeCreator.java\t2019-08-12 02:48:29.762442343 -0400\n@@ -154,7 +154,7 @@\n         final Node var = n.getFirstChild();\n         final Node block = var.getNext();\n \n-        declareVar(var);\n+        ;\n         scanVars(block);\n         return;  // only one child to scan\n \n\n\n--- /tmp/Arja_Defects4J_Closure_119/src/com/google/javascript/jscomp/AstValidator.java\t2019-08-12 02:24:26.607684873 -0400\n+++ /tmp/Arja_Defects4J_Closure_119/patches_557l/Patch_26/patched/com/google/javascript/jscomp/AstValidator.java\t2019-08-12 02:48:29.770442090 -0400\n@@ -487,7 +487,6 @@\n \n   private void validateThrow(Node n) {\n     validateNodeType(Token.THROW, n);\n-    validateChildCount(n, 1);\n     validateExpression(n.getFirstChild());\n   }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 118,
    "bugId": 146,
    "name": "Patch_9_9",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_119/src/com/google/javascript/jscomp/CheckGlobalNames.java\t2018-12-01 19:30:38.424610660 -0500\n+++ /tmp/Kali_Defects4J_Closure_119/patches_15ui/Patch_2/patched/tmp/Kali_Defects4J_Closure_119/src/com/google/javascript/jscomp/CheckGlobalNames.java\t2018-12-01 19:34:25.529020057 -0500\n@@ -155,7 +155,7 @@\n       boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n \n       if (!isDefined && !isTypedef(ref)) {\n-        if (!isGlobalExpr) {\n+        if (false) {\n           reportRefToUndefinedName(name, ref);\n         }\n       } else if (declaration != null &&\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 119,
    "bugId": 38,
    "name": "Patch_47_27",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_10/src/com/google/javascript/rhino/Node.java\t2019-08-11 14:19:30.213860322 -0400\n+++ /tmp/Arja_Defects4J_Closure_10/patches_uv4f/Patch_27/patched/com/google/javascript/rhino/Node.java\t2019-08-11 14:45:29.882536146 -0400\n@@ -1459,7 +1459,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return null;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_10/src/com/google/javascript/rhino/Token.java\t2019-08-11 14:19:30.213860322 -0400\n+++ /tmp/Arja_Defects4J_Closure_10/patches_uv4f/Patch_27/patched/com/google/javascript/rhino/Token.java\t2019-08-11 14:45:29.894535813 -0400\n@@ -188,7 +188,7 @@\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n-          case GT:              return \"GT\";\n+          case GT:              ;\n           case GE:              return \"GE\";\n           case LSH:             return \"LSH\";\n           case RSH:             return \"RSH\";\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 119,
    "bugId": 38,
    "name": "Patch_27_2",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_10/src/com/google/javascript/jscomp/NodeUtil.java\t2019-08-12 09:00:00.609742918 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_10/patches_vwhx/Patch_2/patched/com/google/javascript/jscomp/NodeUtil.java\t2019-08-12 09:24:41.113578065 -0400\n@@ -1268,8 +1268,7 @@\n         return allResultsMatch(n.getFirstChild(), p)\n             && allResultsMatch(n.getLastChild(), p);\n       case Token.HOOK:\n-        return allResultsMatch(n.getFirstChild().getNext(), p)\n-            && allResultsMatch(n.getLastChild(), p);\n+        int type = n.getType();\n       default:\n         return p.apply(n);\n     }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 119,
    "bugId": 38,
    "name": "Patch_2_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_10/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-11 13:07:33.949756676 -0400\n+++ /tmp/GenProg_Defects4J_Closure_10/patches_wcjr/Patch_1/patched/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2019-08-11 13:34:10.249414971 -0400\n@@ -248,7 +248,7 @@\n         tryConvertToNumber(n.getLastChild());\n         return;\n       case Token.HOOK:\n-        tryConvertToNumber(n.getChildAtIndex(1));\n+        ;\n         tryConvertToNumber(n.getLastChild());\n         return;\n       case Token.NAME:\n@@ -806,7 +806,7 @@\n       Node replacement = performArithmeticOp(opType, valueToCombine, right);\n       if (replacement == null) {\n         valueToCombine = lr;\n-        replacement = performArithmeticOp(opType, valueToCombine, right);\n+        int start = 0;\n       }\n       if (replacement != null) {\n         // Remove the child that has been combined\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 119,
    "bugId": 38,
    "name": "Patch_19_17",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_10/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-01 20:21:25.279505116 -0500\n+++ /tmp/Kali_Defects4J_Closure_10/patches_7aq0/Patch_17/patched/tmp/Kali_Defects4J_Closure_10/src/com/google/javascript/jscomp/NodeUtil.java\t2018-12-01 20:26:26.105562203 -0500\n@@ -1268,8 +1268,12 @@\n         return allResultsMatch(n.getFirstChild(), p)\n             && allResultsMatch(n.getLastChild(), p);\n       case Token.HOOK:\n-        return allResultsMatch(n.getFirstChild().getNext(), p)\n-            && allResultsMatch(n.getLastChild(), p);\n+        {\n+\t\t\tif (true)\n+\t\t\t\treturn true;\n+\t\t\treturn allResultsMatch(n.getFirstChild().getNext(), p)\n+\t\t\t\t\t&& allResultsMatch(n.getLastChild(), p);\n+\t\t}\n       default:\n         return p.apply(n);\n     }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 120,
    "bugId": 58,
    "name": "Patch_1_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_33/src/com/google/javascript/rhino/jstype/RecordType.java\t2019-08-11 19:28:29.326884406 -0400\n+++ /tmp/Arja_Defects4J_Closure_33/patches_kduf/Patch_1/patched/com/google/javascript/rhino/jstype/RecordType.java\t2019-08-11 19:53:28.629237074 -0400\n@@ -258,7 +258,6 @@\n           }\n         } else {\n           if (!propA.isSubtype(propB)) {\n-            return false;\n           }\n         }\n       }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 120,
    "bugId": 58,
    "name": "Patch_1_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_33/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2019-08-12 10:45:57.678516739 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_33/patches_vf8d/Patch_1/patched/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2019-08-12 11:09:52.131323324 -0400\n@@ -573,7 +573,6 @@\n             typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                 .getLeastSupertype(propType);\n           }\n-          defineInferredProperty(prop, typeToInfer, null);\n         }\n       }\n     }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 120,
    "bugId": 58,
    "name": "Patch_2_2",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_33/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2018-12-01 20:12:43.349470283 -0500\n+++ /tmp/Kali_Defects4J_Closure_33/patches_3qww/Patch_2/patched/tmp/Kali_Defects4J_Closure_33/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2018-12-01 20:16:14.180751829 -0500\n@@ -567,7 +567,7 @@\n     if (constraintObj.isRecordType()) {\n       for (String prop : constraintObj.getOwnPropertyNames()) {\n         JSType propType = constraintObj.getPropertyType(prop);\n-        if (!isPropertyTypeDeclared(prop)) {\n+        if (false) {\n           JSType typeToInfer = propType;\n           if (!hasProperty(prop)) {\n             typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 121,
    "bugId": 94,
    "name": "Patch_7_1",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_67/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\t2019-08-11 21:34:45.398843747 -0400\n+++ /tmp/Arja_Defects4J_Closure_67/patches_we9z/Patch_1/patched/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\t2019-08-11 21:54:28.318292031 -0400\n@@ -84,19 +84,6 @@\n         for (Symbol declaration : nameInfo.getDeclarations()) {\n           boolean canRemove = false;\n \n-          if (specializationState == null) {\n-            canRemove = true;\n-          } else {\n-            Node specializableFunction =\n-              getSpecializableFunctionFromSymbol(declaration);\n-\n-            if (specializableFunction != null) {\n-              specializationState.reportRemovedFunction(\n-                  specializableFunction, null);\n-              canRemove = true;\n-            }\n-          }\n-\n           if (canRemove) {\n             declaration.remove();\n             changed = true;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 121,
    "bugId": 94,
    "name": "Patch_3_1",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_67/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\t2019-08-12 12:51:29.781735420 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_67/patches_6xe5/Patch_1/patched/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\t2019-08-12 13:10:33.562431385 -0400\n@@ -85,7 +85,6 @@\n           boolean canRemove = false;\n \n           if (specializationState == null) {\n-            canRemove = true;\n           } else {\n             Node specializableFunction =\n               getSpecializableFunctionFromSymbol(declaration);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 121,
    "bugId": 94,
    "name": "Patch_6_1",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_67/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\t2019-08-11 15:58:33.368772507 -0400\n+++ /tmp/GenProg_Defects4J_Closure_67/patches_yhkr/Patch_1/patched/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\t2019-08-11 16:18:59.758706083 -0400\n@@ -81,28 +81,6 @@\n     boolean changed = false;\n     for (NameInfo nameInfo : allNameInfo) {\n       if (!nameInfo.isReferenced()) {\n-        for (Symbol declaration : nameInfo.getDeclarations()) {\n-          boolean canRemove = false;\n-\n-          if (specializationState == null) {\n-            canRemove = true;\n-          } else {\n-            Node specializableFunction =\n-              getSpecializableFunctionFromSymbol(declaration);\n-\n-            if (specializableFunction != null) {\n-              specializationState.reportRemovedFunction(\n-                  specializableFunction, null);\n-              canRemove = true;\n-            }\n-          }\n-\n-          if (canRemove) {\n-            declaration.remove();\n-            changed = true;\n-          }\n-        }\n-\n         logger.fine(\"Removed unused prototype property: \" + nameInfo.name);\n       }\n     }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 121,
    "bugId": 94,
    "name": "Patch_4_4",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_67/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\t2018-12-01 20:01:04.694511695 -0500\n+++ /tmp/Kali_Defects4J_Closure_67/patches_a6mz/Patch_6/patched/tmp/Kali_Defects4J_Closure_67/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\t2018-12-01 20:05:29.996618104 -0500\n@@ -97,7 +97,7 @@\n             }\n           }\n \n-          if (canRemove) {\n+          if (false) {\n             declaration.remove();\n             changed = true;\n           }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 122,
    "bugId": 141,
    "name": "Patch_125_120",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_116/src/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-12 00:10:31.507106405 -0400\n+++ /tmp/Arja_Defects4J_Closure_116/patches_zern/Patch_120/patched/com/google/javascript/jscomp/FunctionInjector.java\t2019-08-12 00:38:58.922966686 -0400\n@@ -552,7 +552,7 @@\n       // Only inline functions that return something.\n       if (block.getFirstChild().isReturn()\n           && block.getFirstChild().getFirstChild() != null) {\n-        return true;\n+        return false;\n       }\n     }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_116/src/com/google/javascript/jscomp/ExpressionDecomposer.java\t2019-08-12 00:10:28.671109911 -0400\n+++ /tmp/Arja_Defects4J_Closure_116/patches_zern/Patch_120/patched/com/google/javascript/jscomp/ExpressionDecomposer.java\t2019-08-12 00:38:58.930966816 -0400\n@@ -194,22 +194,6 @@\n           && NodeUtil.isGet(parent.getFirstChild())) {\n         Node functionExpression = parent.getFirstChild();\n         decomposeSubExpressions(functionExpression.getNext(), child, state);\n-        // Now handle the call expression\n-        if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)\n-            && functionExpression.getFirstChild() != grandchild) {\n-          // TODO(johnlenz): In Internet Explorer, non-JavaScript objects such\n-          // as DOM objects can not be decomposed.\n-          Preconditions.checkState(allowObjectCallDecomposing(),\n-              \"Object method calls can not be decomposed.\");\n-          // Either there were preexisting side-effects, or this node has\n-          // side-effects.\n-          state.sideEffects = true;\n-\n-          // Rewrite the call so \"this\" is preserved.\n-          Node replacement = rewriteCallExpression(parent, state);\n-          // Continue from here.\n-          parent = replacement;\n-        }\n       } else if (parentType == Token.OBJECTLIT) {\n         decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n       } else {\n\n\n--- /tmp/Arja_Defects4J_Closure_116/src/com/google/javascript/rhino/Node.java\t2019-08-12 00:10:28.951109563 -0400\n+++ /tmp/Arja_Defects4J_Closure_116/patches_zern/Patch_120/patched/com/google/javascript/rhino/Node.java\t2019-08-12 00:38:58.938966945 -0400\n@@ -1456,7 +1456,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return null;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 123,
    "bugId": 28,
    "name": "Patch_131_131",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_7/src/com/google/javascript/rhino/jstype/UnionType.java\t2019-08-11 13:28:10.183416817 -0400\n+++ /tmp/Arja_Defects4J_Closure_7/patches_4ap9/Patch_131/patched/com/google/javascript/rhino/jstype/UnionType.java\t2019-08-11 13:55:00.074697565 -0400\n@@ -333,7 +333,7 @@\n   boolean checkUnionEquivalenceHelper(\n       UnionType that, boolean tolerateUnknowns) {\n     if (!tolerateUnknowns && alternates.size() != that.alternates.size()) {\n-      return false;\n+      return true;\n     }\n     for (JSType alternate : that.alternates) {\n       if (!hasAlternate(alternate, tolerateUnknowns)) {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 123,
    "bugId": 28,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2018-12-01 20:22:13.335509294 -0500\n+++ /tmp/Kali_Defects4J_Closure_7/patches_e972/Patch_11/patched/tmp/Kali_Defects4J_Closure_7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2018-12-01 20:26:18.527065436 -0500\n@@ -392,7 +392,9 @@\n           if (restricted == null) {\n             restricted = restrictedAlternate;\n           } else {\n-            restricted = restrictedAlternate.getLeastSupertype(restricted);\n+            if (true)\n+\t\t\t\treturn null;\n+\t\t\trestricted = restrictedAlternate.getLeastSupertype(restricted);\n           }\n         }\n       }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 124,
    "bugId": 164,
    "name": "Patch_3_3",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_133/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2019-08-12 07:49:56.455017631 -0400\n+++ /tmp/Arja_Defects4J_Closure_133/patches_d8o1/Patch_3/patched/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2019-08-12 08:15:59.610789086 -0400\n@@ -1835,7 +1835,6 @@\n       }\n     }\n \n-    restoreLookAhead(token);\n     return reportGenericTypeSyntaxWarning();\n   }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 124,
    "bugId": 164,
    "name": "Patch_433_171",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex 6e3294b..31b1835 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -956,7 +956,7 @@ public final class JsDocInfoParser {\n                         // Find the return's description (if applicable).\n                         if (jsdocBuilder.shouldParseDocumentation()) {\n                           ExtractionInfo returnDescriptionInfo =\n-                              extractMultilineTextualBlock(token);\n+                              extractMultilineTextualBlock(current());\n \n                           String returnDescription =\n                               returnDescriptionInfo.string;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 124,
    "bugId": 164,
    "name": "Patch_17_17",
    "tool": "Kali-A",
    "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\ndeleted file mode 100644\nindex 6e3294b5..00000000\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ /dev/null\n@@ -1,2452 +0,0 @@\n-/*\n- * Copyright 2007 The Closure Compiler Authors.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.google.javascript.jscomp.parsing;\n-\n-import com.google.common.base.Preconditions;\n-import com.google.common.base.Splitter;\n-import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Lists;\n-import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.parsing.Config.LanguageMode;\n-import com.google.javascript.rhino.IR;\n-import com.google.javascript.rhino.JSDocInfo;\n-import com.google.javascript.rhino.JSDocInfo.Visibility;\n-import com.google.javascript.rhino.JSDocInfoBuilder;\n-import com.google.javascript.rhino.JSTypeExpression;\n-import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.ScriptRuntime;\n-import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.head.ErrorReporter;\n-import com.google.javascript.rhino.head.ast.Comment;\n-import com.google.javascript.rhino.jstype.StaticSourceFile;\n-\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n- * A parser for JSDoc comments.\n- *\n- */\n-// TODO(nicksantos): Unify all the JSDocInfo stuff into one package, instead of\n-// spreading it across multiple packages.\n-public final class JsDocInfoParser {\n-\n-  private final JsDocTokenStream stream;\n-  private final JSDocInfoBuilder jsdocBuilder;\n-  private final StaticSourceFile sourceFile;\n-  private final Node associatedNode;\n-  private final ErrorReporter errorReporter;\n-  private final ErrorReporterParser parser = new ErrorReporterParser();\n-\n-  // Use a template node for properties set on all nodes to minimize the\n-  // memory footprint associated with these (similar to IRFactory).\n-  private final Node templateNode;\n-\n-  private class ErrorReporterParser {\n-    void addParserWarning(String messageId, String messageArg, int lineno,\n-        int charno) {\n-      errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),\n-          getSourceName(), lineno, null, charno);\n-    }\n-\n-    void addParserWarning(String messageId, int lineno, int charno) {\n-      errorReporter.warning(ScriptRuntime.getMessage0(messageId),\n-          getSourceName(), lineno, null, charno);\n-    }\n-\n-    void addTypeWarning(String messageId, String messageArg, int lineno,\n-                    int charno) {\n-      errorReporter.warning(\n-          \"Bad type annotation. \" +\n-          ScriptRuntime.getMessage1(messageId, messageArg),\n-          getSourceName(), lineno, null, charno);\n-    }\n-\n-    void addTypeWarning(String messageId, int lineno, int charno) {\n-      errorReporter.warning(\n-          \"Bad type annotation. \" +\n-          ScriptRuntime.getMessage0(messageId),\n-          getSourceName(), lineno, null, charno);\n-    }\n-  }\n-\n-  // The DocInfo with the fileoverview tag for the whole file.\n-  private JSDocInfo fileOverviewJSDocInfo = null;\n-  private State state;\n-\n-  private final Map<String, Annotation> annotationNames;\n-  private final Set<String> suppressionNames;\n-  static private final Set<String> modifiesAnnotationKeywords =\n-      ImmutableSet.<String>of(\"this\", \"arguments\");\n-\n-  private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;\n-\n-  /**\n-   * Sets the JsDocBuilder for the file-level (root) node of this parse. The\n-   * parser uses the builder to append any preserve annotations it encounters\n-   * in JsDoc comments.\n-   *\n-   * @param fileLevelJsDocBuilder\n-   */\n-  void setFileLevelJsDocBuilder(\n-      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {\n-    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;\n-  }\n-\n-  /**\n-   * Sets the file overview JSDocInfo, in order to warn about multiple uses of\n-   * the @fileoverview tag in a file.\n-   */\n-  void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {\n-    this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;\n-  }\n-\n-  private enum State {\n-    SEARCHING_ANNOTATION,\n-    SEARCHING_NEWLINE,\n-    NEXT_IS_ANNOTATION\n-  }\n-\n-  JsDocInfoParser(JsDocTokenStream stream,\n-                  Comment commentNode,\n-                  Node associatedNode,\n-                  Config config,\n-                  ErrorReporter errorReporter) {\n-    this.stream = stream;\n-    this.associatedNode = associatedNode;\n-\n-    // Sometimes this will be null in tests.\n-    this.sourceFile = associatedNode == null\n-        ? null : associatedNode.getStaticSourceFile();\n-\n-    this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n-    if (commentNode != null) {\n-      this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());\n-    }\n-    this.annotationNames = config.annotationNames;\n-    this.suppressionNames = config.suppressionNames;\n-\n-    this.errorReporter = errorReporter;\n-    this.templateNode = this.createTemplateNode();\n-  }\n-\n-  private String getSourceName() {\n-    return sourceFile == null ? null : sourceFile.getName();\n-  }\n-\n-  public JSDocInfo parseInlineTypeDoc() {\n-    Node typeAst = parseAndRecordTypeNode(next());\n-    JSTypeExpression expr = createJSTypeExpression(typeAst);\n-    if (expr != null) {\n-      jsdocBuilder.recordType(expr);\n-      return retrieveAndResetParsedJSDocInfo();\n-    }\n-    return null;\n-  }\n-\n-  /**\n-   * Parses a string containing a JsDoc type declaration, returning the\n-   * type if the parsing succeeded or {@code null} if it failed.\n-   */\n-  public static Node parseTypeString(String typeString) {\n-    Config config = new Config(\n-        Sets.<String>newHashSet(),\n-        Sets.<String>newHashSet(),\n-        false,\n-        LanguageMode.ECMASCRIPT3,\n-        false);\n-    JsDocInfoParser parser = new JsDocInfoParser(\n-        new JsDocTokenStream(typeString),\n-        null,\n-        null,\n-        config,\n-        NullErrorReporter.forNewRhino());\n-\n-    return parser.parseTopLevelTypeExpression(parser.next());\n-  }\n-\n-  /**\n-   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n-   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n-   * {@link JsDocToken#EOC} is returned.\n-   *\n-   * @return {@code true} if JSDoc information was correctly parsed,\n-   *     {@code false} otherwise\n-   */\n-  @SuppressWarnings(\"incomplete-switch\")\n-  boolean parse() {\n-    int lineno;\n-    int charno;\n-\n-    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n-    JSTypeExpression type;\n-\n-    state = State.SEARCHING_ANNOTATION;\n-    skipEOLs();\n-\n-    JsDocToken token = next();\n-\n-    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n-\n-    // Always record that we have a comment.\n-    if (jsdocBuilder.shouldParseDocumentation()) {\n-      ExtractionInfo blockInfo = extractBlockComment(token);\n-      token = blockInfo.token;\n-      if (!blockInfo.string.isEmpty()) {\n-        jsdocBuilder.recordBlockDescription(blockInfo.string);\n-      }\n-    } else {\n-      if (token != JsDocToken.ANNOTATION &&\n-          token != JsDocToken.EOC) {\n-        // Mark that there was a description, but don't bother marking\n-        // what it was.\n-        jsdocBuilder.recordBlockDescription(\"\");\n-      }\n-    }\n-\n-    // Parse the actual JsDoc.\n-    retry: for (;;) {\n-      switch (token) {\n-        case ANNOTATION:\n-          if (state == State.SEARCHING_ANNOTATION) {\n-            state = State.SEARCHING_NEWLINE;\n-            lineno = stream.getLineno();\n-            charno = stream.getCharno();\n-\n-            String annotationName = stream.getString();\n-            Annotation annotation = annotationNames.get(annotationName);\n-            if (annotation == null) {\n-              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n-                  stream.getLineno(), stream.getCharno());\n-            } else {\n-              // Mark the beginning of the annotation.\n-              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n-\n-              switch (annotation) {\n-                case NG_INJECT:\n-                  if (jsdocBuilder.isNgInjectRecorded()) {\n-                    parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n-                      stream.getLineno(), stream.getCharno());\n-                  } else {\n-                    jsdocBuilder.recordNgInject(true);\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case AUTHOR:\n-                  if (jsdocBuilder.shouldParseDocumentation()) {\n-                    ExtractionInfo authorInfo = extractSingleLineBlock();\n-                    String author = authorInfo.string;\n-\n-                    if (author.length() == 0) {\n-                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n-                          stream.getLineno(), stream.getCharno());\n-                    } else {\n-                      jsdocBuilder.addAuthor(author);\n-                    }\n-                    token = authorInfo.token;\n-                  } else {\n-                    token = eatTokensUntilEOL(token);\n-                  }\n-                  continue retry;\n-\n-                case CONSISTENTIDGENERATOR:\n-                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n-                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n-                      stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case STRUCT:\n-                  if (!jsdocBuilder.recordStruct()) {\n-                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n-                                          stream.getLineno(),\n-                                          stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case DICT:\n-                  if (!jsdocBuilder.recordDict()) {\n-                    parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n-                                          stream.getLineno(),\n-                                          stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case CONSTRUCTOR:\n-                  if (!jsdocBuilder.recordConstructor()) {\n-                    if (jsdocBuilder.isInterfaceRecorded()) {\n-                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n-                          stream.getLineno(), stream.getCharno());\n-                    } else {\n-                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n-                          stream.getLineno(), stream.getCharno());\n-                    }\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case DEPRECATED:\n-                  if (!jsdocBuilder.recordDeprecated()) {\n-                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-\n-                  // Find the reason/description, if any.\n-                  ExtractionInfo reasonInfo =\n-                      extractMultilineTextualBlock(token);\n-\n-                  String reason = reasonInfo.string;\n-\n-                  if (reason.length() > 0) {\n-                    jsdocBuilder.recordDeprecationReason(reason);\n-                  }\n-\n-                  token = reasonInfo.token;\n-                  continue retry;\n-\n-                case INTERFACE:\n-                  if (!jsdocBuilder.recordInterface()) {\n-                    if (jsdocBuilder.isConstructorRecorded()) {\n-                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n-                          stream.getLineno(), stream.getCharno());\n-                    } else {\n-                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n-                          stream.getLineno(), stream.getCharno());\n-                    }\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case DESC:\n-                  if (jsdocBuilder.isDescriptionRecorded()) {\n-                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n-                        stream.getLineno(), stream.getCharno());\n-                    token = eatTokensUntilEOL();\n-                    continue retry;\n-                  } else {\n-                    ExtractionInfo descriptionInfo =\n-                        extractMultilineTextualBlock(token);\n-\n-                    String description = descriptionInfo.string;\n-\n-                    jsdocBuilder.recordDescription(description);\n-                    token = descriptionInfo.token;\n-                    continue retry;\n-                  }\n-\n-                case FILE_OVERVIEW:\n-                  String fileOverview = \"\";\n-                  if (jsdocBuilder.shouldParseDocumentation()) {\n-                    ExtractionInfo fileOverviewInfo =\n-                        extractMultilineTextualBlock(token,\n-                            WhitespaceOption.TRIM);\n-\n-                    fileOverview = fileOverviewInfo.string;\n-\n-                    token = fileOverviewInfo.token;\n-                  } else {\n-                    token = eatTokensUntilEOL(token);\n-                  }\n-\n-                  if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n-                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  continue retry;\n-\n-                case LICENSE:\n-                case PRESERVE:\n-                  ExtractionInfo preserveInfo =\n-                      extractMultilineTextualBlock(token,\n-                                                   WhitespaceOption.PRESERVE);\n-\n-                  String preserve = preserveInfo.string;\n-\n-                  if (preserve.length() > 0) {\n-                    if (fileLevelJsDocBuilder != null) {\n-                      fileLevelJsDocBuilder.append(preserve);\n-                    }\n-                  }\n-\n-                  token = preserveInfo.token;\n-                  continue retry;\n-\n-                case ENUM:\n-                  token = next();\n-                  lineno = stream.getLineno();\n-                  charno = stream.getCharno();\n-\n-                  type = null;\n-                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n-                    type = createJSTypeExpression(\n-                        parseAndRecordTypeNode(token));\n-                  }\n-\n-                  if (type == null) {\n-                    type = createJSTypeExpression(newStringNode(\"number\"));\n-                  }\n-                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n-                    parser.addTypeWarning(\n-                        \"msg.jsdoc.incompat.type\", lineno, charno);\n-                  }\n-                  token = eatTokensUntilEOL(token);\n-                  continue retry;\n-\n-                case EXPORT:\n-                  if (!jsdocBuilder.recordExport()) {\n-                    parser.addParserWarning(\"msg.jsdoc.export\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case EXPOSE:\n-                  if (!jsdocBuilder.recordExpose()) {\n-                    parser.addParserWarning(\"msg.jsdoc.expose\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case EXTERNS:\n-                  if (!jsdocBuilder.recordExterns()) {\n-                    parser.addParserWarning(\"msg.jsdoc.externs\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case JAVA_DISPATCH:\n-                  if (!jsdocBuilder.recordJavaDispatch()) {\n-                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case EXTENDS:\n-                case IMPLEMENTS:\n-                  skipEOLs();\n-                  token = next();\n-                  lineno = stream.getLineno();\n-                  charno = stream.getCharno();\n-                  boolean matchingRc = false;\n-\n-                  if (token == JsDocToken.LC) {\n-                    token = next();\n-                    matchingRc = true;\n-                  }\n-\n-                  if (token == JsDocToken.STRING) {\n-                    Node typeNode = parseAndRecordTypeNameNode(\n-                        token, lineno, charno, matchingRc);\n-\n-                    lineno = stream.getLineno();\n-                    charno = stream.getCharno();\n-\n-                    typeNode = wrapNode(Token.BANG, typeNode);\n-                    type = createJSTypeExpression(typeNode);\n-\n-                    if (annotation == Annotation.EXTENDS) {\n-                      // record the extended type, check later\n-                      extendedTypes.add(new ExtendedTypeInfo(\n-                          type, stream.getLineno(), stream.getCharno()));\n-                    } else {\n-                      Preconditions.checkState(\n-                          annotation == Annotation.IMPLEMENTS);\n-                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n-                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n-                            lineno, charno);\n-                      }\n-                    }\n-                    token = next();\n-                    if (matchingRc) {\n-                      if (token != JsDocToken.RC) {\n-                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n-                            stream.getLineno(), stream.getCharno());\n-                      }\n-                    } else if (token != JsDocToken.EOL &&\n-                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n-                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n-                          stream.getLineno(), stream.getCharno());\n-                    }\n-                  } else {\n-                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n-                  }\n-                  token = eatTokensUntilEOL(token);\n-                  continue retry;\n-\n-                case HIDDEN:\n-                  if (!jsdocBuilder.recordHiddenness()) {\n-                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case LENDS:\n-                  skipEOLs();\n-\n-                  matchingRc = false;\n-                  if (match(JsDocToken.LC)) {\n-                    token = next();\n-                    matchingRc = true;\n-                  }\n-\n-                  if (match(JsDocToken.STRING)) {\n-                    token = next();\n-                    if (!jsdocBuilder.recordLends(stream.getString())) {\n-                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n-                          stream.getLineno(), stream.getCharno());\n-                    }\n-                  } else {\n-                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-\n-                  if (matchingRc && !match(JsDocToken.RC)) {\n-                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case MEANING:\n-                  ExtractionInfo meaningInfo =\n-                      extractMultilineTextualBlock(token);\n-                  String meaning = meaningInfo.string;\n-                  token = meaningInfo.token;\n-                  if (!jsdocBuilder.recordMeaning(meaning)) {\n-                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  continue retry;\n-\n-                case NO_ALIAS:\n-                  if (!jsdocBuilder.recordNoAlias()) {\n-                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case NO_COMPILE:\n-                  if (!jsdocBuilder.recordNoCompile()) {\n-                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case NO_TYPE_CHECK:\n-                  if (!jsdocBuilder.recordNoTypeCheck()) {\n-                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case NOT_IMPLEMENTED:\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case INHERIT_DOC:\n-                case OVERRIDE:\n-                  if (!jsdocBuilder.recordOverride()) {\n-                    parser.addTypeWarning(\"msg.jsdoc.override\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case THROWS:\n-                  skipEOLs();\n-                  token = next();\n-                  lineno = stream.getLineno();\n-                  charno = stream.getCharno();\n-                  type = null;\n-\n-                  if (token == JsDocToken.LC) {\n-                    type = createJSTypeExpression(\n-                        parseAndRecordTypeNode(token));\n-\n-                    if (type == null) {\n-                      // parsing error reported during recursive descent\n-                      // recovering parsing\n-                      token = eatTokensUntilEOL();\n-                      continue retry;\n-                    }\n-                  }\n-\n-                  // *Update* the token to that after the type annotation.\n-                  token = current();\n-\n-                  // Save the throw type.\n-                  jsdocBuilder.recordThrowType(type);\n-\n-                  // Find the throw's description (if applicable).\n-                  if (jsdocBuilder.shouldParseDocumentation()) {\n-                    ExtractionInfo descriptionInfo =\n-                        extractMultilineTextualBlock(token);\n-\n-                    String description = descriptionInfo.string;\n-\n-                    if (description.length() > 0) {\n-                      jsdocBuilder.recordThrowDescription(type, description);\n-                    }\n-\n-                    token = descriptionInfo.token;\n-                  } else {\n-                    token = eatTokensUntilEOL(token);\n-                  }\n-                  continue retry;\n-\n-                case PARAM:\n-                  skipEOLs();\n-                  token = next();\n-                  lineno = stream.getLineno();\n-                  charno = stream.getCharno();\n-                  type = null;\n-\n-                  if (token == JsDocToken.LC) {\n-                    type = createJSTypeExpression(\n-                        parseAndRecordParamTypeNode(token));\n-\n-                    if (type == null) {\n-                      // parsing error reported during recursive descent\n-                      // recovering parsing\n-                      token = eatTokensUntilEOL();\n-                      continue retry;\n-                    }\n-                    skipEOLs();\n-                    token = next();\n-                    lineno = stream.getLineno();\n-                    charno = stream.getCharno();\n-                  }\n-\n-                  String name = null;\n-                  boolean isBracketedParam = JsDocToken.LB == token;\n-                  if (isBracketedParam) {\n-                    token = next();\n-                  }\n-\n-                  if (JsDocToken.STRING != token) {\n-                    parser.addTypeWarning(\"msg.missing.variable.name\",\n-                        lineno, charno);\n-                  } else {\n-                    name = stream.getString();\n-\n-                    if (isBracketedParam) {\n-                      token = next();\n-\n-                      // Throw out JsDocToolkit's \"default\" parameter\n-                      // annotation.  It makes no sense under our type\n-                      // system.\n-                      if (JsDocToken.EQUALS == token) {\n-                        token = next();\n-                        if (JsDocToken.STRING == token) {\n-                          token = next();\n-                        }\n-                      }\n-\n-                      if (JsDocToken.RB != token) {\n-                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n-                      } else if (type != null) {\n-                        // Make the type expression optional, if it isn't\n-                        // already.\n-                        type = JSTypeExpression.makeOptionalArg(type);\n-                      }\n-                    }\n-\n-                    // If the param name has a DOT in it, just throw it out\n-                    // quietly. We do not handle the JsDocToolkit method\n-                    // for handling properties of params.\n-                    if (name.indexOf('.') > -1) {\n-                      name = null;\n-                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n-                      if (jsdocBuilder.hasParameter(name)) {\n-                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n-                            lineno, charno);\n-                      } else {\n-                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n-                            lineno, charno);\n-                      }\n-                    }\n-                  }\n-\n-                  if (name == null) {\n-                    token = eatTokensUntilEOL(token);\n-                    continue retry;\n-                  }\n-\n-                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n-\n-                  // Find the parameter's description (if applicable).\n-                  if (jsdocBuilder.shouldParseDocumentation()) {\n-                    ExtractionInfo paramDescriptionInfo =\n-                        extractMultilineTextualBlock(token);\n-\n-                    String paramDescription = paramDescriptionInfo.string;\n-\n-                    if (paramDescription.length() > 0) {\n-                      jsdocBuilder.recordParameterDescription(name,\n-                          paramDescription);\n-                    }\n-\n-                    token = paramDescriptionInfo.token;\n-                  } else {\n-                    token = eatTokensUntilEOL(token);\n-                  }\n-                  continue retry;\n-\n-                case PRESERVE_TRY:\n-                  if (!jsdocBuilder.recordPreserveTry()) {\n-                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case NO_SHADOW:\n-                  if (!jsdocBuilder.recordNoShadow()) {\n-                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case NO_SIDE_EFFECTS:\n-                  if (!jsdocBuilder.recordNoSideEffects()) {\n-                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case MODIFIES:\n-                  token = parseModifiesTag(next());\n-                  continue retry;\n-\n-                case IMPLICIT_CAST:\n-                  if (!jsdocBuilder.recordImplicitCast()) {\n-                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case SEE:\n-                  if (jsdocBuilder.shouldParseDocumentation()) {\n-                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n-                    String reference = referenceInfo.string;\n-\n-                    if (reference.length() == 0) {\n-                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n-                          stream.getLineno(), stream.getCharno());\n-                    } else {\n-                      jsdocBuilder.addReference(reference);\n-                    }\n-\n-                    token = referenceInfo.token;\n-                  } else {\n-                    token = eatTokensUntilEOL(token);\n-                  }\n-                  continue retry;\n-\n-                case STABLEIDGENERATOR:\n-                  if (!jsdocBuilder.recordStableIdGenerator()) {\n-                    parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n-                      stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case SUPPRESS:\n-                  token = parseSuppressTag(next());\n-                  continue retry;\n-\n-                case TEMPLATE: {\n-                  ExtractionInfo templateInfo = extractSingleLineBlock();\n-                  List<String> names = Lists.newArrayList(\n-                      Splitter.on(',')\n-                          .trimResults()\n-                          .split(templateInfo.string));\n-\n-                  if (names.size() == 0 || names.get(0).length() == 0) {\n-                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n-                          stream.getLineno(), stream.getCharno());\n-                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n-                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-\n-                  token = templateInfo.token;\n-                  continue retry;\n-                }\n-\n-                case CLASS_TEMPLATE: {\n-                  ExtractionInfo classTemplateInfo = extractSingleLineBlock();\n-                  List<String> names = Lists.newArrayList(\n-                      Splitter.on(',')\n-                          .trimResults()\n-                          .split(classTemplateInfo.string));\n-\n-                  if (names.size() == 0 || names.get(0).length() == 0) {\n-                    parser.addTypeWarning(\n-                        \"msg.jsdoc.classtemplate.missing.type.name\",\n-                        stream.getLineno(), stream.getCharno());\n-                  } else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {\n-                    parser.addTypeWarning(\n-                        \"msg.jsdoc.classtemplate.at.most.once\",\n-                        stream.getLineno(), stream.getCharno());\n-                  }\n-\n-                  token = classTemplateInfo.token;\n-                  continue retry;\n-                }\n-\n-                case IDGENERATOR:\n-                  if (!jsdocBuilder.recordIdGenerator()) {\n-                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n-                      stream.getLineno(), stream.getCharno());\n-                  }\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-\n-                case VERSION:\n-                  ExtractionInfo versionInfo = extractSingleLineBlock();\n-                  String version = versionInfo.string;\n-\n-                  if (version.length() == 0) {\n-                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n-                          stream.getLineno(), stream.getCharno());\n-                  } else {\n-                    if (!jsdocBuilder.recordVersion(version)) {\n-                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n-                          stream.getLineno(), stream.getCharno());\n-                    }\n-                  }\n-\n-                  token = versionInfo.token;\n-                  continue retry;\n-\n-                case CONSTANT:\n-                case DEFINE:\n-                case RETURN:\n-                case PRIVATE:\n-                case PROTECTED:\n-                case PUBLIC:\n-                case THIS:\n-                case TYPE:\n-                case TYPEDEF:\n-                  lineno = stream.getLineno();\n-                  charno = stream.getCharno();\n-\n-                  Node typeNode = null;\n-                  boolean hasType = lookAheadForTypeAnnotation();\n-                  boolean isAlternateTypeAnnotation =\n-                      (annotation == Annotation.PRIVATE ||\n-                       annotation == Annotation.PROTECTED ||\n-                       annotation == Annotation.PUBLIC ||\n-                       annotation == Annotation.CONSTANT);\n-                  boolean canSkipTypeAnnotation =\n-                      (isAlternateTypeAnnotation ||\n-                       annotation == Annotation.RETURN);\n-                  type = null;\n-                  if (hasType || !canSkipTypeAnnotation) {\n-                    skipEOLs();\n-                    token = next();\n-                    typeNode = parseAndRecordTypeNode(token);\n-\n-                    if (annotation == Annotation.THIS) {\n-                      typeNode = wrapNode(Token.BANG, typeNode);\n-                    }\n-                    type = createJSTypeExpression(typeNode);\n-                  }\n-\n-                  // The error was reported during recursive descent\n-                  // recovering parsing\n-                  boolean hasError = type == null && !canSkipTypeAnnotation;\n-                  if (!hasError) {\n-                    // Record types for @type.\n-                    // If the @private, @protected, or @public annotations\n-                    // have a type attached, pretend that they actually wrote:\n-                    // @type {type}\\n@private\n-                    // This will have some weird behavior in some cases\n-                    // (for example, @private can now be used as a type-cast),\n-                    // but should be mostly OK.\n-                    if ((type != null && isAlternateTypeAnnotation)\n-                        || annotation == Annotation.TYPE) {\n-                      if (!jsdocBuilder.recordType(type)) {\n-                        parser.addTypeWarning(\n-                            \"msg.jsdoc.incompat.type\", lineno, charno);\n-                      }\n-                    }\n-\n-                    switch (annotation) {\n-                      case CONSTANT:\n-                        if (!jsdocBuilder.recordConstancy()) {\n-                          parser.addParserWarning(\"msg.jsdoc.const\",\n-                              stream.getLineno(), stream.getCharno());\n-                        }\n-                        break;\n-\n-                      case DEFINE:\n-                        if (!jsdocBuilder.recordDefineType(type)) {\n-                          parser.addParserWarning(\"msg.jsdoc.define\",\n-                              lineno, charno);\n-                        }\n-                        break;\n-\n-                      case PRIVATE:\n-                        if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n-                          parser.addParserWarning(\n-                              \"msg.jsdoc.visibility.private\",\n-                              lineno, charno);\n-                        }\n-                        break;\n-\n-                      case PROTECTED:\n-                        if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n-                          parser.addParserWarning(\n-                              \"msg.jsdoc.visibility.protected\",\n-                              lineno, charno);\n-                        }\n-                        break;\n-\n-                      case PUBLIC:\n-                        if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n-                          parser.addParserWarning(\n-                              \"msg.jsdoc.visibility.public\",\n-                              lineno, charno);\n-                        }\n-                        break;\n-\n-                      case RETURN:\n-                        if (type == null) {\n-                          type = createJSTypeExpression(newNode(Token.QMARK));\n-                        }\n-\n-                        if (!jsdocBuilder.recordReturnType(type)) {\n-                          parser.addTypeWarning(\n-                              \"msg.jsdoc.incompat.type\", lineno, charno);\n-                          break;\n-                        }\n-\n-                        // Find the return's description (if applicable).\n-                        if (jsdocBuilder.shouldParseDocumentation()) {\n-                          ExtractionInfo returnDescriptionInfo =\n-                              extractMultilineTextualBlock(token);\n-\n-                          String returnDescription =\n-                              returnDescriptionInfo.string;\n-\n-                          if (returnDescription.length() > 0) {\n-                            jsdocBuilder.recordReturnDescription(\n-                                returnDescription);\n-                          }\n-\n-                          token = returnDescriptionInfo.token;\n-                        } else {\n-                          token = eatTokensUntilEOL(token);\n-                        }\n-                        continue retry;\n-\n-                      case THIS:\n-                        if (!jsdocBuilder.recordThisType(type)) {\n-                          parser.addTypeWarning(\n-                              \"msg.jsdoc.incompat.type\", lineno, charno);\n-                        }\n-                        break;\n-\n-                      case TYPEDEF:\n-                        if (!jsdocBuilder.recordTypedef(type)) {\n-                          parser.addTypeWarning(\n-                              \"msg.jsdoc.incompat.type\", lineno, charno);\n-                        }\n-                        break;\n-                    }\n-                  }\n-\n-                  token = eatTokensUntilEOL();\n-                  continue retry;\n-              }\n-            }\n-          }\n-          break;\n-\n-        case EOC:\n-          if (hasParsedFileOverviewDocInfo()) {\n-            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n-          }\n-          checkExtendedTypes(extendedTypes);\n-          return true;\n-\n-        case EOF:\n-          // discard any accumulated information\n-          jsdocBuilder.build(null);\n-          parser.addParserWarning(\"msg.unexpected.eof\",\n-              stream.getLineno(), stream.getCharno());\n-          checkExtendedTypes(extendedTypes);\n-          return false;\n-\n-        case EOL:\n-          if (state == State.SEARCHING_NEWLINE) {\n-            state = State.SEARCHING_ANNOTATION;\n-          }\n-          token = next();\n-          continue retry;\n-\n-        default:\n-          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n-            token = next();\n-            continue retry;\n-          } else {\n-            state = State.SEARCHING_NEWLINE;\n-            token = eatTokensUntilEOL();\n-            continue retry;\n-          }\n-      }\n-\n-      // next token\n-      token = next();\n-    }\n-  }\n-\n-  private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n-    for (ExtendedTypeInfo typeInfo : extendedTypes) {\n-      // If interface, record the multiple extended interfaces\n-      if (jsdocBuilder.isInterfaceRecorded()) {\n-        if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) {\n-          parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n-              typeInfo.lineno, typeInfo.charno);\n-        }\n-      } else {\n-        if (!jsdocBuilder.recordBaseType(typeInfo.type)) {\n-          parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n-              typeInfo.lineno, typeInfo.charno);\n-        }\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Parse a {@code @suppress} tag of the form\n-   * {@code @suppress&#123;warning1|warning2&#125;}.\n-   *\n-   * @param token The current token.\n-   */\n-  private JsDocToken parseSuppressTag(JsDocToken token) {\n-    if (token == JsDocToken.LC) {\n-      Set<String> suppressions = new HashSet<String>();\n-      while (true) {\n-        if (match(JsDocToken.STRING)) {\n-          String name = stream.getString();\n-          if (!suppressionNames.contains(name)) {\n-            parser.addParserWarning(\"msg.jsdoc.suppress.unknown\", name,\n-                stream.getLineno(), stream.getCharno());\n-          }\n-\n-          suppressions.add(stream.getString());\n-          token = next();\n-        } else {\n-          parser.addParserWarning(\"msg.jsdoc.suppress\",\n-              stream.getLineno(), stream.getCharno());\n-          return token;\n-        }\n-\n-        if (match(JsDocToken.PIPE)) {\n-          token = next();\n-        } else {\n-          break;\n-        }\n-      }\n-\n-      if (!match(JsDocToken.RC)) {\n-        parser.addParserWarning(\"msg.jsdoc.suppress\",\n-            stream.getLineno(), stream.getCharno());\n-      } else {\n-        token = next();\n-        if (!jsdocBuilder.recordSuppressions(suppressions)) {\n-          parser.addParserWarning(\"msg.jsdoc.suppress.duplicate\",\n-              stream.getLineno(), stream.getCharno());\n-        }\n-      }\n-    }\n-    return token;\n-  }\n-\n-  /**\n-   * Parse a {@code @modifies} tag of the form\n-   * {@code @modifies&#123;this|arguments|param&#125;}.\n-   *\n-   * @param token The current token.\n-   */\n-  private JsDocToken parseModifiesTag(JsDocToken token) {\n-    if (token == JsDocToken.LC) {\n-      Set<String> modifies = new HashSet<String>();\n-      while (true) {\n-        if (match(JsDocToken.STRING)) {\n-          String name = stream.getString();\n-          if (!modifiesAnnotationKeywords.contains(name)\n-              && !jsdocBuilder.hasParameter(name)) {\n-              parser.addParserWarning(\"msg.jsdoc.modifies.unknown\", name,\n-                  stream.getLineno(), stream.getCharno());\n-          }\n-\n-          modifies.add(stream.getString());\n-          token = next();\n-        } else {\n-          parser.addParserWarning(\"msg.jsdoc.modifies\",\n-              stream.getLineno(), stream.getCharno());\n-          return token;\n-        }\n-\n-        if (match(JsDocToken.PIPE)) {\n-          token = next();\n-        } else {\n-          break;\n-        }\n-      }\n-\n-      if (!match(JsDocToken.RC)) {\n-        parser.addParserWarning(\"msg.jsdoc.modifies\",\n-            stream.getLineno(), stream.getCharno());\n-      } else {\n-        token = next();\n-        if (!jsdocBuilder.recordModifies(modifies)) {\n-          parser.addParserWarning(\"msg.jsdoc.modifies.duplicate\",\n-              stream.getLineno(), stream.getCharno());\n-        }\n-      }\n-    }\n-    return token;\n-  }\n-\n-  /**\n-   * Looks for a type expression at the current token and if found,\n-   * returns it. Note that this method consumes input.\n-   *\n-   * @param token The current token.\n-   * @return The type expression found or null if none.\n-   */\n-  Node parseAndRecordTypeNode(JsDocToken token) {\n-    return parseAndRecordTypeNode(token, token == JsDocToken.LC);\n-  }\n-\n-  /**\n-   * Looks for a type expression at the current token and if found,\n-   * returns it. Note that this method consumes input.\n-   *\n-   * @param token The current token.\n-   * @param matchingLC Whether the type expression starts with a \"{\".\n-   * @return The type expression found or null if none.\n-   */\n-  private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) {\n-    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n-        matchingLC, false);\n-  }\n-\n-  /**\n-   * Looks for a type expression at the current token and if found,\n-   * returns it. Note that this method consumes input.\n-   *\n-   * @param token The current token.\n-   * @param lineno The line of the type expression.\n-   * @param startCharno The starting character position of the type expression.\n-   * @param matchingLC Whether the type expression starts with a \"{\".\n-   * @return The type expression found or null if none.\n-   */\n-  private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,\n-                                          int startCharno, boolean matchingLC) {\n-    return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);\n-  }\n-\n-  /**\n-   * Looks for a type expression at the current token and if found,\n-   * returns it. Note that this method consumes input.\n-   *\n-   * Parameter type expressions are special for two reasons:\n-   * <ol>\n-   *   <li>They must begin with '{', to distinguish type names from param names.\n-   *   <li>They may end in '=', to denote optionality.\n-   * </ol>\n-   *\n-   * @param token The current token.\n-   * @return The type expression found or null if none.\n-   */\n-  private Node parseAndRecordParamTypeNode(JsDocToken token) {\n-    Preconditions.checkArgument(token == JsDocToken.LC);\n-    int lineno = stream.getLineno();\n-    int startCharno = stream.getCharno();\n-\n-    Node typeNode = parseParamTypeExpressionAnnotation(token);\n-    if (typeNode != null) {\n-      int endLineno = stream.getLineno();\n-      int endCharno = stream.getCharno();\n-\n-      jsdocBuilder.markTypeNode(typeNode, lineno, startCharno,\n-          endLineno, endCharno, true);\n-    }\n-    return typeNode;\n-  }\n-\n-  /**\n-   * Looks for a parameter type expression at the current token and if found,\n-   * returns it. Note that this method consumes input.\n-   *\n-   * @param token The current token.\n-   * @param lineno The line of the type expression.\n-   * @param startCharno The starting character position of the type expression.\n-   * @param matchingLC Whether the type expression starts with a \"{\".\n-   * @param onlyParseSimpleNames If true, only simple type names are parsed\n-   *     (via a call to parseTypeNameAnnotation instead of\n-   *     parseTypeExpressionAnnotation).\n-   * @return The type expression found or null if none.\n-   */\n-  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n-                                      int startCharno,\n-                                      boolean matchingLC,\n-                                      boolean onlyParseSimpleNames) {\n-    Node typeNode = null;\n-\n-    if (onlyParseSimpleNames) {\n-      typeNode = parseTypeNameAnnotation(token);\n-    } else {\n-      typeNode = parseTypeExpressionAnnotation(token);\n-    }\n-\n-    if (typeNode != null) {\n-      int endLineno = stream.getLineno();\n-      int endCharno = stream.getCharno();\n-\n-      jsdocBuilder.markTypeNode(\n-          typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);\n-    }\n-\n-    return typeNode;\n-  }\n-\n-  /**\n-   * Converts a JSDoc token to its string representation.\n-   */\n-  private String toString(JsDocToken token) {\n-    switch (token) {\n-      case ANNOTATION:\n-        return \"@\" + stream.getString();\n-\n-      case BANG:\n-        return \"!\";\n-\n-      case COMMA:\n-        return \",\";\n-\n-      case COLON:\n-        return \":\";\n-\n-      case GT:\n-        return \">\";\n-\n-      case LB:\n-        return \"[\";\n-\n-      case LC:\n-        return \"{\";\n-\n-      case LP:\n-        return \"(\";\n-\n-      case LT:\n-        return \".<\";\n-\n-      case QMARK:\n-        return \"?\";\n-\n-      case PIPE:\n-        return \"|\";\n-\n-      case RB:\n-        return \"]\";\n-\n-      case RC:\n-        return \"}\";\n-\n-      case RP:\n-        return \")\";\n-\n-      case STAR:\n-        return \"*\";\n-\n-      case ELLIPSIS:\n-        return \"...\";\n-\n-      case EQUALS:\n-        return \"=\";\n-\n-      case STRING:\n-        return stream.getString();\n-\n-      default:\n-        throw new IllegalStateException(token.toString());\n-    }\n-  }\n-\n-  /**\n-   * Constructs a new {@code JSTypeExpression}.\n-   * @param n A node. May be null.\n-   */\n-  JSTypeExpression createJSTypeExpression(Node n) {\n-    return n == null ? null :\n-        new JSTypeExpression(n, getSourceName());\n-  }\n-\n-  /**\n-   * Tuple for returning both the string extracted and the\n-   * new token following a call to any of the extract*Block\n-   * methods.\n-   */\n-  private static class ExtractionInfo {\n-    private final String string;\n-    private final JsDocToken token;\n-\n-    public ExtractionInfo(String string, JsDocToken token) {\n-      this.string = string;\n-      this.token = token;\n-    }\n-  }\n-\n-  /**\n-   * Tuple for recording extended types\n-   */\n-  private static class ExtendedTypeInfo {\n-    final JSTypeExpression type;\n-    final int lineno;\n-    final int charno;\n-\n-    public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) {\n-      this.type = type;\n-      this.lineno = lineno;\n-      this.charno = charno;\n-    }\n-  }\n-\n-  /**\n-   * Extracts the text found on the current line starting at token. Note that\n-   * token = token.info; should be called after this method is used to update\n-   * the token properly in the parser.\n-   *\n-   * @return The extraction information.\n-   */\n-  private ExtractionInfo extractSingleLineBlock() {\n-\n-    // Get the current starting point.\n-    stream.update();\n-    int lineno = stream.getLineno();\n-    int charno = stream.getCharno() + 1;\n-\n-    String line = getRemainingJSDocLine().trim();\n-\n-    // Record the textual description.\n-    if (line.length() > 0) {\n-      jsdocBuilder.markText(line, lineno, charno, lineno,\n-                            charno + line.length());\n-    }\n-\n-    return new ExtractionInfo(line, next());\n-  }\n-\n-  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) {\n-    return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);\n-  }\n-\n-  private enum WhitespaceOption {\n-    /**\n-     * Preserves all whitespace and formatting. Needed for licenses and\n-     * purposely formatted text.\n-     */\n-    PRESERVE,\n-\n-    /** Preserves newlines but trims the output. */\n-    TRIM,\n-\n-    /** Removes newlines and turns the output into a single line string. */\n-    SINGLE_LINE\n-  }\n-\n-  /**\n-   * Extracts the text found on the current line and all subsequent\n-   * until either an annotation, end of comment or end of file is reached.\n-   * Note that if this method detects an end of line as the first token, it\n-   * will quit immediately (indicating that there is no text where it was\n-   * expected).  Note that token = info.token; should be called after this\n-   * method is used to update the token properly in the parser.\n-   *\n-   * @param token The start token.\n-   * @param option How to handle whitespace.\n-   *\n-   * @return The extraction information.\n-   */\n-  @SuppressWarnings(\"fallthrough\")\n-  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n-                                                      WhitespaceOption option) {\n-\n-    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n-        token == JsDocToken.EOF) {\n-      return new ExtractionInfo(\"\", token);\n-    }\n-\n-    stream.update();\n-    int startLineno = stream.getLineno();\n-    int startCharno = stream.getCharno() + 1;\n-\n-    // Read the content from the first line.\n-    String line = getRemainingJSDocLine();\n-    if (option != WhitespaceOption.PRESERVE) {\n-      line = line.trim();\n-    }\n-\n-    StringBuilder builder = new StringBuilder();\n-    builder.append(line);\n-\n-    state = State.SEARCHING_ANNOTATION;\n-    token = next();\n-\n-    boolean ignoreStar = false;\n-\n-    // Track the start of the line to count whitespace that\n-    // the tokenizer skipped. Because this case is rare, it's easier\n-    // to do this here than in the tokenizer.\n-    int lineStartChar = -1;\n-\n-    do {\n-      switch (token) {\n-        case STAR:\n-          if (ignoreStar) {\n-            // Mark the position after the star as the new start of the line.\n-            lineStartChar = stream.getCharno() + 1;\n-          } else {\n-            // The star is part of the comment.\n-            if (builder.length() > 0) {\n-              builder.append(' ');\n-            }\n-\n-            builder.append('*');\n-          }\n-\n-          token = next();\n-          continue;\n-\n-        case EOL:\n-          if (option != WhitespaceOption.SINGLE_LINE) {\n-            builder.append(\"\\n\");\n-          }\n-\n-          ignoreStar = true;\n-          lineStartChar = 0;\n-          token = next();\n-          continue;\n-\n-        default:\n-          ignoreStar = false;\n-          state = State.SEARCHING_ANNOTATION;\n-\n-          boolean isEOC = token == JsDocToken.EOC;\n-          if (!isEOC) {\n-            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {\n-              int numSpaces = stream.getCharno() - lineStartChar;\n-              for (int i = 0; i < numSpaces; i++) {\n-                builder.append(' ');\n-              }\n-              lineStartChar = -1;\n-            } else if (builder.length() > 0) {\n-              // All tokens must be separated by a space.\n-              builder.append(' ');\n-            }\n-          }\n-\n-          if (token == JsDocToken.EOC ||\n-              token == JsDocToken.EOF ||\n-              // When we're capturing a license block, annotations\n-              // in the block are OK.\n-              (token == JsDocToken.ANNOTATION &&\n-               option != WhitespaceOption.PRESERVE)) {\n-            String multilineText = builder.toString();\n-\n-            if (option != WhitespaceOption.PRESERVE) {\n-              multilineText = multilineText.trim();\n-            }\n-\n-            int endLineno = stream.getLineno();\n-            int endCharno = stream.getCharno();\n-\n-            if (multilineText.length() > 0) {\n-              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n-                  endLineno, endCharno);\n-            }\n-\n-            return new ExtractionInfo(multilineText, token);\n-          }\n-\n-          builder.append(toString(token));\n-\n-          line = getRemainingJSDocLine();\n-\n-          if (option != WhitespaceOption.PRESERVE) {\n-            line = trimEnd(line);\n-          }\n-\n-          builder.append(line);\n-          token = next();\n-      }\n-    } while (true);\n-  }\n-\n-\n-  /**\n-   * Extracts the top-level block comment from the JsDoc comment, if any.\n-   * This method differs from the extractMultilineTextualBlock in that it\n-   * terminates under different conditions (it doesn't have the same\n-   * prechecks), it does not first read in the remaining of the current\n-   * line and its conditions for ignoring the \"*\" (STAR) are different.\n-   *\n-   * @param token The starting token.\n-   *\n-   * @return The extraction information.\n-   */\n-  private ExtractionInfo extractBlockComment(JsDocToken token) {\n-    StringBuilder builder = new StringBuilder();\n-\n-    boolean ignoreStar = true;\n-\n-    do {\n-      switch (token) {\n-        case ANNOTATION:\n-        case EOC:\n-        case EOF:\n-          return new ExtractionInfo(builder.toString().trim(), token);\n-\n-        case STAR:\n-          if (!ignoreStar) {\n-            if (builder.length() > 0) {\n-              builder.append(' ');\n-            }\n-\n-            builder.append('*');\n-          }\n-\n-          token = next();\n-          continue;\n-\n-        case EOL:\n-          ignoreStar = true;\n-          builder.append('\\n');\n-          token = next();\n-          continue;\n-\n-        default:\n-          if (!ignoreStar && builder.length() > 0) {\n-            builder.append(' ');\n-          }\n-\n-          ignoreStar = false;\n-\n-          builder.append(toString(token));\n-\n-          String line = getRemainingJSDocLine();\n-          line = trimEnd(line);\n-          builder.append(line);\n-          token = next();\n-      }\n-    } while (true);\n-  }\n-\n-  /**\n-   * Trim characters from only the end of a string.\n-   * This method will remove all whitespace characters\n-   * (defined by Character.isWhitespace(char), in addition to the characters\n-   * provided, from the end of the provided string.\n-   *\n-   * @param s String to be trimmed\n-   * @return String with whitespace and characters in extraChars removed\n-   *                   from the end.\n-   */\n-  private static String trimEnd(String s) {\n-    int trimCount = 0;\n-    while (trimCount < s.length()) {\n-      char ch = s.charAt(s.length() - trimCount - 1);\n-      if (Character.isWhitespace(ch)) {\n-        trimCount++;\n-      } else {\n-        break;\n-      }\n-    }\n-\n-    if (trimCount == 0) {\n-      return s;\n-    }\n-    return s.substring(0, s.length() - trimCount);\n-  }\n-\n-  // Based on ES4 grammar proposed on July 10, 2008.\n-  // http://wiki.ecmascript.org/doku.php?id=spec:spec\n-  // Deliberately written to line up with the actual grammar rules,\n-  // for maximum flexibility.\n-\n-  // TODO(nicksantos): The current implementation tries to maintain backwards\n-  // compatibility with previous versions of the spec whenever we can.\n-  // We should try to gradually withdraw support for these.\n-\n-  /**\n-   * TypeExpressionAnnotation := TypeExpression |\n-   *     '{' TopLevelTypeExpression '}'\n-   */\n-  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n-    if (token == JsDocToken.LC) {\n-      skipEOLs();\n-      Node typeNode = parseTopLevelTypeExpression(next());\n-      if (typeNode != null) {\n-        skipEOLs();\n-        if (!match(JsDocToken.RC)) {\n-          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n-        } else {\n-          next();\n-        }\n-      }\n-\n-      return typeNode;\n-    } else {\n-      return parseTypeExpression(token);\n-    }\n-  }\n-\n-  /**\n-   * ParamTypeExpressionAnnotation :=\n-   *     '{' OptionalParameterType '}' |\n-   *     '{' TopLevelTypeExpression '}' |\n-   *     '{' '...' TopLevelTypeExpression '}'\n-   *\n-   * OptionalParameterType :=\n-   *     TopLevelTypeExpression '='\n-   */\n-  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {\n-    Preconditions.checkArgument(token == JsDocToken.LC);\n-\n-    skipEOLs();\n-\n-    boolean restArg = false;\n-    token = next();\n-    if (token == JsDocToken.ELLIPSIS) {\n-      token = next();\n-      if (token == JsDocToken.RC) {\n-        // EMPTY represents the UNKNOWN type in the Type AST.\n-        return wrapNode(Token.ELLIPSIS, IR.empty());\n-      }\n-      restArg = true;\n-    }\n-\n-    Node typeNode = parseTopLevelTypeExpression(token);\n-    if (typeNode != null) {\n-      skipEOLs();\n-      if (restArg) {\n-        typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n-      } else if (match(JsDocToken.EQUALS)) {\n-        next();\n-        skipEOLs();\n-        typeNode = wrapNode(Token.EQUALS, typeNode);\n-      }\n-\n-      if (!match(JsDocToken.RC)) {\n-        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n-      } else {\n-        next();\n-      }\n-    }\n-\n-    return typeNode;\n-  }\n-\n-  /**\n-   * TypeNameAnnotation := TypeName | '{' TypeName '}'\n-   */\n-  private Node parseTypeNameAnnotation(JsDocToken token) {\n-    if (token == JsDocToken.LC) {\n-      skipEOLs();\n-      Node typeNode = parseTypeName(next());\n-      if (typeNode != null) {\n-        skipEOLs();\n-        if (!match(JsDocToken.RC)) {\n-          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n-        } else {\n-          next();\n-        }\n-      }\n-\n-      return typeNode;\n-    } else {\n-      return parseTypeName(token);\n-    }\n-  }\n-\n-  /**\n-   * TopLevelTypeExpression := TypeExpression\n-   *     | TypeUnionList\n-   *\n-   * We made this rule up, for the sake of backwards compatibility.\n-   */\n-  private Node parseTopLevelTypeExpression(JsDocToken token) {\n-    Node typeExpr = parseTypeExpression(token);\n-    if (typeExpr != null) {\n-      // top-level unions are allowed\n-      if (match(JsDocToken.PIPE)) {\n-        next();\n-        if (match(JsDocToken.PIPE)) {\n-          // We support double pipes for backwards-compatibility.\n-          next();\n-        }\n-        skipEOLs();\n-        token = next();\n-        return parseUnionTypeWithAlternate(token, typeExpr);\n-      }\n-    }\n-    return typeExpr;\n-  }\n-\n-  /**\n-   * TypeExpressionList := TopLevelTypeExpression\n-   *     | TopLevelTypeExpression ',' TypeExpressionList\n-   */\n-  private Node parseTypeExpressionList(JsDocToken token) {\n-    Node typeExpr = parseTopLevelTypeExpression(token);\n-    if (typeExpr == null) {\n-      return null;\n-    }\n-    Node typeList = IR.block();\n-    typeList.addChildToBack(typeExpr);\n-    while (match(JsDocToken.COMMA)) {\n-      next();\n-      skipEOLs();\n-      typeExpr = parseTopLevelTypeExpression(next());\n-      if (typeExpr == null) {\n-        return null;\n-      }\n-      typeList.addChildToBack(typeExpr);\n-    }\n-    return typeList;\n-  }\n-\n-  /**\n-   * TypeExpression := BasicTypeExpression\n-   *     | '?' BasicTypeExpression\n-   *     | '!' BasicTypeExpression\n-   *     | BasicTypeExpression '?'\n-   *     | BasicTypeExpression '!'\n-   *     | '?'\n-   */\n-  private Node parseTypeExpression(JsDocToken token) {\n-    if (token == JsDocToken.QMARK) {\n-      // A QMARK could mean that a type is nullable, or that it's unknown.\n-      // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n-      // we assume it means nullable. There are 5 cases:\n-      // {?} - right curly\n-      // {?=} - equals\n-      // {function(?, number)} - comma\n-      // {function(number, ?)} - right paren\n-      // {function(number, ...[?])} - right bracket\n-      // {function(): ?|number} - pipe\n-      // {Array.<?>} - greater than\n-      // I'm not a big fan of using look-ahead for this, but it makes\n-      // the type language a lot nicer.\n-      token = next();\n-      if (token == JsDocToken.COMMA ||\n-          token == JsDocToken.EQUALS ||\n-          token == JsDocToken.RB ||\n-          token == JsDocToken.RC ||\n-          token == JsDocToken.RP ||\n-          token == JsDocToken.PIPE ||\n-          token == JsDocToken.GT) {\n-        restoreLookAhead(token);\n-        return newNode(Token.QMARK);\n-      }\n-\n-      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\n-    } else if (token == JsDocToken.BANG) {\n-      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n-    } else {\n-      Node basicTypeExpr = parseBasicTypeExpression(token);\n-      if (basicTypeExpr != null) {\n-        if (match(JsDocToken.QMARK)) {\n-          next();\n-          return wrapNode(Token.QMARK, basicTypeExpr);\n-        } else if (match(JsDocToken.BANG)) {\n-          next();\n-          return wrapNode(Token.BANG, basicTypeExpr);\n-        }\n-      }\n-\n-      return basicTypeExpr;\n-    }\n-  }\n-\n-  /**\n-   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n-   *     | FunctionType | UnionType | RecordType | ArrayType\n-   */\n-  private Node parseBasicTypeExpression(JsDocToken token) {\n-    if (token == JsDocToken.STAR) {\n-      return newNode(Token.STAR);\n-    } else if (token == JsDocToken.LB) {\n-      skipEOLs();\n-      return parseArrayType(next());\n-    } else if (token == JsDocToken.LC) {\n-      skipEOLs();\n-      return parseRecordType(next());\n-    } else if (token == JsDocToken.LP) {\n-      skipEOLs();\n-      return parseUnionType(next());\n-    } else if (token == JsDocToken.STRING) {\n-      String string = stream.getString();\n-      if (\"function\".equals(string)) {\n-        skipEOLs();\n-        return parseFunctionType(next());\n-      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n-        return newStringNode(string);\n-      } else {\n-        return parseTypeName(token);\n-      }\n-    }\n-\n-    restoreLookAhead(token);\n-    return reportGenericTypeSyntaxWarning();\n-  }\n-\n-  /**\n-   * TypeName := NameExpression | NameExpression TypeApplication\n-   * TypeApplication := '.<' TypeExpressionList '>'\n-   */\n-  private Node parseTypeName(JsDocToken token) {\n-    if (token != JsDocToken.STRING) {\n-      return reportGenericTypeSyntaxWarning();\n-    }\n-\n-    String typeName = stream.getString();\n-    int lineno = stream.getLineno();\n-    int charno = stream.getCharno();\n-    while (match(JsDocToken.EOL) &&\n-        typeName.charAt(typeName.length() - 1) == '.') {\n-      skipEOLs();\n-      if (match(JsDocToken.STRING)) {\n-        next();\n-        typeName += stream.getString();\n-      }\n-    }\n-\n-    Node typeNameNode = newStringNode(typeName, lineno, charno);\n-\n-    if (match(JsDocToken.LT)) {\n-      next();\n-      skipEOLs();\n-      Node memberType = parseTypeExpressionList(next());\n-      if (memberType != null) {\n-        typeNameNode.addChildToFront(memberType);\n-\n-        skipEOLs();\n-        if (!match(JsDocToken.GT)) {\n-          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n-        }\n-\n-        next();\n-      }\n-    }\n-    return typeNameNode;\n-  }\n-\n-  /**\n-   * FunctionType := 'function' FunctionSignatureType\n-   * FunctionSignatureType :=\n-   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n-   */\n-  private Node parseFunctionType(JsDocToken token) {\n-    // NOTE(nicksantos): We're not implementing generics at the moment, so\n-    // just throw out TypeParameters.\n-    if (token != JsDocToken.LP) {\n-      restoreLookAhead(token);\n-      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n-    }\n-\n-    Node functionType = newNode(Token.FUNCTION);\n-    Node parameters = null;\n-    skipEOLs();\n-    if (!match(JsDocToken.RP)) {\n-      token = next();\n-\n-      boolean hasParams = true;\n-      if (token == JsDocToken.STRING) {\n-        String tokenStr = stream.getString();\n-        boolean isThis = \"this\".equals(tokenStr);\n-        boolean isNew = \"new\".equals(tokenStr);\n-        if (isThis || isNew) {\n-          if (match(JsDocToken.COLON)) {\n-            next();\n-            skipEOLs();\n-            Node contextType = wrapNode(\n-                isThis ? Token.THIS : Token.NEW,\n-                parseTypeName(next()));\n-            if (contextType == null) {\n-              return null;\n-            }\n-\n-            functionType.addChildToFront(contextType);\n-          } else {\n-            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n-          }\n-\n-          if (match(JsDocToken.COMMA)) {\n-            next();\n-            skipEOLs();\n-            token = next();\n-          } else {\n-            hasParams = false;\n-          }\n-        }\n-      }\n-\n-      if (hasParams) {\n-        parameters = parseParametersType(token);\n-        if (parameters == null) {\n-          return null;\n-        }\n-      }\n-    }\n-\n-    if (parameters != null) {\n-      functionType.addChildToBack(parameters);\n-    }\n-\n-    skipEOLs();\n-    if (!match(JsDocToken.RP)) {\n-      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n-    }\n-\n-    skipEOLs();\n-    Node resultType = parseResultType(next());\n-    if (resultType == null) {\n-      return null;\n-    } else {\n-      functionType.addChildToBack(resultType);\n-    }\n-    return functionType;\n-  }\n-\n-  /**\n-   * ParametersType := RestParameterType | NonRestParametersType\n-   *     | NonRestParametersType ',' RestParameterType\n-   * RestParameterType := '...' Identifier\n-   * NonRestParametersType := ParameterType ',' NonRestParametersType\n-   *     | ParameterType\n-   *     | OptionalParametersType\n-   * OptionalParametersType := OptionalParameterType\n-   *     | OptionalParameterType, OptionalParametersType\n-   * OptionalParameterType := ParameterType=\n-   * ParameterType := TypeExpression | Identifier ':' TypeExpression\n-   */\n-  // NOTE(nicksantos): The official ES4 grammar forces optional and rest\n-  // arguments to come after the required arguments. Our parser does not\n-  // enforce this. Instead we allow them anywhere in the function at parse-time,\n-  // and then warn about them during type resolution.\n-  //\n-  // In theory, it might be mathematically nicer to do the order-checking here.\n-  // But in practice, the order-checking for structural functions is exactly\n-  // the same as the order-checking for @param annotations. And the latter\n-  // has to happen during type resolution. Rather than duplicate the\n-  // order-checking in two places, we just do all of it in type resolution.\n-  private Node parseParametersType(JsDocToken token) {\n-    Node paramsType = newNode(Token.PARAM_LIST);\n-    boolean isVarArgs = false;\n-    Node paramType = null;\n-    if (token != JsDocToken.RP) {\n-      do {\n-        if (paramType != null) {\n-          // skip past the comma\n-          next();\n-          skipEOLs();\n-          token = next();\n-        }\n-\n-        if (token == JsDocToken.ELLIPSIS) {\n-          // In the latest ES4 proposal, there are no type constraints allowed\n-          // on variable arguments. We support the old syntax for backwards\n-          // compatibility, but we should gradually tear it out.\n-          skipEOLs();\n-          if (match(JsDocToken.RP)) {\n-            paramType = newNode(Token.ELLIPSIS);\n-          } else {\n-            skipEOLs();\n-            if (!match(JsDocToken.LB)) {\n-              return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n-            }\n-\n-            next();\n-            skipEOLs();\n-            paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n-            skipEOLs();\n-            if (!match(JsDocToken.RB)) {\n-              return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n-            }\n-            skipEOLs();\n-            next();\n-          }\n-\n-          isVarArgs = true;\n-        } else {\n-          paramType = parseTypeExpression(token);\n-          if (match(JsDocToken.EQUALS)) {\n-            skipEOLs();\n-            next();\n-            paramType = wrapNode(Token.EQUALS, paramType);\n-          }\n-        }\n-\n-        if (paramType == null) {\n-          return null;\n-        }\n-        paramsType.addChildToBack(paramType);\n-        if (isVarArgs) {\n-          break;\n-        }\n-      } while (match(JsDocToken.COMMA));\n-    }\n-\n-    if (isVarArgs && match(JsDocToken.COMMA)) {\n-      return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");\n-    }\n-\n-    // The right paren will be checked by parseFunctionType\n-\n-    return paramsType;\n-  }\n-\n-  /**\n-   * ResultType := <empty> | ':' void | ':' TypeExpression\n-   */\n-  private Node parseResultType(JsDocToken token) {\n-    skipEOLs();\n-    if (!match(JsDocToken.COLON)) {\n-      return newNode(Token.EMPTY);\n-    }\n-\n-    token = next();\n-    skipEOLs();\n-    if (match(JsDocToken.STRING) && \"void\".equals(stream.getString())) {\n-      next();\n-      return newNode(Token.VOID);\n-    } else {\n-      return parseTypeExpression(next());\n-    }\n-  }\n-\n-  /**\n-   * UnionType := '(' TypeUnionList ')'\n-   * TypeUnionList := TypeExpression | TypeExpression '|' TypeUnionList\n-   *\n-   * We've removed the empty union type.\n-   */\n-  private Node parseUnionType(JsDocToken token) {\n-    return parseUnionTypeWithAlternate(token, null);\n-  }\n-\n-  /**\n-   * Create a new union type, with an alternate that has already been\n-   * parsed. The alternate may be null.\n-   */\n-  private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) {\n-    Node union = newNode(Token.PIPE);\n-    if (alternate != null) {\n-      union.addChildToBack(alternate);\n-    }\n-\n-    Node expr = null;\n-    do {\n-      if (expr != null) {\n-        skipEOLs();\n-        token = next();\n-        Preconditions.checkState(\n-            token == JsDocToken.PIPE || token == JsDocToken.COMMA);\n-\n-        boolean isPipe = token == JsDocToken.PIPE;\n-        if (isPipe && match(JsDocToken.PIPE)) {\n-          // We support double pipes for backwards compatibility.\n-          next();\n-        }\n-        skipEOLs();\n-        token = next();\n-      }\n-      expr = parseTypeExpression(token);\n-      if (expr == null) {\n-        return null;\n-      }\n-\n-      union.addChildToBack(expr);\n-      // We support commas for backwards compatibility.\n-    } while (match(JsDocToken.PIPE, JsDocToken.COMMA));\n-\n-    if (alternate == null) {\n-      skipEOLs();\n-      if (!match(JsDocToken.RP)) {\n-        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n-      }\n-      next();\n-    }\n-    return union;\n-  }\n-\n-  /**\n-   * ArrayType := '[' ElementTypeList ']'\n-   * ElementTypeList := <empty> | TypeExpression | '...' TypeExpression\n-   *     | TypeExpression ',' ElementTypeList\n-   */\n-  private Node parseArrayType(JsDocToken token) {\n-    Node array = newNode(Token.LB);\n-    Node arg = null;\n-    boolean hasVarArgs = false;\n-\n-    do {\n-      if (arg != null) {\n-        next();\n-        skipEOLs();\n-        token = next();\n-      }\n-      if (token == JsDocToken.ELLIPSIS) {\n-        arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n-        hasVarArgs = true;\n-      } else {\n-        arg = parseTypeExpression(token);\n-      }\n-\n-      if (arg == null) {\n-        return null;\n-      }\n-\n-      array.addChildToBack(arg);\n-      if (hasVarArgs) {\n-        break;\n-      }\n-      skipEOLs();\n-    } while (match(JsDocToken.COMMA));\n-\n-    if (!match(JsDocToken.RB)) {\n-      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n-    }\n-    next();\n-    return array;\n-  }\n-\n-  /**\n-   * RecordType := '{' FieldTypeList '}'\n-   */\n-  private Node parseRecordType(JsDocToken token) {\n-    Node recordType = newNode(Token.LC);\n-    Node fieldTypeList = parseFieldTypeList(token);\n-\n-    if (fieldTypeList == null) {\n-      return reportGenericTypeSyntaxWarning();\n-    }\n-\n-    skipEOLs();\n-    if (!match(JsDocToken.RC)) {\n-      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n-    }\n-\n-    next();\n-\n-    recordType.addChildToBack(fieldTypeList);\n-    return recordType;\n-  }\n-\n-  /**\n-   * FieldTypeList := FieldType | FieldType ',' FieldTypeList\n-   */\n-  private Node parseFieldTypeList(JsDocToken token) {\n-    Node fieldTypeList = newNode(Token.LB);\n-\n-    do {\n-      Node fieldType = parseFieldType(token);\n-\n-      if (fieldType == null) {\n-        return null;\n-      }\n-\n-      fieldTypeList.addChildToBack(fieldType);\n-\n-      skipEOLs();\n-      if (!match(JsDocToken.COMMA)) {\n-        break;\n-      }\n-\n-      // Move to the comma token.\n-      next();\n-\n-      // Move to the token passed the comma.\n-      skipEOLs();\n-      token = next();\n-    } while (true);\n-\n-    return fieldTypeList;\n-  }\n-\n-  /**\n-   * FieldType := FieldName | FieldName ':' TypeExpression\n-   */\n-  private Node parseFieldType(JsDocToken token) {\n-    Node fieldName = parseFieldName(token);\n-\n-    if (fieldName == null) {\n-      return null;\n-    }\n-\n-    skipEOLs();\n-    if (!match(JsDocToken.COLON)) {\n-      return fieldName;\n-    }\n-\n-    // Move to the colon.\n-    next();\n-\n-    // Move to the token after the colon and parse\n-    // the type expression.\n-    skipEOLs();\n-    Node typeExpression = parseTypeExpression(next());\n-\n-    if (typeExpression == null) {\n-      return null;\n-    }\n-\n-    Node fieldType = newNode(Token.COLON);\n-    fieldType.addChildToBack(fieldName);\n-    fieldType.addChildToBack(typeExpression);\n-    return fieldType;\n-  }\n-\n-  /**\n-   * FieldName := NameExpression | StringLiteral | NumberLiteral |\n-   * ReservedIdentifier\n-   */\n-  private Node parseFieldName(JsDocToken token) {\n-    switch (token) {\n-      case STRING:\n-        String string = stream.getString();\n-        return newStringNode(string);\n-\n-      default:\n-        return null;\n-    }\n-  }\n-\n-  private Node wrapNode(int type, Node n) {\n-    return n == null ? null :\n-        new Node(type, n, stream.getLineno(),\n-            stream.getCharno()).clonePropsFrom(templateNode);\n-  }\n-\n-  private Node newNode(int type) {\n-    return new Node(type, stream.getLineno(),\n-        stream.getCharno()).clonePropsFrom(templateNode);\n-  }\n-\n-  private Node newStringNode(String s) {\n-    return newStringNode(s, stream.getLineno(), stream.getCharno());\n-  }\n-\n-  private Node newStringNode(String s, int lineno, int charno) {\n-    Node n = Node.newString(s, lineno, charno).clonePropsFrom(templateNode);\n-    n.setLength(s.length());\n-    return n;\n-  }\n-\n-  // This is similar to IRFactory.createTemplateNode to share common props\n-  // e.g., source-name, between all nodes.\n-  private Node createTemplateNode() {\n-    // The Node type choice is arbitrary.\n-    Node templateNode = IR.script();\n-    templateNode.setStaticSourceFile(\n-      this.associatedNode != null ?\n-      this.associatedNode.getStaticSourceFile() :\n-      null);\n-    return templateNode;\n-  }\n-\n-  private Node reportTypeSyntaxWarning(String warning) {\n-    parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());\n-    return null;\n-  }\n-\n-  private Node reportGenericTypeSyntaxWarning() {\n-    return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");\n-  }\n-\n-  /**\n-   * Eats tokens until {@link JsDocToken#EOL} included, and switches back the\n-   * state to {@link State#SEARCHING_ANNOTATION}.\n-   */\n-  private JsDocToken eatTokensUntilEOL() {\n-    return eatTokensUntilEOL(next());\n-  }\n-\n-  /**\n-   * Eats tokens until {@link JsDocToken#EOL} included, and switches back the\n-   * state to {@link State#SEARCHING_ANNOTATION}.\n-   */\n-  private JsDocToken eatTokensUntilEOL(JsDocToken token) {\n-    do {\n-      if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n-          token == JsDocToken.EOF) {\n-        state = State.SEARCHING_ANNOTATION;\n-        return token;\n-      }\n-      token = next();\n-    } while (true);\n-  }\n-\n-  /**\n-   * Specific value indicating that the {@link #unreadToken} contains no token.\n-   */\n-  private static final JsDocToken NO_UNREAD_TOKEN = null;\n-\n-  /**\n-   * One token buffer.\n-   */\n-  private JsDocToken unreadToken = NO_UNREAD_TOKEN;\n-\n-  /** Restores the lookahead token to the token stream */\n-  private void restoreLookAhead(JsDocToken token) {\n-    unreadToken = token;\n-  }\n-\n-  /**\n-   * Tests whether the next symbol of the token stream matches the specific\n-   * token.\n-   */\n-  private boolean match(JsDocToken token) {\n-    unreadToken = next();\n-    return unreadToken == token;\n-  }\n-\n-  /**\n-   * Tests that the next symbol of the token stream matches one of the specified\n-   * tokens.\n-   */\n-  private boolean match(JsDocToken token1, JsDocToken token2) {\n-    unreadToken = next();\n-    return unreadToken == token1 || unreadToken == token2;\n-  }\n-\n-  /**\n-   * Gets the next token of the token stream or the buffered token if a matching\n-   * was previously made.\n-   */\n-  private JsDocToken next() {\n-    if (unreadToken == NO_UNREAD_TOKEN) {\n-      return stream.getJsDocToken();\n-    } else {\n-      return current();\n-    }\n-  }\n-\n-  /**\n-   * Gets the current token, invalidating it in the process.\n-   */\n-  private JsDocToken current() {\n-    JsDocToken t = unreadToken;\n-    unreadToken = NO_UNREAD_TOKEN;\n-    return t;\n-  }\n-\n-  /**\n-   * Skips all EOLs and all empty lines in the JSDoc. Call this method if you\n-   * want the JSDoc entry to span multiple lines.\n-   */\n-  private void skipEOLs() {\n-    while (match(JsDocToken.EOL)) {\n-      next();\n-      if (match(JsDocToken.STAR)) {\n-        next();\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Returns the remainder of the line.\n-   */\n-  private String getRemainingJSDocLine() {\n-    String result = stream.getRemainingJSDocLine();\n-    return result;\n-  }\n-\n-  /**\n-   * Determines whether the parser has been populated with docinfo with a\n-   * fileoverview tag.\n-   */\n-  private boolean hasParsedFileOverviewDocInfo() {\n-    return jsdocBuilder.isPopulatedWithFileOverview();\n-  }\n-\n-  boolean hasParsedJSDocInfo() {\n-    return jsdocBuilder.isPopulated();\n-  }\n-\n-  JSDocInfo retrieveAndResetParsedJSDocInfo() {\n-    return jsdocBuilder.build(associatedNode);\n-  }\n-\n-  /**\n-   * Gets the fileoverview JSDocInfo, if any.\n-   */\n-  JSDocInfo getFileOverviewJSDocInfo() {\n-    return fileOverviewJSDocInfo;\n-  }\n-\n-  /**\n-   * Look ahead for a type annotation by advancing the character stream.\n-   * Does not modify the token stream.\n-   * This is kind of a hack, and is only necessary because we use the token\n-   * stream to parse types, but need the underlying character stream to get\n-   * JsDoc descriptions.\n-   * @return Whether we found a type annotation.\n-   */\n-  private boolean lookAheadForTypeAnnotation() {\n-    boolean matchedLc = false;\n-    int c;\n-    while (true) {\n-      c = stream.getChar();\n-      if (c == ' ') {\n-        continue;\n-      } else if (c == '{') {\n-        matchedLc = true;\n-        break;\n-      } else {\n-        break;\n-      }\n-    }\n-    stream.ungetChar(c);\n-    return matchedLc;\n-  }\n-}",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 125,
    "bugId": 32,
    "name": "Patch_94_51",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_1/src/com/google/javascript/rhino/Node.java\t2019-08-11 11:54:23.043997768 -0400\n+++ /tmp/Arja_Defects4J_Closure_1/patches_a0it/Patch_51/patched/com/google/javascript/rhino/Node.java\t2019-08-11 12:08:51.390623499 -0400\n@@ -1408,11 +1408,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return toString(true, true, true);\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_1/src/com/google/javascript/jscomp/RemoveUnusedVars.java\t2019-08-11 11:54:25.391997717 -0400\n+++ /tmp/Arja_Defects4J_Closure_1/patches_a0it/Patch_51/patched/com/google/javascript/jscomp/RemoveUnusedVars.java\t2019-08-11 12:08:51.406623561 -0400\n@@ -393,12 +393,7 @@\n       Node lastArg;\n       while ((lastArg = argList.getLastChild()) != null) {\n         Var var = fnScope.getVar(lastArg.getString());\n-        if (!referenced.contains(var)) {\n-          argList.removeChild(lastArg);\n-          compiler.reportCodeChange();\n-        } else {\n-          break;\n-        }\n+        break;\n       }\n     } else {\n       callSiteOptimizer.optimize(fnScope, referenced);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 125,
    "bugId": 32,
    "name": "Patch_4_4",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_1/src/com/google/javascript/jscomp/RemoveUnusedVars.java\t2018-12-01 20:23:53.310762130 -0500\n+++ /tmp/Kali_Defects4J_Closure_1/patches_ddtc/Patch_4/patched/tmp/Kali_Defects4J_Closure_1/src/com/google/javascript/jscomp/RemoveUnusedVars.java\t2018-12-01 20:28:10.835468285 -0500\n@@ -393,7 +393,7 @@\n       Node lastArg;\n       while ((lastArg = argList.getLastChild()) != null) {\n         Var var = fnScope.getVar(lastArg.getString());\n-        if (!referenced.contains(var)) {\n+        if (false) {\n           argList.removeChild(lastArg);\n           compiler.reportCodeChange();\n         } else {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 126,
    "bugId": 137,
    "name": "Patch_2_2",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2019-08-11 22:54:21.545844074 -0400\n+++ /tmp/Arja_Defects4J_Closure_112/patches_f37u/Patch_2/patched/com/google/javascript/jscomp/TypeInference.java\t2019-08-11 23:19:49.020314049 -0400\n@@ -1068,48 +1068,8 @@\n       for (JSType alernative : unionType.getAlternates()) {\n         maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n       }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1316,7 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n+        return null;\n       }\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 126,
    "bugId": 137,
    "name": "Patch_15_4",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2019-08-12 13:59:00.507535824 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_112/patches_oujc/Patch_4/patched/com/google/javascript/jscomp/TypeInference.java\t2019-08-12 14:24:01.887447032 -0400\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 126,
    "bugId": 137,
    "name": "Patch_17_7",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2019-08-11 17:01:56.751122884 -0400\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_gjzb/Patch_7/patched/com/google/javascript/jscomp/TypeInference.java\t2019-08-11 17:29:39.044948006 -0400\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 126,
    "bugId": 137,
    "name": "Patch_12_12",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 19:40:12.327554752 -0500\n+++ /tmp/Kali_Defects4J_Closure_112/patches_if4a/Patch_8/patched/tmp/Kali_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 19:45:21.186157736 -0500\n@@ -1144,7 +1144,7 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n+    if (false) {\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 127,
    "bugId": 136,
    "name": "Patch_5_5",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_117/src/com/google/javascript/jscomp/TypeValidator.java\t2019-08-12 00:39:03.383038824 -0400\n+++ /tmp/Arja_Defects4J_Closure_117/patches_rztv/Patch_5/patched/com/google/javascript/jscomp/TypeValidator.java\t2019-08-12 01:07:45.453554550 -0400\n@@ -748,7 +748,6 @@\n         if (objectType != null &&\n             (objectType.getConstructor() != null ||\n              objectType.isFunctionPrototypeType())) {\n-          return objectType.toString() + \".\" + propName;\n         }\n       }\n     }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 127,
    "bugId": 136,
    "name": "Patch_8_8",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_117/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2018-12-01 19:37:03.477325581 -0500\n+++ /tmp/Kali_Defects4J_Closure_117/patches_06en/Patch_3/patched/tmp/Kali_Defects4J_Closure_117/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2018-12-01 19:41:15.725715759 -0500\n@@ -1802,7 +1802,11 @@\n                   child.getLastChild());\n               break;\n             case Token.GETPROP:\n-              maybeCollectMember(child, child, null);\n+              {\n+\t\t\t\tif (true)\n+\t\t\t\t\treturn;\n+\t\t\t\tmaybeCollectMember(child, child, null);\n+\t\t\t}\n               break;\n           }\n         }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 128,
    "bugId": 151,
    "name": "Patch_5_5",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2019-08-12 03:43:27.389529829 -0400\n+++ /tmp/Arja_Defects4J_Closure_124/patches_6aox/Patch_5/patched/com/google/javascript/jscomp/ExploitAssigns.java\t2019-08-12 04:06:09.759098865 -0400\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 128,
    "bugId": 151,
    "name": "Patch_10_3",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2019-08-12 17:26:07.213263784 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_124/patches_onp5/Patch_3/patched/com/google/javascript/jscomp/ExploitAssigns.java\t2019-08-12 17:48:44.483103217 -0400\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 128,
    "bugId": 151,
    "name": "Patch_25_9",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2019-08-11 19:48:39.465269415 -0400\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_njul/Patch_9/patched/com/google/javascript/jscomp/ExploitAssigns.java\t2019-08-11 20:13:13.768316507 -0400\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 128,
    "bugId": 151,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 19:28:09.304862752 -0500\n+++ /tmp/Kali_Defects4J_Closure_124/patches_8g7z/Patch_1/patched/tmp/Kali_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 19:32:21.800741750 -0500\n@@ -211,8 +211,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n+    if (true) {\n       return false;\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 129,
    "bugId": 65,
    "name": "Patch_56_31",
    "tool": "ARJA",
    "diff": "--- /tmp/Arja_Defects4J_Closure_45/src/com/google/javascript/jscomp/NodeUtil.java\t2019-08-11 19:53:30.605182186 -0400\n+++ /tmp/Arja_Defects4J_Closure_45/patches_mag2/Patch_31/patched/com/google/javascript/jscomp/NodeUtil.java\t2019-08-11 20:16:29.228293606 -0400\n@@ -591,7 +591,7 @@\n             return false;\n           }\n         }\n-        return true;\n+        return false;\n \n       case Token.REGEXP:\n         // Return true only if all children are const.\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 129,
    "bugId": 65,
    "name": "Patch_281_95",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex be72a58..6b5e0a1 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -732,10 +732,7 @@ class RemoveUnusedVars\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;\n-            } else if (!NodeUtil.isLiteralValue(\n-                assign.assignNode.getLastChild(), true)) {\n-              assignedToUnknownValue = true;\n-            }\n+            } else assignedToUnknownValue = true;\n           }\n \n           if (assignedToUnknownValue && hasPropertyAssign) {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 129,
    "bugId": 65,
    "name": "Patch_5_5",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Closure_45/src/com/google/javascript/jscomp/RemoveUnusedVarsjava\n+++ /tmp/jKali_Defects4J_Closure_45/src/com/google/javascript/jscomp/RemoveUnusedVarsjava\n@@ -732,8 +732,8 @@\n \t\t\t\t\tfor (com.google.javascript.jscomp.RemoveUnusedVars.Assign assign : assignsByVar.get(var)) {\n \t\t\t\t\t\tif (assign.isPropertyAssign) {\n \t\t\t\t\t\t\thasPropertyAssign = true;\n-\t\t\t\t\t\t}else { \t\t\t\t\t\t\tif (!(com.google.javascript.jscomp.NodeUtil.isLiteralValue(\n-\t\t\t\t\t\t\tassign.assignNode.getLastChild(), true))) {\n+\t\t\t\t\t\t}else { \t\t\t\t\t\t\tif (true) \n+\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tassignedToUnknownValue = true;\n \t\t\t\t\t\t\t}}\n \t\t\t\t\t}\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 129,
    "bugId": 65,
    "name": "Patch_77_27",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_45/src/com/google/javascript/jscomp/NodeUtil.java\t2019-08-12 11:09:53.283307911 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_45/patches_t9am/Patch_27/patched/com/google/javascript/jscomp/NodeUtil.java\t2019-08-12 11:32:25.769211346 -0400\n@@ -591,7 +591,7 @@\n             return false;\n           }\n         }\n-        return true;\n+        return false;\n \n       case Token.REGEXP:\n         // Return true only if all children are const.\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 129,
    "bugId": 65,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_45/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:09:53.073393723 -0500\n+++ /tmp/Kali_Defects4J_Closure_45/patches_zfw4/Patch_7/patched/tmp/Kali_Defects4J_Closure_45/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:14:06.832725850 -0500\n@@ -1430,7 +1430,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 130,
    "bugId": 306,
    "name": "Patch_525_329",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 4e95ed5..51ca2f4 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -266,7 +266,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n                     // Inverse quadratic interpolation.\n                     double r1 = y0 / y2;\n                     double r2 = y1 / y2;\n-                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r1 - 1.0));\n                     p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                 }\n                 if (p > 0.0) {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 130,
    "bugId": 306,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -281,3 +281,5 @@\n                     // Fall back to bisection.\n-                    delta = 0.5 * dx;\n+                    if (y0 < 1) {\n+                        delta = 0.5 * dx;\n+                    }\n                     oldDelta = delta;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 131,
    "bugId": 287,
    "name": "Patch_354_98",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\nindex 1200544..720324c 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n@@ -159,7 +159,7 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti\n             try {\n                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 131,
    "bugId": 287,
    "name": "Patch_118_71",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\nindex 1200544..7a3dd2c 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n@@ -159,7 +159,7 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti\n             try {\n                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                optima[i] = optimizer.optimize(f, goal, min, FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 131,
    "bugId": 287,
    "name": "Patch_261_142",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\nindex 1200544..720324c 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n@@ -159,7 +159,7 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti\n             try {\n                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 132,
    "bugId": 324,
    "name": "Patch_533_251",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cb..649ea4c 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -159,7 +159,7 @@ public class Gamma implements Serializable {\n             ret = Double.NaN;\n         } else if (x == 0.0) {\n             ret = 0.0;\n-        } else if (a >= 1.0 && x > a) {\n+        } else if (a >= 1.0 && x >= a) {\n             // use regularizedGammaQ because it should converge faster in this\n             // case.\n             ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 132,
    "bugId": 324,
    "name": "Patch_485_406",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cb..649ea4c 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -159,7 +159,7 @@ public class Gamma implements Serializable {\n             ret = Double.NaN;\n         } else if (x == 0.0) {\n             ret = 0.0;\n-        } else if (a >= 1.0 && x > a) {\n+        } else if (a >= 1.0 && x >= a) {\n             // use regularizedGammaQ because it should converge faster in this\n             // case.\n             ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 133,
    "bugId": 23,
    "name": "Patch_4159_891",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex 929de4c..29c3e6c 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2535,7 +2535,7 @@ public class CategoryPlot extends Plot\n         // if the plot area is too small, just return...\n         boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n         boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n-        if (b1 || b2) {\n+        if (this.rangeGridlinesVisible || b2) {\n             return;\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 133,
    "bugId": 23,
    "name": "Patch_158_78",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Chart_26/source/org/jfree/chart/plot/CategoryPlotjava\n+++ /tmp/jMutRepair_Defects4J_Chart_26/source/org/jfree/chart/plot/CategoryPlotjava\n@@ -2535,7 +2535,7 @@\n \n \t\tboolean b1 = (area.getWidth()) <= (org.jfree.chart.plot.Plot.MINIMUM_WIDTH_TO_DRAW);\n \t\tboolean b2 = (area.getHeight()) <= (org.jfree.chart.plot.Plot.MINIMUM_HEIGHT_TO_DRAW);\n-\t\tif (b1 || b2) {\n+\t\tif ((!b1) || b2) {\n \t\t\treturn;\n \t\t}\n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 133,
    "bugId": 23,
    "name": "Patch_2377_1050",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex 929de4c..153106b 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2535,7 +2535,7 @@ public class CategoryPlot extends Plot\n         // if the plot area is too small, just return...\n         boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n         boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n-        if (b1 || b2) {\n+        if (b1 || (getRenderer() != null)) {\n             return;\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 133,
    "bugId": 23,
    "name": "Patch_2377_1050",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex 929de4c..153106b 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2535,7 +2535,7 @@ public class CategoryPlot extends Plot\n         // if the plot area is too small, just return...\n         boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n         boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n-        if (b1 || b2) {\n+        if (b1 || (getRenderer() != null)) {\n             return;\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 133,
    "bugId": 23,
    "name": "Patch_5751_2399",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/CategoryPlot.java b/source/org/jfree/chart/plot/CategoryPlot.java\nindex 929de4c..9515320 100644\n--- a/source/org/jfree/chart/plot/CategoryPlot.java\n+++ b/source/org/jfree/chart/plot/CategoryPlot.java\n@@ -2533,7 +2533,7 @@ public class CategoryPlot extends Plot\n                      PlotRenderingInfo state) {\n \n         // if the plot area is too small, just return...\n-        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n+        boolean b1 = (area.getWidth()!=MINIMUM_WIDTH_TO_DRAW);\n         boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n         if (b1 || b2) {\n             return;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 133,
    "bugId": 23,
    "name": "Patch_27_27",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Chart_26/source/org/jfree/chart/plot/CategoryPlot.java\t2018-12-01 18:42:25.640372567 -0500\n+++ /tmp/Kali_Defects4J_Chart_26/patches_oc3p/Patch_27/patched/tmp/Kali_Defects4J_Chart_26/source/org/jfree/chart/plot/CategoryPlot.java\t2018-12-01 18:44:20.936377901 -0500\n@@ -2541,7 +2541,9 @@\n \n         // record the plot area...\n         if (state == null) {\n-            // if the incoming state is null, no information will be passed\n+            if (true)\n+\t\t\t\treturn;\n+\t\t\t// if the incoming state is null, no information will be passed\n             // back to the caller - but we create a temporary state to record\n             // the plot area, since that is used later by the axes\n             state = new PlotRenderingInfo(null);\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 134,
    "bugId": 37,
    "name": "Patch_37_11",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex d1836e6..8bb0e6c 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -109,7 +109,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n         }\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n+          if (apply(c)) {\n             return true;\n           }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 134,
    "bugId": 37,
    "name": "Patch_160_37",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex d1836e6..8bb0e6c 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -109,7 +109,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n         }\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n+          if (apply(c)) {\n             return true;\n           }\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 134,
    "bugId": 37,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_12/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2018-12-01 20:20:28.174545338 -0500\n+++ /tmp/Kali_Defects4J_Closure_12/patches_onbh/Patch_1/patched/tmp/Kali_Defects4J_Closure_12/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2018-12-01 20:24:51.874374397 -0500\n@@ -397,7 +397,7 @@\n                  Predicates.\n                      <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                  false);\n-        if (pathCheck.somePathsSatisfyPredicate()) {\n+        if (true) {\n           return false;\n         }\n       }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 135,
    "bugId": 74,
    "name": "Patch_739_289",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 3fb4813..7d461dd 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1438,7 +1438,7 @@ final class TypedScopeCreator implements ScopeCreator {\n       JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n       if (valueType == null && rhsValue != null) {\n         // Determining type for #5\n-        valueType = rhsValue.getJSType();\n+        valueType = ownerNode.getJSType();\n       }\n       // Function prototypes are special.\n       // It's a common JS idiom to do:\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 136,
    "bugId": 8,
    "name": "Patch_1624_352",
    "tool": "AVATAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex ec26162..20c0a47 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4490,14 +4490,17 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                     }\n                 }\n                 \n-                    Collection c = r.getAnnotations();\n+                    if (r != null) {\n+\tCollection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n                         XYAnnotation a = (XYAnnotation) i.next();\n                         if (a instanceof XYAnnotationBoundsInfo) {\n                             includedAnnotations.add(a);\n                         }\n-                    }\n+                    }\n+}\n+\n             }\n         }\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 136,
    "bugId": 8,
    "name": "Patch_992_384",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex ec26162..20c0a47 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4490,14 +4490,17 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                     }\n                 }\n                 \n-                    Collection c = r.getAnnotations();\n+                    if (r != null) {\n+\tCollection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n                         XYAnnotation a = (XYAnnotation) i.next();\n                         if (a instanceof XYAnnotationBoundsInfo) {\n                             includedAnnotations.add(a);\n                         }\n-                    }\n+                    }\n+}\n+\n             }\n         }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 136,
    "bugId": 8,
    "name": "Patch_992_384",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex ec26162..20c0a47 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4490,14 +4490,17 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                     }\n                 }\n                 \n-                    Collection c = r.getAnnotations();\n+                    if (r != null) {\n+\tCollection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n                         XYAnnotation a = (XYAnnotation) i.next();\n                         if (a instanceof XYAnnotationBoundsInfo) {\n                             includedAnnotations.add(a);\n                         }\n-                    }\n+                    }\n+}\n+\n             }\n         }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 136,
    "bugId": 8,
    "name": "Patch_2689_1263",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex ec26162..1dd3ed6 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4490,14 +4490,17 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                     }\n                 }\n                 \n-                    Collection c = r.getAnnotations();\n+                    if (r != null) {\n+\tCollection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n                         XYAnnotation a = (XYAnnotation) i.next();\n                         if (a instanceof XYAnnotationBoundsInfo) {\n                             includedAnnotations.add(a);\n                         }\n-                    }\n+                    }\n+\t}\n+\n             }\n         }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 137,
    "bugId": 181,
    "name": "Patch_694_214",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/Fraction.java b/src/main/java/org/apache/commons/lang3/math/Fraction.java\nindex b36a156..6627221 100644\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n@@ -581,7 +581,7 @@ public final class Fraction extends Number implements Comparable<Fraction> {\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 137,
    "bugId": 181,
    "name": "Patch_59_55",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Lang_22/src/main/java/org/apache/commons/lang3/math/Fractionjava\n+++ /tmp/jMutRepair_Defects4J_Lang_22/src/main/java/org/apache/commons/lang3/math/Fractionjava\n@@ -581,7 +581,7 @@\n \tprivate static int greatestCommonDivisor(int u, int v) {\n \n \n-\t\tif (((java.lang.Math.abs(u)) <= 1) || ((java.lang.Math.abs(v)) <= 1)) {\n+\t\tif (((java.lang.Math.abs(u)) <= 1) && ((java.lang.Math.abs(v)) <= 1)) {\n \t\t\treturn 1;\n \t\t}\n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 137,
    "bugId": 181,
    "name": "Patch_50_50",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Lang_22/src/main/java/org/apache/commons/lang3/math/Fractionjava\n+++ /tmp/jKali_Defects4J_Lang_22/src/main/java/org/apache/commons/lang3/math/Fractionjava\n@@ -581,7 +581,7 @@\n \tprivate static int greatestCommonDivisor(int u, int v) {\n \n \n-\t\tif (((java.lang.Math.abs(u)) <= 1) || ((java.lang.Math.abs(v)) <= 1)) {\n+\t\tif (false) {\n \t\t\treturn 1;\n \t\t}\n \n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 137,
    "bugId": 181,
    "name": "Patch_1806_847",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/Fraction.java b/src/main/java/org/apache/commons/lang3/math/Fraction.java\nindex b36a156..0fdfc36 100644\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n@@ -581,7 +581,7 @@ public final class Fraction extends Number implements Comparable<Fraction> {\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(u)==1 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 138,
    "bugId": 31,
    "name": "Patch_60_13",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex a0f95db..488b37a 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1571,7 +1571,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     Set<String> currentPropertyNames;\n       // This can be the case if interfaceType is proxy to a non-existent\n       // object (which is a bad type annotation, but shouldn't crash).\n-      currentPropertyNames = implicitProto.getOwnPropertyNames();\n+      if (implicitProto != null) {\n+\tcurrentPropertyNames = implicitProto.getOwnPropertyNames();\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {\n@@ -1585,6 +1586,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n       }\n       currentProperties.put(name, interfaceType);\n     }\n+}\n+\n     for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n       checkInterfaceConflictProperties(t, n, functionName, properties,\n           currentProperties, iType);\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 139,
    "bugId": 163,
    "name": "Patch_1150_355",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\nindex 4d010ea..0500460 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -92,7 +92,7 @@ public abstract class CharSequenceTranslator {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+                pos += Character.charCount(Character.codePointAt(input, pt));\n             }\n         }\n     }\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 140,
    "bugId": 219,
    "name": "Patch_714_324",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 886d424..4afe443 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -877,7 +877,7 @@ public class StrBuilder implements Cloneable {\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(padChar + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 140,
    "bugId": 219,
    "name": "Patch_382_208",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 886d424..eb914c3 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -877,7 +877,7 @@ public class StrBuilder implements Cloneable {\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(padChar);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 140,
    "bugId": 219,
    "name": "Patch_1657_1032",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 886d424..4c14509 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -881,7 +881,7 @@ public class StrBuilder implements Cloneable {\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                str.getChars(0, width, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 141,
    "bugId": 92,
    "name": "Patch_15_3",
    "tool": "AVATAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex edb7805..0a20462 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1910,7 +1910,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n    * @return a number between 0.0 and 100.0\n    */\n   double getTypedPercent() {\n-    int total = nullCount + unknownCount + typedCount;\n+    int total = this.noTypeCheckSection + unknownCount + typedCount;\n     if (total == 0) {\n       return 0.0;\n     } else {\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 141,
    "bugId": 92,
    "name": "Patch_9_6",
    "tool": "TBar",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex edb7805..0a20462 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1910,7 +1910,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n    * @return a number between 0.0 and 100.0\n    */\n   double getTypedPercent() {\n-    int total = nullCount + unknownCount + typedCount;\n+    int total = this.noTypeCheckSection + unknownCount + typedCount;\n     if (total == 0) {\n       return 0.0;\n     } else {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 142,
    "bugId": 171,
    "name": "Patch_78_11",
    "tool": "AVATAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/SerializationUtils.java b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\nindex 1ee636c..8010115 100644\n--- a/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n@@ -251,23 +251,7 @@ public class SerializationUtils {\n \n         }\n \n-        /**\n-         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>\n-         * of the current <code>Thread</code> to resolve the class.\n-         * @param desc An instance of class <code>ObjectStreamClass</code>.\n-         * @return A <code>Class</code> object corresponding to <code>desc</code>.\n-         * @throws IOException Any of the usual Input/Output exceptions.\n-         * @throws ClassNotFoundException If class of a serialized object cannot be found.\n-         */\n-        @Override\n-        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n-            String name = desc.getName();\n-            try {\n-                return Class.forName(name, false, classLoader);\n-            } catch (ClassNotFoundException ex) {\n-                    return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n-            }\n-        }\n+        \n \n     }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 142,
    "bugId": 171,
    "name": "Patch_18_6",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/SerializationUtils.java b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\nindex 1ee636c..8010115 100644\n--- a/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n@@ -251,23 +251,7 @@ public class SerializationUtils {\n \n         }\n \n-        /**\n-         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>\n-         * of the current <code>Thread</code> to resolve the class.\n-         * @param desc An instance of class <code>ObjectStreamClass</code>.\n-         * @return A <code>Class</code> object corresponding to <code>desc</code>.\n-         * @throws IOException Any of the usual Input/Output exceptions.\n-         * @throws ClassNotFoundException If class of a serialized object cannot be found.\n-         */\n-        @Override\n-        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n-            String name = desc.getName();\n-            try {\n-                return Class.forName(name, false, classLoader);\n-            } catch (ClassNotFoundException ex) {\n-                    return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n-            }\n-        }\n+        \n \n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 142,
    "bugId": 171,
    "name": "Patch_165_66",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Lang_13/src/main/java/org/apache/commons/lang3/SerializationUtils.java\t2019-07-31 19:29:33.123134662 -0400\n+++ /tmp/RSRepair_Defects4J_Lang_13/patches_c9x2/Patch_66/patched/org/apache/commons/lang3/SerializationUtils.java\t2019-07-31 19:38:40.081745231 -0400\n@@ -96,7 +96,7 @@\n             return readObject;\n \n         } catch (ClassNotFoundException ex) {\n-            throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n+            return object;\n         } catch (IOException ex) {\n             throw new SerializationException(\"IOException while reading cloned object data\", ex);\n         } finally {\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 143,
    "bugId": 214,
    "name": "Patch_38_2",
    "tool": "AVATAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex ceb886e..158b8eb 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return cAvailableLocaleList.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 143,
    "bugId": 214,
    "name": "Patch_33_11",
    "tool": "FixMiner",
    "diff": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex ceb886e..aaa27dc 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,10 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        if (cAvailableLocaleSet == null) {\n+    return false;\n+}\n+return cAvailableLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 143,
    "bugId": 214,
    "name": "Patch_33_11",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex ceb886e..aaa27dc 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,10 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        if (cAvailableLocaleSet == null) {\n+    return false;\n+}\n+return cAvailableLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 143,
    "bugId": 214,
    "name": "Patch_44_17",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex ceb886e..139d9a7 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return availableLocaleList().contains(locale);\n     }\n \n     //-----------------------------------------------------------------------",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 144,
    "bugId": 285,
    "name": "Patch_34_34",
    "tool": "jMutRepair",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jMutRepair_Defects4J_Math_52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotationjava\n+++ /tmp/jMutRepair_Defects4J_Math_52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotationjava\n@@ -341,7 +341,7 @@\n \t\torg.apache.commons.math.geometry.euclidean.threed.Vector3D k = v1Su1.crossProduct(v2Su2);\n \t\torg.apache.commons.math.geometry.euclidean.threed.Vector3D u3 = u1.crossProduct(u2);\n \t\tdouble c = k.dotProduct(u3);\n-\t\tif (c == 0) {\n+\t\tif (c <= 0) {\n \n \n \t\t\torg.apache.commons.math.geometry.euclidean.threed.Vector3D v3 = org.apache.commons.math.geometry.euclidean.threed.Vector3D.crossProduct(v1, v2);\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 145,
    "bugId": 124,
    "name": "Patch_49_45",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Closure_101/src/com/google/javascript/jscomp/CompilationLeveljava\n+++ /tmp/jKali_Defects4J_Closure_101/src/com/google/javascript/jscomp/CompilationLeveljava\n@@ -91,7 +91,7 @@\n \tprivate static void applySafeCompilationOptions(com.google.javascript.jscomp.CompilerOptions options) {\n \n \n-\t\toptions.closurePass = true;\n+\n \t\toptions.variableRenaming = com.google.javascript.jscomp.VariableRenamingPolicy.LOCAL;\n \t\toptions.inlineLocalVariables = true;\n \t\toptions.checkGlobalThisLevel = com.google.javascript.jscomp.CheckLevel.OFF;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 146,
    "bugId": 253,
    "name": "Patch_92_84",
    "tool": "jKali",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jKali_Defects4J_Math_29/src/main/java/org/apache/commons/math3/linear/OpenMapRealVectorjava\n+++ /tmp/jKali_Defects4J_Math_29/src/main/java/org/apache/commons/math3/linear/OpenMapRealVectorjava\n@@ -136,8 +136,8 @@\n \t\tthis.epsilon = epsilon;\n \t\tfor (int key = 0; key < (values.length); key++) {\n \t\t\tdouble value = values[key];\n-\t\t\tif (!(isDefaultValue(value))) {\n-\t\t\t\tentries.put(key, value);\n+\t\t\tif (true) {\n+\t\t\t\tthis.entries.put(key, value);\n \t\t\t}\n \t\t}\n \t}\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 147,
    "bugId": 282,
    "name": "Patch_133_92",
    "tool": "jGenProg",
    "diff": "PATCH_DIFF_ORIG=--- /tmp/jGenProg_Defects4J_Math_60/src/main/java/org/apache/commons/math/util/ContinuedFractionjava\n+++ /tmp/jGenProg_Defects4J_Math_60/src/main/java/org/apache/commons/math/util/ContinuedFractionjava\n@@ -183,24 +183,24 @@\n \t\t\tdouble r = p2 / q2;\n \n \t\t\tif (java.lang.Double.isNaN(r)) {\n-\t\t\t\tthrow new org.apache.commons.math.ConvergenceException(\n-\t\t\t\torg.apache.commons.math.exception.util.LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, \n-\t\t\t\tx);\n-\t\t\t}\n-\t\t\trelativeError = org.apache.commons.math.util.FastMath.abs(((r / c) - 1.0));\n \n \n-\t\t\tc = p2 / q2;\n-\t\t\tp0 = p1;\n-\t\t\tp1 = p2;\n-\t\t\tq0 = q1;\n-\t\t\tq1 = q2;\n-\t\t} \n \n-\t\tif (n >= maxIterations) {\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n \t\t\tthrow new org.apache.commons.math.MaxIterationsExceededException(maxIterations, \n \t\t\torg.apache.commons.math.exception.util.LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, \n-\t\t\tx);\n+\t\t\t\tx);} \t\t\trelativeError = org.apache.commons.math.util.FastMath.abs(((r / c) - 1.0)); \t\t\tc = p2 / q2; \t\t\tp0 = p1; \t\t\tp1 = p2; \t\t\tq0 = q1; \t\t\tq1 = q2;} \t\tif (n >= maxIterations) { \t\t\tthrow new org.apache.commons.math.MaxIterationsExceededException(maxIterations, org.apache.commons.math.exception.util.LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, x);\n \t\t}\n \n \t\treturn c;\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 148,
    "bugId": 19,
    "name": "Patch_47_25",
    "tool": "FixMiner",
    "diff": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex ffd1dff..ec72351 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -876,7 +876,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n         if (start < 0) {\n             throw new IllegalArgumentException(\"Requires start >= 0.\");\n         }\n-        if (end < start) {\n+        if ((end < start) && (this.data.size() > 0)) {\n             throw new IllegalArgumentException(\"Requires start <= end.\");\n         }\n         TimeSeries copy = (TimeSeries) super.clone();",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 148,
    "bugId": 19,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -879,3 +879,5 @@\n         if (end < start) {\n-            throw new IllegalArgumentException(\"Requires start <= end.\");\n+            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) {\n+                throw new IllegalArgumentException(\"Requires start <= end.\");\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 148,
    "bugId": 19,
    "name": "Patch_47_25",
    "tool": "kPAR",
    "diff": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex ffd1dff..ec72351 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -876,7 +876,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n         if (start < 0) {\n             throw new IllegalArgumentException(\"Requires start >= 0.\");\n         }\n-        if (end < start) {\n+        if ((end < start) && (this.data.size() > 0)) {\n             throw new IllegalArgumentException(\"Requires start <= end.\");\n         }\n         TimeSeries copy = (TimeSeries) super.clone();",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 149,
    "bugId": 241,
    "name": "Patch_1_1",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\nindex 8b0993c..e301e2e 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n@@ -272,7 +272,7 @@ public class FDistribution extends AbstractRealDistribution {\n \n     /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n-        return true;\n+        return false;\n     }\n \n     /** {@inheritDoc} */",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 149,
    "bugId": 241,
    "name": "Patch_2_2",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\nindex 5d32f6e..0d279de 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n@@ -181,7 +181,7 @@ public class UniformRealDistribution extends AbstractRealDistribution {\n \n     /** {@inheritDoc} */\n     public boolean isSupportUpperBoundInclusive() {\n-        return false;\n+        return true;\n     }\n \n     /**",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 150,
    "bugId": 260,
    "name": "Patch_19_11",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\nindex 1eb0053..3f3919c 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n@@ -206,6 +206,6 @@ public abstract class ListPopulation implements Population {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+        return getChromosomes().iterator();\n     }\n }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 151,
    "bugId": 249,
    "name": "Patch_322_65",
    "tool": "FixMiner",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\nindex ce694ce..a161737 100644\n--- a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n@@ -170,7 +170,7 @@ public class MannWhitneyUTest {\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+        final double n1n2prod = n1 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 152,
    "bugId": 16,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "--- a/source/org/jfree/data/Range.java\n+++ b/source/org/jfree/data/Range.java\n@@ -334,3 +334,5 @@\n         if (!(this.lower == range.lower)) {\n-            return false;\n+            if ((org.jfree.data.Range.this.lower <= 0) || (29 < org.jfree.data.Range.this.upper)) {\n+                return false;\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 153,
    "bugId": 203,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "--- a/src/java/org/apache/commons/lang/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n@@ -192,12 +192,14 @@\n                 case 'L' :\n-                    if (dec == null\n+                    if ((1) != (val.length())) {\n+                        if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n-                        try {\n-                            return createLong(numeric);\n-                        } catch (NumberFormatException nfe) {\n-                            //Too big for a long\n+                            try {\n+                                return createLong(numeric);\n+                            } catch (NumberFormatException nfe) {\n+                                //Too big for a long\n+                            }\n+                            return createBigInteger(numeric);\n+                            \n                         }\n-                        return createBigInteger(numeric);\n-\n                     }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 153,
    "bugId": 203,
    "name": "Patch_3382_1595",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/NumberUtils.java b/src/java/org/apache/commons/lang/NumberUtils.java\nindex 18a05ef..20eb6e3 100644\n--- a/src/java/org/apache/commons/lang/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n@@ -191,8 +191,7 @@ public final class NumberUtils {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n-                        && exp == null\n-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 153,
    "bugId": 203,
    "name": "Patch_4046_2567",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/NumberUtils.java b/src/java/org/apache/commons/lang/NumberUtils.java\nindex 18a05ef..04cfc6b 100644\n--- a/src/java/org/apache/commons/lang/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n@@ -190,9 +190,9 @@ public final class NumberUtils {\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n-                    if (dec == null\n+                    if (dec != numeric || (dec == null\n                         && exp == null\n-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 154,
    "bugId": 381,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+++ b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n@@ -209,3 +209,3 @@\n             // month is largest field and being added to, such as month-day\n-        if (DateTimeUtils.isContiguous(partial)) {\n+        if ((org.joda.time.chrono.BasicMonthOfYearDateTimeField.MIN <= fieldIndex) || ((!(1 == valueToAdd)) && ((valueToAdd) != (-1)))) {\n             long instant = 0L;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 155,
    "bugId": 258,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n@@ -338,3 +338,5 @@\n             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n-                columnsToDrop.add(i);\n+                if ((2) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables)) {\n+                    columnsToDrop.add(i);\n+                }\n             }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 155,
    "bugId": 258,
    "name": "Patch_8_3",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2019-08-01 09:38:00.014590480 -0400\n+++ /tmp/RSRepair_Defects4J_Math_33/patches_myeo/Patch_3/patched/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2019-08-01 11:03:22.912709022 -0400\n@@ -335,9 +335,6 @@\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n-                columnsToDrop.add(i);\n-            }\n         }\n \n         // non-basic artificial variables\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 156,
    "bugId": 233,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -350,3 +350,5 @@\n                 for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n+                    if (org.apache.commons.math3.ode.AbstractIntegrator.this.stepHandlers.size() == orderingSign) {\n+                        handler.handleStep(interpolator, isLastStep);\n+                    }\n                 }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 156,
    "bugId": 233,
    "name": "Patch_405_243",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c..9940abf 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -124,7 +124,7 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n                                 final double maxCheckInterval,\n                                 final double convergence,\n                                 final int maxIterationCount) {\n-        addEventHandler(handler, maxCheckInterval, convergence,\n+        addEventHandler(handler, maxIterationCount, convergence,\n                         maxIterationCount,\n                         new BracketingNthOrderBrentSolver(convergence, 5));\n     }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 157,
    "bugId": 265,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -346,3 +346,5 @@\n           if (getBasicRow(col) == null) {\n-            columnsToDrop.add(col);\n+            if (0 < org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) {\n+                columnsToDrop.add(col);\n+            }\n           }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 157,
    "bugId": 265,
    "name": "Patch_3449_1703",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 02c22b5..97acd65 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -193,7 +193,7 @@ class SimplexTableau implements Serializable {\n             maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n         copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);\n         matrix.setEntry(zIndex, width - 1,\n-            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n+            maximize ? f.getConstantTerm() : -1 * f.hashCode());\n \n         if (!restrictToNonNegative) {\n             matrix.setEntry(zIndex, getSlackVariableOffset() - 1,",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 158,
    "bugId": 208,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n@@ -663,5 +663,7 @@\n         // reset time\n-        if (date.getTime() != time) {\n-            date.setTime(time);\n-            val.setTime(date);\n+        if (seconds <= org.apache.commons.lang.time.DateUtils.fields.length) {\n+            if (date.getTime() != time) {\n+                date.setTime(time);\n+                val.setTime(date);\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 158,
    "bugId": 208,
    "name": "Patch_1593_845",
    "tool": "kPAR",
    "diff": "diff --git a/src/java/org/apache/commons/lang/time/DateUtils.java b/src/java/org/apache/commons/lang/time/DateUtils.java\nindex 0dd0ded..1fb79e2 100644\n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n@@ -661,7 +661,7 @@ public class DateUtils {\n         }\n \n         // reset time\n-        if (date.getTime() != time) {\n+        if ((!round || millisecs < 500)) {\n             date.setTime(time);\n             val.setTime(date);\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 159,
    "bugId": 3,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -882,3 +882,5 @@\n         if (end < start) {\n-            throw new IllegalArgumentException(\"Requires start <= end.\");\n+            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) {\n+                throw new IllegalArgumentException(\"Requires start <= end.\");\n+            }\n         }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 159,
    "bugId": 3,
    "name": "Patch_497_311",
    "tool": "TBar",
    "diff": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex 4067e3e..a62e5fe 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -941,7 +941,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+        if (endIndex < startIndex || (endIndex < 0)) {\n             emptyRange = true;\n         }\n         if (emptyRange) {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 160,
    "bugId": 243,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -513,3 +513,5 @@\n                 !Double.isInfinite(uB[i])) {\n-                hasFiniteBounds = true;\n+                if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.checkFeasableCount == org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.iterations) {\n+                    hasFiniteBounds = true;\n+                }\n                 break;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 161,
    "bugId": 311,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -160,4 +160,6 @@\n                     if (!restrictToNonNegative) {\n-                        matrix[row][getSlackVariableOffset() - 1] =\n+                        if (org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables < height) {\n+                            matrix[row][getSlackVariableOffset() - 1] =\n                             getInvertedCoeffiecientSum(constraint.getCoefficients());\n+                        }\n                     }\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 162,
    "bugId": 209,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n@@ -243,3 +243,5 @@\n                     case '/' :\n-                            out.write('\\\\');\n+                            if (escapeSingleQuote) {\n+                                out.write('\\\\');\n+                            }\n                         out.write('/');\n",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 163,
    "bugId": 218,
    "name": "Patch_1_1",
    "tool": "Nopol",
    "diff": "a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n@@ -117,3 +117,5 @@\n         }\n-            stopTime = System.currentTimeMillis();\n+            if (org.apache.commons.lang.time.StopWatch.this.stopTime < 10) {\n+                stopTime = System.currentTimeMillis();\n+            }\n         this.runningState = STATE_STOPPED;\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 164,
    "bugId": 173,
    "name": "Patch_2058_1100",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex e043323..a708f4e 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -492,7 +492,7 @@ public class FastDateFormat extends Format {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n+                if ((tokenLen >= 4) || !(tokenLen == 2)) {\n                     rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                 } else {\n                     rule = TwoDigitYearField.INSTANCE;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 164,
    "bugId": 173,
    "name": "Patch_5849_3524",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex e043323..a708f4e 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -492,7 +492,7 @@ public class FastDateFormat extends Format {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n+                if ((tokenLen >= 4) || !(tokenLen == 2)) {\n                     rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                 } else {\n                     rule = TwoDigitYearField.INSTANCE;",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 165,
    "bugId": 178,
    "name": "Patch_154_93",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/DateUtils.java b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\nindex 9a24c00..11ed8b4 100644\n--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n@@ -262,7 +262,7 @@ public class DateUtils {\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(MODIFY_TRUNCATE) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 166,
    "bugId": 384,
    "name": "Patch_5075_2912",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 74a3802..4a93375 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -1165,7 +1165,7 @@ public abstract class DateTimeZone implements Serializable {\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+        long instantAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n         if (instantBefore == instantAfter) {\n             return instant;  // not an overlap (less than is a gap, equal is normal case)\n         }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 167,
    "bugId": 67,
    "name": "Patch_329_204",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 088a993..f73c012 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -632,7 +632,7 @@ final class NameAnalyzer implements CompilerPass {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n+          JsName name = getName(ns.name, true);\n           if (name != null) {\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 168,
    "bugId": 239,
    "name": "Patch_524_360",
    "tool": "kPAR",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/util/FastMath.java b/src/main/java/org/apache/commons/math3/util/FastMath.java\nindex d571325..ae461ce 100644\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -1538,7 +1538,7 @@ public class FastMath {\n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n+            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y < 8e298 && y > -8e298)) {\n                 return pow(-x, y);\n             }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 168,
    "bugId": 239,
    "name": "Patch_1163_932",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/util/FastMath.java b/src/main/java/org/apache/commons/math3/util/FastMath.java\nindex d571325..db7b579 100644\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -1538,7 +1538,7 @@ public class FastMath {\n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n+            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y == (long) y)) {\n                 return pow(-x, y);\n             }",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 169,
    "bugId": 61,
    "name": "Patch_27_13",
    "tool": "kPAR",
    "diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 13e1092..a04cd51 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1119,7 +1119,7 @@ class TypeInference\n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n     if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n+      ObjectType objType = ObjectType.cast(type.collapseUnion());\n       if (objType != null) {\n         for (String prop : constraintObj.getOwnPropertyNames()) {\n           JSType propType = constraintObj.getPropertyType(prop);",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 170,
    "bugId": 289,
    "name": "Patch_137_80",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 30ebfff..8eac352 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -255,7 +255,7 @@ public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMul\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n-            chiSquare += residual * residual / residualsWeights[i];\n+            chiSquare += residual * residual * residualsWeights[i];\n         }\n         return chiSquare;\n     }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 171,
    "bugId": 319,
    "name": "Patch_439_157",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/math/complex/Complex.java b/src/java/org/apache/commons/math/complex/Complex.java\nindex 3571567..ab0a394 100644\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n@@ -255,7 +255,7 @@ public class Complex implements Serializable  {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+                    ret = (Double.doubleToRawLongBits(real)>=Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 172,
    "bugId": 230,
    "name": "Patch_31_8",
    "tool": "TBar",
    "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\nindex 1570681..795cd7e 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n@@ -180,7 +180,7 @@ public class MultivariateNormalDistribution\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+        return FastMath.pow(2 * FastMath.PI, -dim / 2d) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 173,
    "bugId": 205,
    "name": "Patch_1517_899",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 13281ce..bf81de2 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1183,7 +1183,8 @@ public class StrBuilder implements Cloneable {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n-            int strLen = str.length();\n+            if (str == null) str = new String();\n+ int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);\n             } else {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 173,
    "bugId": 205,
    "name": "Patch_1732_1023",
    "tool": "TBar",
    "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 13281ce..1f64e59 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -1227,7 +1227,8 @@ public class StrBuilder implements Cloneable {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n-            int strLen = str.length();\n+            if (str == null) str = new String();\n+ int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(0, width, buffer, size);\n             } else {",
    "correctness": "C",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 174,
    "bugId": 152,
    "name": "Patch_58_16",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_127/src/com/google/javascript/rhino/Node.java\t2019-08-12 18:12:21.716140328 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_127/patches_srek/Patch_16/patched/com/google/javascript/rhino/Node.java\t2019-08-12 18:31:58.020401120 -0400\n@@ -1454,7 +1454,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return null;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 174,
    "bugId": 152,
    "name": "Patch_17_13",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2018-12-01 19:26:28.403820730 -0500\n+++ /tmp/Kali_Defects4J_Closure_127/patches_dqjd/Patch_2/patched/tmp/Kali_Defects4J_Closure_127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2018-12-01 19:32:17.257866623 -0500\n@@ -167,7 +167,7 @@\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+            if (false) {\n               removeNode(n);\n             }\n           }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 175,
    "bugId": 89,
    "name": "Patch_1760_548",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_61/src/com/google/javascript/rhino/Node.java\t2019-08-12 12:18:04.348568555 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_61/patches_5q5e/Patch_548/patched/com/google/javascript/rhino/Node.java\t2019-08-12 12:51:27.221769673 -0400\n@@ -1500,7 +1500,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return null;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 175,
    "bugId": 89,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_61/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:02:23.261437912 -0500\n+++ /tmp/Kali_Defects4J_Closure_61/patches_i9a3/Patch_1/patched/tmp/Kali_Defects4J_Closure_61/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:06:14.933474039 -0500\n@@ -1500,7 +1500,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 176,
    "bugId": 327,
    "name": "Patch_1758_558",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Math_103/src/java/org/apache/commons/math/special/Gamma.java\t2019-08-03 02:54:34.781327669 -0400\n+++ /tmp/RSRepair_Defects4J_Math_103/patches_3693/Patch_558/patched/org/apache/commons/math/special/Gamma.java\t2019-08-03 03:31:17.116602501 -0400\n@@ -167,7 +167,19 @@\n             // calculate series\n             double n = 0.0; // current element index\n             double an = 1.0 / a; // n-th element in the series\n-            double sum = an; // partial sum\n+            if (Double.isNaN(x) || (x <= 0.0)) {\n+\t\t\t\tret = Double.NaN;\n+\t\t\t} else {\n+\t\t\t\tdouble g = 607.0 / 128.0;\n+\t\t\t\tdouble sum = 0.0;\n+\t\t\t\tfor (int i = lanczos.length - 1; i > 0; --i) {\n+\t\t\t\t\tsum = sum + (lanczos[i] / (x + i));\n+\t\t\t\t}\n+\t\t\t\tsum = sum + lanczos[0];\n+\t\t\t\tdouble tmp = x + g + .5;\n+\t\t\t\tret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x);\n+\t\t\t}\n+\t\t\tdouble sum = an; // partial sum\n             while (Math.abs(an) > epsilon && n < maxIterations) {\n                 // compute next element in the series\n                 n = n + 1.0;\n@@ -177,7 +189,6 @@\n                 sum = sum + an;\n             }\n             if (n >= maxIterations) {\n-                throw new MaxIterationsExceededException(maxIterations);\n             } else {\n                 ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n             }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 177,
    "bugId": 56,
    "name": "Patch_1435_524",
    "tool": "RSRepair-A",
    "diff": "--- /tmp/RSRepair_Defects4J_Closure_31/src/com/google/javascript/rhino/Node.java\t2019-08-12 10:08:44.004413988 -0400\n+++ /tmp/RSRepair_Defects4J_Closure_31/patches_0qcr/Patch_524/patched/com/google/javascript/rhino/Node.java\t2019-08-12 10:45:53.134577540 -0400\n@@ -1456,7 +1456,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return null;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 177,
    "bugId": 56,
    "name": "Patch_11_11",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_31/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:13:04.194275237 -0500\n+++ /tmp/Kali_Defects4J_Closure_31/patches_nc61/Patch_15/patched/tmp/Kali_Defects4J_Closure_31/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:17:41.365561988 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 178,
    "bugId": 255,
    "name": "Patch_235_119",
    "tool": "GenProg-A",
    "diff": "--- /tmp/GenProg_Defects4J_Math_31/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\t2019-07-31 10:48:31.566974128 -0400\n+++ /tmp/GenProg_Defects4J_Math_31/patches_xnp9/Patch_119/patched/org/apache/commons/math3/distribution/FDistribution.java\t2019-07-31 12:18:52.469100139 -0400\n@@ -212,7 +212,8 @@\n      */\n     public double getNumericalVariance() {\n         if (!numericalVarianceIsCalculated) {\n-            numericalVariance = calculateNumericalVariance();\n+            final double logm = FastMath.log(denominatorDegreesOfFreedom);\n+\t\t\tnumericalVariance = calculateNumericalVariance();\n             numericalVarianceIsCalculated = true;\n         }\n         return numericalVariance;\n\n\n--- /tmp/GenProg_Defects4J_Math_31/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\t2019-07-31 10:48:35.794966426 -0400\n+++ /tmp/GenProg_Defects4J_Math_31/patches_xnp9/Patch_119/patched/org/apache/commons/math3/util/ContinuedFraction.java\t2019-07-31 12:18:52.481100118 -0400\n@@ -174,8 +174,7 @@\n                                                x);\n             }\n             if (Double.isNaN(hN)) {\n-                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n-                                               x);\n+                return -0.0;\n             }\n \n             if (FastMath.abs(deltaN - 1.0) < epsilon) {\n\n\n--- /tmp/GenProg_Defects4J_Math_31/src/main/java/org/apache/commons/math3/exception/MathIllegalStateException.java\t2019-07-31 10:48:31.210974776 -0400\n+++ /tmp/GenProg_Defects4J_Math_31/patches_xnp9/Patch_119/patched/org/apache/commons/math3/exception/MathIllegalStateException.java\t2019-07-31 12:18:52.489100102 -0400\n@@ -83,6 +83,6 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        return context.getMessage();\n     }\n }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 178,
    "bugId": 255,
    "name": "Patch_12_12",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Math_31/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\t2018-12-01 17:28:03.404647744 -0500\n+++ /tmp/Kali_Defects4J_Math_31/patches_cawh/Patch_8/patched/tmp/Kali_Defects4J_Math_31/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\t2018-12-01 17:47:04.616410968 -0500\n@@ -174,7 +174,9 @@\n                                                x);\n             }\n             if (Double.isNaN(hN)) {\n-                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n+                if (true)\n+\t\t\t\t\treturn -1;\n+\t\t\t\tthrow new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                                x);\n             }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 179,
    "bugId": 55,
    "name": "Patch_15_13",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_30/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:14:11.588582551 -0500\n+++ /tmp/Kali_Defects4J_Closure_30/patches_ibi6/Patch_23/patched/tmp/Kali_Defects4J_Closure_30/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:19:50.309781934 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 180,
    "bugId": 63,
    "name": "Patch_25_19",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_36/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:11:09.913552631 -0500\n+++ /tmp/Kali_Defects4J_Closure_36/patches_sqc9/Patch_15/patched/tmp/Kali_Defects4J_Closure_36/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:16:51.529177686 -0500\n@@ -1443,7 +1443,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 181,
    "bugId": 29,
    "name": "Patch_21_13",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_5/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:22:45.561145835 -0500\n+++ /tmp/Kali_Defects4J_Closure_5/patches_2yd2/Patch_13/patched/tmp/Kali_Defects4J_Closure_5/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:28:07.320900533 -0500\n@@ -1437,7 +1437,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 182,
    "bugId": 75,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_49/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:05:26.258240896 -0500\n+++ /tmp/Kali_Defects4J_Closure_49/patches_mr7r/Patch_1/patched/tmp/Kali_Defects4J_Closure_49/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:09:00.768856791 -0500\n@@ -1606,7 +1606,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 183,
    "bugId": 27,
    "name": "Patch_27_17",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_3/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2018-12-01 20:23:05.293213865 -0500\n+++ /tmp/Kali_Defects4J_Closure_3/patches_afca/Patch_1/patched/tmp/Kali_Defects4J_Closure_3/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2018-12-01 20:27:20.245687443 -0500\n@@ -402,7 +402,7 @@\n                  Predicates.\n                      <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                  false);\n-        if (pathCheck.somePathsSatisfyPredicate()) {\n+        if (true) {\n           return false;\n         }\n       }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 184,
    "bugId": 90,
    "name": "Patch_43_43",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_64/src/com/google/javascript/jscomp/StatementFusion.java\t2018-12-01 20:02:35.460405760 -0500\n+++ /tmp/Kali_Defects4J_Closure_64/patches_5224/Patch_39/patched/tmp/Kali_Defects4J_Closure_64/src/com/google/javascript/jscomp/StatementFusion.java\t2018-12-01 20:09:00.780514360 -0500\n@@ -58,7 +58,9 @@\n \n     for (Node c = block.getFirstChild(); c != null; c = c.getNext()) {\n       if (!NodeUtil.isExpressionNode(c) && c != last) {\n-        return false;\n+        if (true)\n+\t\t\treturn true;\n+\t\treturn false;\n       }\n     }\n \n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 185,
    "bugId": 162,
    "name": "Patch_41_33",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_132/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:22:54.386827891 -0500\n+++ /tmp/Kali_Defects4J_Closure_132/patches_w4ef/Patch_33/patched/tmp/Kali_Defects4J_Closure_132/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:30:37.779541625 -0500\n@@ -1443,7 +1443,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 186,
    "bugId": 54,
    "name": "Patch_25_15",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_29/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:14:05.254324224 -0500\n+++ /tmp/Kali_Defects4J_Closure_29/patches_k17t/Patch_25/patched/tmp/Kali_Defects4J_Closure_29/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:19:49.047063107 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 187,
    "bugId": 76,
    "name": "Patch_19_17",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_50/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:04:44.966484875 -0500\n+++ /tmp/Kali_Defects4J_Closure_50/patches_kngg/Patch_25/patched/tmp/Kali_Defects4J_Closure_50/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:08:37.176723600 -0500\n@@ -1606,7 +1606,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 188,
    "bugId": 149,
    "name": "Patch_1_1",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2018-12-01 19:29:26.610491418 -0500\n+++ /tmp/Kali_Defects4J_Closure_122/patches_y24k/Patch_1/patched/tmp/Kali_Defects4J_Closure_122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2018-12-01 19:34:37.203864009 -0500\n@@ -249,7 +249,7 @@\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+    if (true) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 189,
    "bugId": 101,
    "name": "Patch_15_15",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_76/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:59:32.566148849 -0500\n+++ /tmp/Kali_Defects4J_Closure_76/patches_zn81/Patch_15/patched/tmp/Kali_Defects4J_Closure_76/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:04:00.136988865 -0500\n@@ -1408,7 +1408,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 190,
    "bugId": 166,
    "name": "Patch_21_21",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_131/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:24:06.818224925 -0500\n+++ /tmp/Kali_Defects4J_Closure_131/patches_8nqz/Patch_21/patched/tmp/Kali_Defects4J_Closure_131/src/com/google/javascript/rhino/Node.java\t2018-12-01 19:31:14.392140455 -0500\n@@ -1443,7 +1443,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 191,
    "bugId": 46,
    "name": "Patch_15_13",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_20/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:17:57.727539963 -0500\n+++ /tmp/Kali_Defects4J_Closure_20/patches_rvw9/Patch_15/patched/tmp/Kali_Defects4J_Closure_20/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:23:55.741986571 -0500\n@@ -1456,7 +1456,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 192,
    "bugId": 100,
    "name": "Patch_7_7",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_72/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:00:33.809050483 -0500\n+++ /tmp/Kali_Defects4J_Closure_72/patches_31ay/Patch_9/patched/tmp/Kali_Defects4J_Closure_72/src/com/google/javascript/rhino/Node.java\t2018-12-01 20:04:09.449316711 -0500\n@@ -1421,7 +1421,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+\t\t\treturn null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  },
  {
    "id": 193,
    "bugId": 43,
    "name": "Patch_23_15",
    "tool": "Kali-A",
    "diff": "--- /tmp/Kali_Defects4J_Closure_15/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2018-12-01 20:19:39.300995017 -0500\n+++ /tmp/Kali_Defects4J_Closure_15/patches_2nqc/Patch_1/patched/tmp/Kali_Defects4J_Closure_15/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2018-12-01 20:24:11.840765515 -0500\n@@ -367,7 +367,7 @@\n                  Predicates.\n                      <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                  false);\n-        if (pathCheck.somePathsSatisfyPredicate()) {\n+        if (true) {\n           return false;\n         }\n       }\n\n\n",
    "correctness": "P",
    "faultLocalization": "n",
    "rules": [],
    "extraInformation": "",
    "references": [
      { "referenceId": 3, "fieldNames": "All except the mentioned ones!" },
      {
        "referenceId": 0,
        "fieldNames": ["id", "bugId", "rules", "extraInformation", "references"]
      }
    ]
  }
]
